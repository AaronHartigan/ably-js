(function() {
  for(var t = {FAIL_REASON_DISCONNECTED:"Connection to server temporarily unavailable", FAIL_REASON_SUSPENDED:"Connection to server unavailable", FAIL_REASON_FAILED:"Connection failed or disconnected by server", FAIL_REASON_CLOSED:"Connection closed by client", FAIL_REASON_REFUSED:"Connection refused by the server", FAIL_REASON_DETACHED:"Channel not attached", FAIL_REASON_UNKNOWN:"Channel not attached"}, o = {protocolVersion:1, HOST:"rt0.ably.io", HOST_CDN:"localhost", HOST_DEBUG:"sandbox.ably.io", 
  PATH:"/", HTTP_PORT:8092, HTTPS_PORT:443, WS_PORT:8080, WSS_PORT:443, STATIC_PATH:"/", connectTimeout:2E4, disconnectTimeout:6E4, suspendedTimeout:12E4, cometRecvTimeout:9E4, cometSendTimeout:1E4, transports:["web_socket", "flash_socket", "xhr", "jsonp"]}, A = function(a, b, c) {
    function g() {
    }
    g.prototype = b.prototype;
    a.prototype = new g;
    if(c) {
      for(var e in c) {
        a.prototype[e] = c[e]
      }
    }
  }, W = [], j = 0;j < 256;j++) {
    W[j] = (j > 15 ? "" : "0") + j.toString(16)
  }
  var w = function(a, b) {
    a instanceof Array ? (this.buffer = a, this.offset = b || 0) : (this.buffer = this.buffer || Array(8), this.offset = 0, this.setValue.apply(this, arguments))
  };
  w.MAX_INT = Math.pow(2, 53);
  w.MIN_INT = -Math.pow(2, 53);
  w.prototype = {_2scomp:function() {
    for(var a = this.buffer, b = this.offset, c = 1, g = b + 7;g >= b;g--) {
      c = (a[g] ^ 255) + c, a[g] = c & 255, c >>= 8
    }
  }, setValue:function(a, b) {
    var c = !1;
    if(arguments.length == 1) {
      if(typeof a == "number") {
        c = a < 0;
        a = Math.abs(a);
        b = a % 4294967296;
        a /= 4294967296;
        if(a > 4294967296) {
          throw new RangeError(a + " is outside Int64 range");
        }
        a |= 0
      }else {
        if(typeof a == "string") {
          a = (a + "").replace(/^0x/, ""), b = a.substr(-8), a = a.length > 8 ? a.substr(0, a.length - 8) : "", a = parseInt(a, 16), b = parseInt(b, 16)
        }else {
          throw Error(a + " must be a Number or String");
        }
      }
    }
    for(var g = this.buffer, e = this.offset, f = 7;f >= 0;f--) {
      g[e + f] = b & 255, b = f == 4 ? a : b >>> 8
    }
    c && this._2scomp()
  }, toNumber:function(a) {
    for(var b = this.buffer, c = this.offset, g = b[0] & 128, e = 0, f = 1, i = 7, d = 1;i >= 0;i--, d *= 256) {
      var h = b[c + i];
      g && (h = (h ^ 255) + f, f = h >> 8, h &= 255);
      e += h * d
    }
    if(!a && e >= w.MAX_INT) {
      return g ? -Infinity : Infinity
    }
    return g ? -e : e
  }, valueOf:function() {
    return this.toNumber(!1)
  }, toString:function(a) {
    return this.valueOf().toString(a || 10)
  }, toOctetString:function(a) {
    for(var b = Array(8), c = this.buffer, g = this.offset, e = 0;e < 8;e++) {
      b[e] = W[c[g + e]]
    }
    return b.join(a || "")
  }, inspect:function() {
    return"[Int64 value:" + this + " octets:" + this.toOctetString(" ") + "]"
  }};
  var d = {Version:"0.8.0", Type:{STOP:0, VOID:1, BOOL:2, BYTE:3, I08:3, DOUBLE:4, I16:6, I32:8, I64:10, STRING:11, UTF7:11, STRUCT:12, MAP:13, SET:14, LIST:15, UTF8:16, UTF16:17}, MessageType:{CALL:1, REPLY:2, EXCEPTION:3}, objectLength:function(a) {
    var b = 0, c;
    for(c in a) {
      a.hasOwnProperty(c) && b++
    }
    return b
  }, inherits:function(a, b) {
    function c() {
    }
    c.prototype = b.prototype;
    a.prototype = new c
  }, TException:function(a) {
    this.message = a
  }};
  d.inherits(d.TException, Error);
  d.TException.prototype.name = "TException";
  d.TApplicationExceptionType = {UNKNOWN:0, UNKNOWN_METHOD:1, INVALID_MESSAGE_TYPE:2, WRONG_METHOD_NAME:3, BAD_SEQUENCE_ID:4, MISSING_RESULT:5, INTERNAL_ERROR:6, PROTOCOL_ERROR:7};
  d.TApplicationException = function(a, b) {
    this.message = a;
    this.code = b === null ? 0 : b
  };
  d.inherits(d.TApplicationException, d.TException);
  d.TApplicationException.prototype.name = "TApplicationException";
  d.TApplicationException.prototype.read = function(a) {
    for(;;) {
      var b = a.readFieldBegin();
      if(b.ftype == d.Type.STOP) {
        break
      }
      switch(b.fid) {
        case 1:
          b.ftype == d.Type.STRING ? (b = a.readString(), this.message = b.value) : a.skip(b.ftype);
          break;
        case 2:
          b.ftype == d.Type.I32 ? (b = a.readI32(), this.code = b.value) : a.skip(b.ftype);
          break;
        default:
          a.skip(b.ftype)
      }
      a.readFieldEnd()
    }
    a.readStructEnd()
  };
  d.TApplicationException.prototype.write = function(a) {
    a.writeStructBegin("TApplicationException");
    this.message && (a.writeFieldBegin("message", d.Type.STRING, 1), a.writeString(this.getMessage()), a.writeFieldEnd());
    this.code && (a.writeFieldBegin("type", d.Type.I32, 2), a.writeI32(this.code), a.writeFieldEnd());
    a.writeFieldStop();
    a.writeStructEnd()
  };
  d.TApplicationException.prototype.getCode = function() {
    return this.code
  };
  d.TApplicationException.prototype.getMessage = function() {
    return this.message
  };
  d.TXHRTransport = function(a) {
    this.url = a;
    this.rpos = this.wpos = 0;
    this.recv_buf = this.send_buf = ""
  };
  d.TXHRTransport.prototype = {getXmlHttpRequestObject:function() {
    try {
      return new XMLHttpRequest
    }catch(a) {
    }
    try {
      return new ActiveXObject("Msxml2.XMLHTTP")
    }catch(b) {
    }
    try {
      return new ActiveXObject("Microsoft.XMLHTTP")
    }catch(c) {
    }
    throw"Your browser doesn't support the XmlHttpRequest object.";
  }, flush:function(a) {
    if(a || this.url === void 0 || this.url === "") {
      return this.send_buf
    }
    a = this.getXmlHttpRequestObject();
    a.overrideMimeType && a.overrideMimeType("application/json");
    a.open("POST", this.url, !1);
    a.send(this.send_buf);
    if(a.readyState != 4) {
      throw"encountered an unknown ajax ready state: " + a.readyState;
    }
    if(a.status != 200) {
      throw"encountered a unknown request status: " + a.status;
    }
    this.recv_buf = a.responseText;
    this.wpos = this.recv_buf_sz = this.recv_buf.length;
    this.rpos = 0
  }, jqRequest:function(a, b, c, g) {
    if(typeof jQuery === "undefined" || typeof jQuery.Deferred === "undefined") {
      throw"Thrift.js requires jQuery 1.5+ to use asynchronous requests";
    }
    var e = jQuery.Deferred(), f = jQuery._Deferred(), i = e.promise();
    i.success = i.done;
    i.error = i.fail;
    i.complete = f.done;
    b = jQuery.ajax({url:this.url, data:b, type:"POST", cache:!1, dataType:"text", context:this, success:this.jqResponse, error:function(c, b, g) {
      e.rejectWith(a, jQuery.merge([g], c.tArgs))
    }, complete:function(c, b) {
      f.resolveWith(a, [c, b])
    }});
    e.done(jQuery.makeArray(c).pop());
    b.tArgs = c;
    b.tClient = a;
    b.tRecvFn = g;
    b.tDfd = e;
    return i
  }, jqResponse:function(a, b, c) {
    this.setRecvBuffer(a);
    try {
      var g = c.tRecvFn.call(c.tClient);
      c.tDfd.resolveWith(c, jQuery.merge([g], c.tArgs))
    }catch(e) {
      c.tDfd.rejectWith(c, jQuery.merge([e], c.tArgs))
    }
  }, setRecvBuffer:function(a) {
    this.recv_buf = a;
    this.wpos = this.recv_buf_sz = this.recv_buf.length;
    this.rpos = 0
  }, isOpen:function() {
    return!0
  }, open:function() {
  }, close:function() {
  }, read:function(a) {
    var b = this.wpos - this.rpos;
    if(b === 0) {
      return""
    }
    var c = a;
    b < a && (c = b);
    a = this.read_buf.substr(this.rpos, c);
    this.rpos += c;
    return a
  }, readAll:function() {
    return this.recv_buf
  }, write:function(a) {
    this.send_buf = a
  }, getSendBuffer:function() {
    return this.send_buf
  }};
  d.TStringTransport = function(a, b) {
    this.send_buf = "";
    this.recv_buf = a || "";
    this.onFlush = b
  };
  d.TStringTransport.prototype = {flush:function() {
    if(this.onFlush) {
      this.onFlush(this.send_buf)
    }
  }, isOpen:function() {
    return!0
  }, open:function() {
  }, close:function() {
  }, read:function() {
    return this.recv_buf
  }, readAll:function() {
    return this.recv_buf
  }, write:function(a) {
    this.send_buf = a
  }};
  d.Protocol = function(a) {
    this.transport = a
  };
  d.Protocol.Type = {};
  d.Protocol.Type[d.Type.BOOL] = '"tf"';
  d.Protocol.Type[d.Type.BYTE] = '"i8"';
  d.Protocol.Type[d.Type.I16] = '"i16"';
  d.Protocol.Type[d.Type.I32] = '"i32"';
  d.Protocol.Type[d.Type.I64] = '"i64"';
  d.Protocol.Type[d.Type.DOUBLE] = '"dbl"';
  d.Protocol.Type[d.Type.STRUCT] = '"rec"';
  d.Protocol.Type[d.Type.STRING] = '"str"';
  d.Protocol.Type[d.Type.MAP] = '"map"';
  d.Protocol.Type[d.Type.LIST] = '"lst"';
  d.Protocol.Type[d.Type.SET] = '"set"';
  d.Protocol.RType = {};
  d.Protocol.RType.tf = d.Type.BOOL;
  d.Protocol.RType.i8 = d.Type.BYTE;
  d.Protocol.RType.i16 = d.Type.I16;
  d.Protocol.RType.i32 = d.Type.I32;
  d.Protocol.RType.i64 = d.Type.I64;
  d.Protocol.RType.dbl = d.Type.DOUBLE;
  d.Protocol.RType.rec = d.Type.STRUCT;
  d.Protocol.RType.str = d.Type.STRING;
  d.Protocol.RType.map = d.Type.MAP;
  d.Protocol.RType.lst = d.Type.LIST;
  d.Protocol.RType.set = d.Type.SET;
  d.Protocol.Version = 1;
  d.Protocol.prototype = {getTransport:function() {
    return this.transport
  }, writeMessageBegin:function(a, b, c) {
    this.tstack = [];
    this.tpos = [];
    this.tstack.push([d.Protocol.Version, '"' + a + '"', b, c])
  }, writeMessageEnd:function() {
    var a = this.tstack.pop();
    this.wobj = this.tstack.pop();
    this.wobj.push(a);
    this.wbuf = "[" + this.wobj.join(",") + "]";
    this.transport.write(this.wbuf)
  }, writeStructBegin:function() {
    this.tpos.push(this.tstack.length);
    this.tstack.push({})
  }, writeStructEnd:function() {
    var a = this.tpos.pop(), b = this.tstack[a], c = "{", g = !0, e;
    for(e in b) {
      g ? g = !1 : c += ",", c += e + ":" + b[e]
    }
    c += "}";
    this.tstack[a] = c
  }, writeFieldBegin:function(a, b, c) {
    this.tpos.push(this.tstack.length);
    this.tstack.push({fieldId:'"' + c + '"', fieldType:d.Protocol.Type[b]})
  }, writeFieldEnd:function() {
    var a = this.tstack.pop(), b = this.tstack.pop();
    this.tstack[this.tstack.length - 1][b.fieldId] = "{" + b.fieldType + ":" + a + "}";
    this.tpos.pop()
  }, writeFieldStop:function() {
  }, writeMapBegin:function(a, b) {
    this.tpos.push(this.tstack.length);
    this.tstack.push([d.Protocol.Type[a], d.Protocol.Type[b], 0])
  }, writeMapEnd:function() {
    var a = this.tpos.pop();
    if(a != this.tstack.length) {
      (this.tstack.length - a - 1) % 2 !== 0 && this.tstack.push("");
      this.tstack[a][this.tstack[a].length - 1] = (this.tstack.length - a - 1) / 2;
      for(var b = "}", c = !0;this.tstack.length > a + 1;) {
        var g = this.tstack.pop(), e = this.tstack.pop();
        c ? c = !1 : b = "," + b;
        isNaN(e) || (e = '"' + e + '"');
        b = e + ":" + g + b
      }
      this.tstack[a].push("{" + b);
      this.tstack[a] = "[" + this.tstack[a].join(",") + "]"
    }
  }, writeListBegin:function(a, b) {
    this.tpos.push(this.tstack.length);
    this.tstack.push([d.Protocol.Type[a], b])
  }, writeListEnd:function() {
    for(var a = this.tpos.pop();this.tstack.length > a + 1;) {
      var b = this.tstack[a + 1];
      this.tstack.splice(a + 1, 1);
      this.tstack[a].push(b)
    }
    this.tstack[a] = "[" + this.tstack[a].join(",") + "]"
  }, writeSetBegin:function(a, b) {
    this.tpos.push(this.tstack.length);
    this.tstack.push([d.Protocol.Type[a], b])
  }, writeSetEnd:function() {
    for(var a = this.tpos.pop();this.tstack.length > a + 1;) {
      var b = this.tstack[a + 1];
      this.tstack.splice(a + 1, 1);
      this.tstack[a].push(b)
    }
    this.tstack[a] = "[" + this.tstack[a].join(",") + "]"
  }, writeBool:function(a) {
    this.tstack.push(a ? 1 : 0)
  }, writeByte:function(a) {
    this.tstack.push(a)
  }, writeI16:function(a) {
    this.tstack.push(a)
  }, writeI32:function(a) {
    this.tstack.push(a)
  }, writeI64:function(a) {
    this.tstack.push(a)
  }, writeDouble:function(a) {
    this.tstack.push(a)
  }, writeString:function(a) {
    if(a === null) {
      this.tstack.push(null)
    }else {
      for(var b = "", c = 0;c < a.length;c++) {
        var g = a.charAt(c);
        b += g === '"' ? '\\"' : g === "\\" ? "\\\\" : g === "\u0008" ? "\\b" : g === "\u000c" ? "\\f" : g === "\n" ? "\\n" : g === "\r" ? "\\r" : g === "\t" ? "\\t" : g
      }
      this.tstack.push('"' + b + '"')
    }
  }, writeBinary:function(a) {
    this.writeString(a)
  }, readMessageBegin:function() {
    this.rstack = [];
    this.rpos = [];
    this.robj = typeof jQuery !== "undefined" ? jQuery.parseJSON(this.transport.readAll()) : eval(this.transport.readAll());
    var a = {}, b = this.robj.shift();
    if(b != d.Protocol.Version) {
      throw"Wrong thrift protocol version: " + b;
    }
    a.fname = this.robj.shift();
    a.mtype = this.robj.shift();
    a.rseqid = this.robj.shift();
    this.rstack.push(this.robj.shift());
    return a
  }, readMessageEnd:function() {
  }, readStructBegin:function() {
    this.rstack[this.rstack.length - 1] instanceof Array && this.rstack.push(this.rstack[this.rstack.length - 1].shift());
    return{fname:""}
  }, readStructEnd:function() {
    this.rstack[this.rstack.length - 2] instanceof Array && this.rstack.pop()
  }, readFieldBegin:function() {
    var a = {}, b = -1, c = d.Type.STOP, g;
    for(g in this.rstack[this.rstack.length - 1]) {
      if(g !== null) {
        b = parseInt(g, 10);
        this.rpos.push(this.rstack.length);
        g = this.rstack[this.rstack.length - 1][b];
        delete this.rstack[this.rstack.length - 1][b];
        this.rstack.push(g);
        break
      }
    }
    if(b != -1) {
      for(var e in this.rstack[this.rstack.length - 1]) {
        d.Protocol.RType[e] !== null && (c = d.Protocol.RType[e], this.rstack[this.rstack.length - 1] = this.rstack[this.rstack.length - 1][e])
      }
    }
    a.fname = "";
    a.ftype = c;
    a.fid = b;
    return a
  }, readFieldEnd:function() {
    for(var a = this.rpos.pop();this.rstack.length > a;) {
      this.rstack.pop()
    }
  }, readMapBegin:function() {
    var a = this.rstack.pop(), b = {};
    b.ktype = d.Protocol.RType[a.shift()];
    b.vtype = d.Protocol.RType[a.shift()];
    b.size = a.shift();
    this.rpos.push(this.rstack.length);
    this.rstack.push(a.shift());
    return b
  }, readMapEnd:function() {
    this.readFieldEnd()
  }, readListBegin:function() {
    var a = this.rstack[this.rstack.length - 1], b = {};
    b.etype = d.Protocol.RType[a.shift()];
    b.size = a.shift();
    this.rpos.push(this.rstack.length);
    this.rstack.push(a);
    return b
  }, readListEnd:function() {
    this.readFieldEnd()
  }, readSetBegin:function(a, b) {
    return this.readListBegin(a, b)
  }, readSetEnd:function() {
    return this.readListEnd()
  }, readBool:function() {
    var a = this.readI32();
    a.value = a !== null && a.value == "1" ? !0 : !1;
    return a
  }, readByte:function() {
    return this.readI32()
  }, readI16:function() {
    return this.readI32()
  }, readI32:function(a) {
    a === void 0 && (a = this.rstack[this.rstack.length - 1]);
    var b = {};
    if(a instanceof Array) {
      b.value = a.length === 0 ? void 0 : a.shift()
    }else {
      if(a instanceof Object) {
        for(var c in a) {
          if(c !== null) {
            this.rstack.push(a[c]);
            delete a[c];
            b.value = c;
            break
          }
        }
      }else {
        b.value = a, this.rstack.pop()
      }
    }
    return b
  }, readI64:function() {
    return this.readI32()
  }, readDouble:function() {
    return this.readI32()
  }, readString:function() {
    return this.readI32()
  }, readBinary:function() {
    return this.readString()
  }, skip:function() {
    throw"skip not supported yet";
  }};
  d.TJSONProtocol = function(a) {
    this.transport = a;
    this.reset()
  };
  d.TJSONProtocol.Type = {};
  d.TJSONProtocol.Type[d.Type.BOOL] = "tf";
  d.TJSONProtocol.Type[d.Type.BYTE] = "i8";
  d.TJSONProtocol.Type[d.Type.I16] = "i16";
  d.TJSONProtocol.Type[d.Type.I32] = "i32";
  d.TJSONProtocol.Type[d.Type.I64] = "i64";
  d.TJSONProtocol.Type[d.Type.DOUBLE] = "dbl";
  d.TJSONProtocol.Type[d.Type.STRUCT] = "rec";
  d.TJSONProtocol.Type[d.Type.STRING] = "str";
  d.TJSONProtocol.Type[d.Type.MAP] = "map";
  d.TJSONProtocol.Type[d.Type.LIST] = "lst";
  d.TJSONProtocol.Type[d.Type.SET] = "set";
  d.TJSONProtocol.getValueFromScope = function(a) {
    var b = a.listvalue;
    return b ? b.shift() : a.value
  };
  d.TJSONProtocol.getScopeFromScope = function(a) {
    var b = a.listvalue;
    b && (a = {value:b.shift()});
    return a
  };
  d.TJSONProtocol.prototype = {reset:function() {
    this.elementStack = []
  }, writeMessageBegin:function() {
    throw Error("TJSONProtocol: Message not supported");
  }, writeMessageEnd:function() {
  }, writeStructBegin:function() {
    this.elementStack.unshift({})
  }, writeStructEnd:function() {
    var a = this.elementStack.shift();
    this.elementStack.length == 0 ? this.transport.write(JSON.stringify(a)) : this.elementStack[0].value.push(a)
  }, writeFieldBegin:function(a, b, c) {
    this.elementStack.unshift({name:a, fieldType:d.TJSONProtocol.Type[b], fieldId:c, value:[]})
  }, writeFieldEnd:function() {
    var a = this.elementStack.shift(), b = {};
    b[a.fieldType] = a.value[0];
    this.elementStack[0][a.fieldId] = b
  }, writeFieldStop:function() {
  }, writeMapBegin:function(a, b, c) {
    this.elementStack.unshift({value:[d.TJSONProtocol.Type[a], d.TJSONProtocol.Type[b], c]})
  }, writeMapEnd:function() {
    this.elementStack[0].value.push(this.elementStack.shift().value)
  }, writeListBegin:function(a, b) {
    this.elementStack.unshift({name:name, value:[d.TJSONProtocol.Type[a], b]})
  }, writeListEnd:function() {
    this.elementStack[0].value.push(this.elementStack.shift().value)
  }, writeSetBegin:function(a, b) {
    this.elementStack.unshift({name:name, value:[d.TJSONProtocol.Type[a], b]})
  }, writeSetEnd:function() {
    this.elementStack[0].value.push(this.elementStack.shift().value)
  }, writeBool:function(a) {
    this.elementStack[0].value.push(a ? 1 : 0)
  }, writeByte:function(a) {
    this.elementStack[0].value.push(a)
  }, writeI16:function(a) {
    this.elementStack[0].value.push(a)
  }, writeI32:function(a) {
    this.elementStack[0].value.push(a)
  }, writeI64:function(a) {
    this.elementStack[0].value.push(a)
  }, writeDouble:function(a) {
    this.elementStack[0].value.push(a)
  }, writeString:function(a) {
    this.elementStack[0].value.push(a)
  }, writeBinary:function(a) {
    this.elementStack[0].value.push(a)
  }, readMessageBegin:function() {
    throw Error("TJSONProtocol: Message not supported");
  }, readMessageEnd:function() {
  }, readStructBegin:function() {
    var a;
    a = this.elementStack.length == 0 ? JSON.parse(this.transport.readAll()) : d.TJSONProtocol.getValueFromScope(this.elementStack[0]);
    var b = [], c;
    for(c in a) {
      b.push(c)
    }
    this.elementStack.unshift({fields:b, value:a});
    return{fname:""}
  }, readStructEnd:function() {
    this.elementStack.shift()
  }, readFieldBegin:function() {
    var a = this.elementStack[0], b = d.TJSONProtocol.getValueFromScope(a), a = a.fields.shift();
    if(!a) {
      return{fname:"", ftype:d.Type.STOP}
    }
    var b = b[a], c;
    for(c in b) {
      return this.elementStack.unshift({value:b[c]}), {fname:"", fid:Number(a), ftype:d.Protocol.RType[c]}
    }
    throw Error("TJSONProtocol: parse error reading field value");
  }, readFieldEnd:function() {
    this.elementStack.shift()
  }, readMapBegin:function() {
    var a = d.TJSONProtocol.getValueFromScope(this.elementStack[0]), b = {ktype:d.Protocol.RType[a.shift()], vtype:d.Protocol.RType[a.shift()], size:a.shift()};
    this.elementStack.unshift({listvalue:a});
    return b
  }, readMapEnd:function() {
    this.elementStack.shift()
  }, readListBegin:function() {
    var a = d.TJSONProtocol.getValueFromScope(this.elementStack[0]), b = {etype:d.Protocol.RType[a.shift()], size:a.shift()};
    this.elementStack.unshift({listvalue:a});
    return b
  }, readListEnd:function() {
    this.elementStack.shift()
  }, readSetBegin:function() {
    var a = d.TJSONProtocol.getValueFromScope(this.elementStack[0]), b = {etype:d.Protocol.RType[a.shift()], size:a.shift()};
    this.elementStack.unshift({listvalue:a});
    return b
  }, readSetEnd:function() {
    this.elementStack.shift()
  }, readBool:function() {
    return!!d.TJSONProtocol.getValueFromScope(this.elementStack[0])
  }, readByte:function() {
    return d.TJSONProtocol.getValueFromScope(this.elementStack[0])
  }, readI16:function() {
    return d.TJSONProtocol.getValueFromScope(this.elementStack[0])
  }, readI32:function() {
    return d.TJSONProtocol.getValueFromScope(this.elementStack[0])
  }, readI64:function() {
    return d.TJSONProtocol.getValueFromScope(this.elementStack[0])
  }, readDouble:function() {
    return d.TJSONProtocol.getValueFromScope(this.elementStack[0])
  }, readString:function() {
    return d.TJSONProtocol.getValueFromScope(this.elementStack[0])
  }, readBinary:function() {
    return d.TJSONProtocol.getValueFromScope(this.elementStack[0])
  }, flush:function() {
    this.transport.flush()
  }};
  var R = {encode:function(a, b, c) {
    for(var g = c, e = 0;e < a.length;e++) {
      var f = a.charCodeAt(e);
      f < 128 ? b.setInt8(g++, f) : (f > 127 && f < 2048 ? b.setInt8(g++, f >> 6 | 192) : (b.setInt8(g++, f >> 12 | 224), b.setInt8(g++, f >> 6 & 63 | 128)), b.setInt8(g++, f & 63 | 128))
    }
    return g - c
  }, decode:function(a, b, c) {
    var g = "", e = b;
    c += b;
    for(b = c1 = c2 = 0;e < c;) {
      b = a.getInt8(e++), b < 128 ? g += String.fromCharCode(b) : b > 191 && b < 224 ? (c2 = a.getInt8(e++), g += String.fromCharCode((b & 31) << 6 | c2 & 63)) : (c2 = a.getInt8(e++), c3 = a.getInt8(e++), g += String.fromCharCode((b & 15) << 12 | (c2 & 63) << 6 | c3 & 63))
    }
    return g
  }}, r = function(a) {
    this.offset = 0;
    if(this.length = a) {
      a = this.buf = new ArrayBuffer(a), this.view = new DataView(a)
    }
  };
  r.prototype = {getArray:function() {
    if(!this.array) {
      this.array = new Uint8Array(this.buf, this.offset, this.length)
    }
    return this.array
  }, slice:function(a, b) {
    var a = a || 0, b = b || this.length, c = new r, g = c.length = b - a, e = c.offset = this.offset + a, f = c.buf = this.buf;
    c.view = new DataView(f, e, g);
    return c
  }, getInt8:function(a) {
    return this.view.getInt8(a)
  }, getInt16:function(a) {
    return this.view.getInt16(a, !1)
  }, getInt32:function(a) {
    return this.view.getInt32(a, !1)
  }, getInt64:function(a) {
    var b = this.view.getInt32(a, !1), a = this.view.getUint32(a + 4, !1);
    return new w(b, a)
  }, getFloat64:function(a) {
    return this.view.getFloat64(a, !1)
  }, getUtf8String:function(a, b) {
    return R.decode(this.view, a, b)
  }, setInt8:function(a, b) {
    this.view.setInt8(a, b)
  }, setInt16:function(a, b) {
    this.view.setInt16(a, b, !1)
  }, setInt32:function(a, b) {
    this.view.setInt32(a, b, !1)
  }, setInt64:function(a, b) {
    this.getArray().set(b.buffer, a)
  }, setFloat64:function(a, b) {
    this.view.setFloat64(a, b, !1)
  }, setBuffer:function(a, b) {
    this.getArray().set(b.getArray(), a)
  }, setUtf8String:function(a, b) {
    return R.encode(b, this.view, a)
  }, inspect:function() {
    for(var a = "length: " + this.length + "\n", b = 0;b < this.length;) {
      for(var c = 0;b < this.length && c < 32;c++) {
        a += this.view.getInt8(b++).toString(16) + " "
      }
      a += "\n"
    }
    return a
  }};
  j = d.CheckedBuffer = function(a) {
    r.call(this, a)
  };
  A(j, r, {grow:function(a) {
    var a = this.length + Math.max(a || 0, this.length * 0.41), b = getArray();
    this.buf = new ArrayBuffer(a);
    this.view = new DataView(this.buf);
    this.getArray().set(b);
    this.offset = 0;
    this.length = a
  }, checkAvailable:function(a, b) {
    a + b >= this.length && this.grow(b)
  }, setInt8:function(a, b) {
    this.checkAvailable(1);
    this.view.setInt8(a, b)
  }, setInt16:function(a, b) {
    this.checkAvailable(2);
    this.view.setInt16(a, b, !1)
  }, setInt32:function(a, b) {
    this.checkAvailable(4);
    this.view.setInt32(a, b, !1)
  }, setInt64:function(a, b) {
    this.checkAvailable(8);
    this.getArray().set(b.buffer, a)
  }, setFloat64:function(a, b) {
    this.checkAvailable(8);
    this.view.setFloat64(a, b, !1)
  }, setBuffer:function(a, b) {
    this.checkAvailable(b.length);
    this.getArray().set(b.getArray(), a)
  }, setUtf8String:function(a, b) {
    for(;;) {
      try {
        return R.encode(b, this.view, a)
      }catch(c) {
        this.grow()
      }
    }
  }});
  var n = d.Type, S = function(a, b) {
    Error.call(this, b);
    this.name = "TProtocolException";
    this.type = a
  };
  A(S, Error);
  j = d.TBinaryProtocol = function(a, b, c) {
    this.trans = a;
    this.strictRead = b !== void 0 ? b : !1;
    this.strictWrite = c !== void 0 ? c : !0
  };
  j.prototype.flush = function() {
    return this.trans.flush()
  };
  j.prototype.writeMessageBegin = function(a, b, c) {
    this.strictWrite ? (this.writeI32(-2147418112 | b), this.writeString(a)) : (this.writeString(a), this.writeByte(b));
    this.writeI32(c)
  };
  j.prototype.writeMessageEnd = function() {
  };
  j.prototype.writeStructBegin = function() {
  };
  j.prototype.writeStructEnd = function() {
  };
  j.prototype.writeFieldBegin = function(a, b, c) {
    this.writeByte(b);
    this.writeI16(c)
  };
  j.prototype.writeFieldEnd = function() {
  };
  j.prototype.writeFieldStop = function() {
    this.writeByte(n.STOP)
  };
  j.prototype.writeMapBegin = function(a, b, c) {
    this.writeByte(a);
    this.writeByte(b);
    this.writeI32(c)
  };
  j.prototype.writeMapEnd = function() {
  };
  j.prototype.writeListBegin = function(a, b) {
    this.writeByte(a);
    this.writeI32(b)
  };
  j.prototype.writeListEnd = function() {
  };
  j.prototype.writeSetBegin = function(a, b) {
    this.writeByte(a);
    this.writeI32(b)
  };
  j.prototype.writeSetEnd = function() {
  };
  j.prototype.writeBool = function(a) {
    this.writeByte(a ? 1 : 0)
  };
  j.prototype.writeByte = function(a) {
    this.trans.writeByte(a)
  };
  j.prototype.writeI16 = function(a) {
    this.trans.writeI16(a)
  };
  j.prototype.writeI32 = function(a) {
    this.trans.writeI32(a)
  };
  j.prototype.writeI64 = function(a) {
    a.buffer ? this.trans.writeI64(a) : this.trans.writeI64(new w(a))
  };
  j.prototype.writeDouble = function(a) {
    this.trans.writeDouble(a)
  };
  j.prototype.writeString = function(a) {
    this.trans.writeWithLength(a)
  };
  j.prototype.writeBinary = function(a) {
    this.trans.writeWithLength(a)
  };
  j.prototype.readMessageBegin = function() {
    var a = this.readI32(), b, c;
    if(a < 0) {
      b = a & -65536;
      if(b != -2147418112) {
        throw console.log("BAD: " + b), S(4, "Bad version in readMessageBegin: " + a);
      }
      a &= 255;
      b = this.readString()
    }else {
      if(this.strictRead) {
        throw S(4, "No protocol version header");
      }
      b = this.trans.read(a);
      a = this.readByte()
    }
    c = this.readI32();
    return{fname:b, mtype:a, rseqid:c}
  };
  j.prototype.readMessageEnd = function() {
  };
  j.prototype.readStructBegin = function() {
    return{fname:""}
  };
  j.prototype.readStructEnd = function() {
  };
  j.prototype.readFieldBegin = function() {
    var a = this.readByte();
    if(a == n.STOP) {
      return{fname:null, ftype:a, fid:0}
    }
    var b = this.readI16();
    return{fname:null, ftype:a, fid:b}
  };
  j.prototype.readFieldEnd = function() {
  };
  j.prototype.readMapBegin = function() {
    var a = this.readByte(), b = this.readByte(), c = this.readI32();
    return{ktype:a, vtype:b, size:c}
  };
  j.prototype.readMapEnd = function() {
  };
  j.prototype.readListBegin = function() {
    var a = this.readByte(), b = this.readI32();
    return{etype:a, size:b}
  };
  j.prototype.readListEnd = function() {
  };
  j.prototype.readSetBegin = function() {
    var a = this.readByte(), b = this.readI32();
    return{etype:a, size:b}
  };
  j.prototype.readSetEnd = function() {
  };
  j.prototype.readBool = function() {
    if(this.readByte() == 0) {
      return!1
    }
    return!0
  };
  j.prototype.readByte = function() {
    return this.trans.readByte()
  };
  j.prototype.readI16 = function() {
    return this.trans.readI16()
  };
  j.prototype.readI32 = function() {
    return this.trans.readI32()
  };
  j.prototype.readI64 = function() {
    return this.trans.readI64()
  };
  j.prototype.readDouble = function() {
    return this.trans.readDouble()
  };
  j.prototype.readBinary = function() {
    return this.trans.read(this.readI32())
  };
  j.prototype.readString = function() {
    return this.trans.readString(this.readI32())
  };
  j.prototype.getTransport = function() {
    return this.trans
  };
  j.prototype.skip = function(a) {
    switch(a) {
      case n.STOP:
        break;
      case n.BOOL:
        this.readBool();
        break;
      case n.BYTE:
        this.readByte();
        break;
      case n.I16:
        this.readI16();
        break;
      case n.I32:
        this.readI32();
        break;
      case n.I64:
        this.readI64();
        break;
      case n.DOUBLE:
        this.readDouble();
        break;
      case n.STRING:
        this.readString();
        break;
      case n.STRUCT:
        for(this.readStructBegin();;) {
          a = this.readFieldBegin();
          if(a.ftype === n.STOP) {
            break
          }
          this.skip(a.ftype);
          this.readFieldEnd()
        }
        this.readStructEnd();
        break;
      case n.MAP:
        for(var a = this.readMapBegin(), b = 0;b < a.size;++b) {
          this.skip(a.ktype), this.skip(a.vtype)
        }
        this.readMapEnd();
        break;
      case n.SET:
        a = this.readSetBegin();
        for(b = 0;b < a.size;++b) {
          this.skip(a.etype)
        }
        this.readSetEnd();
        break;
      case n.LIST:
        a = this.readListBegin();
        for(b = 0;b < a.size;++b) {
          this.skip(a.etype)
        }
        this.readListEnd();
        break;
      default:
        throw Error("Invalid type: " + a);
    }
  };
  var $ = new r(0), y = d.TTransport = function(a, b) {
    this.buf = a || $;
    this.onFlush = b;
    this.reset()
  };
  y.receiver = function(a) {
    return function(b) {
      a(new y(b))
    }
  };
  y.prototype = {commitPosition:function() {
  }, rollbackPosition:function() {
  }, reset:function() {
    this.pos = 0
  }, isOpen:function() {
    return!0
  }, open:function() {
  }, close:function() {
  }, read:function(a) {
    var b = this.pos + a;
    if(this.buf.length < b) {
      throw Error("read(" + a + ") failed - not enough data");
    }
    a = this.buf.slice(this.pos, b);
    this.pos = b;
    return a
  }, readByte:function() {
    return this.buf.getInt8(this.pos++)
  }, readI16:function() {
    var a = this.buf.getInt16(this.pos);
    this.pos += 2;
    return a
  }, readI32:function() {
    var a = this.buf.getInt32(this.pos);
    this.pos += 4;
    return a
  }, readDouble:function() {
    var a = this.buf.getFloat64(this.pos);
    this.pos += 8;
    return a
  }, readString:function(a) {
    var b = this.buf.getUtf8String(this.pos, a);
    this.pos += a;
    return b
  }, readAll:function() {
    return this.buf
  }, writeByte:function(a) {
    this.buf.setInt8(this.pos++, a)
  }, writeI16:function(a) {
    this.buf.setInt16(this.pos, a);
    this.pos += 2
  }, writeI32:function(a) {
    this.buf.setInt32(this.pos, a);
    this.pos += 4
  }, writeI64:function(a) {
    this.buf.setInt64(this.pos, a);
    this.pos += 8
  }, writeDouble:function(a) {
    this.buf.setFloat64(this.pos, a);
    this.pos += 8
  }, write:function(a) {
    typeof a === "string" ? this.pos += this.setUtf8String(this.pos, a) : (this.setBuffer(this.pos, a), this.pos += a.length)
  }, writeWithLength:function(a) {
    typeof a === "string" ? a = this.buf.setUtf8String(this.pos + 4, a) : (this.setBuffer(this.pos + 4, a), a = a.length);
    this.buf.setInt32(this.pos, a);
    this.pos += a + 4
  }, flush:function(a) {
    if(a = a || this.onFlush) {
      var b = this.buf.slice(0, this.pos);
      a(b)
    }
  }};
  var T = d.TFramedTransport = function(a, b) {
    y.call(this, a, b)
  };
  T.receiver = function(a) {
    var b = 0, c = 0, g = null, e = null;
    return function(f) {
      if(e) {
        var i = new r(f.length + e.length);
        e.copy(i, 0, 0);
        f.copy(i, e.length, 0);
        e = null
      }
      for(;f.length;) {
        if(b === 0) {
          if(f.length < 4) {
            console.log("Expecting > 4 bytes, found only " + f.length);
            e = f;
            break
          }
          b = binary.readI32(f, 0);
          g = new r(b);
          c = 0;
          f = f.slice(4, f.length)
        }
        f.length >= b ? (f.copy(g, c, 0, b), f = f.slice(b, f.length), b = 0, a(new T(g))) : f.length && (f.copy(g, c, 0, f.length), b -= f.length, c += f.length, f = f.slice(f.length, f.length))
      }
    }
  };
  A(T, y, {flush:function() {
    var a = this;
    y.prototype.flush.call(this, function(b) {
      if(a.onFlush) {
        var c = new r(b.length + 4);
        binary.writeI32(c, b.length);
        b.copy(c, 4, 0, b.length);
        a.onFlush(c)
      }
    })
  }});
  var z, B, E, G;
  TAction = {HEARTBEAT:0, CONNECT:1, CONNECTED:2, ERROR:3, ATTACH:4, ATTACHED:5, DETACH:6, DETACHED:7, SUBSCRIBE:8, SUBSCRIBED:9, UNSUBSCRIBE:10, UNSUBSCRIBED:11, PRESENCE:12, EVENT:13};
  TType = {NONE:0, TRUE:1, FALSE:2, INT32:3, INT64:4, DOUBLE:5, STRING:6, BUFFER:7, LIST:8, MAP:9};
  TPresenceState = {ENTER:0, LEAVE:1};
  z = function(a) {
    this.mapData = this.listData = this.binaryData = this.stringData = this.doubleData = this.i64Data = this.i32Data = this.type = null;
    if(a) {
      if(a.type !== void 0) {
        this.type = a.type
      }
      if(a.i32Data !== void 0) {
        this.i32Data = a.i32Data
      }
      if(a.i64Data !== void 0) {
        this.i64Data = a.i64Data
      }
      if(a.doubleData !== void 0) {
        this.doubleData = a.doubleData
      }
      if(a.stringData !== void 0) {
        this.stringData = a.stringData
      }
      if(a.binaryData !== void 0) {
        this.binaryData = a.binaryData
      }
      if(a.listData !== void 0) {
        this.listData = a.listData
      }
      if(a.mapData !== void 0) {
        this.mapData = a.mapData
      }
    }
  };
  z.prototype = {};
  z.prototype.read = function(a) {
    for(a.readStructBegin();;) {
      var b = a.readFieldBegin(), c = b.ftype;
      if(c == d.Type.STOP) {
        break
      }
      switch(b.fid) {
        case 1:
          c == d.Type.I32 ? this.type = a.readI32() : a.skip(c);
          break;
        case 2:
          c == d.Type.I32 ? this.i32Data = a.readI32() : a.skip(c);
          break;
        case 3:
          c == d.Type.I64 ? this.i64Data = a.readI64() : a.skip(c);
          break;
        case 4:
          c == d.Type.DOUBLE ? this.doubleData = a.readDouble() : a.skip(c);
          break;
        case 5:
          c == d.Type.STRING ? this.stringData = a.readString() : a.skip(c);
          break;
        case 6:
          c == d.Type.STRING ? this.binaryData = a.readBinary() : a.skip(c);
          break;
        case 7:
          if(c == d.Type.LIST) {
            b = 0;
            this.listData = [];
            b = a.readListBegin().size;
            for(c = 0;c < b;++c) {
              var g = null, g = a.readString();
              this.listData.push(g)
            }
            a.readListEnd()
          }else {
            a.skip(c)
          }
          break;
        case 8:
          if(c == d.Type.MAP) {
            b = 0;
            this.mapData = {};
            b = a.readMapBegin().size;
            for(c = 0;c < b;++c) {
              c > 0 && a.rstack.length > a.rpos[a.rpos.length - 1] + 1 && a.rstack.pop();
              var e = g = null, g = a.readString(), e = a.readString();
              this.mapData[g] = e
            }
            a.readMapEnd()
          }else {
            a.skip(c)
          }
          break;
        default:
          a.skip(c)
      }
      a.readFieldEnd()
    }
    a.readStructEnd()
  };
  z.prototype.write = function(a) {
    a.writeStructBegin("TData");
    this.type !== null && (a.writeFieldBegin("type", d.Type.I32, 1), a.writeI32(this.type), a.writeFieldEnd());
    this.i32Data !== null && (a.writeFieldBegin("i32Data", d.Type.I32, 2), a.writeI32(this.i32Data), a.writeFieldEnd());
    this.i64Data !== null && (a.writeFieldBegin("i64Data", d.Type.I64, 3), a.writeI64(this.i64Data), a.writeFieldEnd());
    this.doubleData !== null && (a.writeFieldBegin("doubleData", d.Type.DOUBLE, 4), a.writeDouble(this.doubleData), a.writeFieldEnd());
    this.stringData !== null && (a.writeFieldBegin("stringData", d.Type.STRING, 5), a.writeString(this.stringData), a.writeFieldEnd());
    this.binaryData !== null && (a.writeFieldBegin("binaryData", d.Type.STRING, 6), a.writeString(this.binaryData), a.writeFieldEnd());
    if(this.listData !== null) {
      a.writeFieldBegin("listData", d.Type.LIST, 7);
      a.writeListBegin(d.Type.STRING, this.listData.length);
      for(var b in this.listData) {
        this.listData.hasOwnProperty(b) && (b = this.listData[b], a.writeString(b))
      }
      a.writeListEnd();
      a.writeFieldEnd()
    }
    if(this.mapData !== null) {
      a.writeFieldBegin("mapData", d.Type.MAP, 8);
      a.writeMapBegin(d.Type.STRING, d.Type.STRING, d.objectLength(this.mapData));
      for(var c in this.mapData) {
        this.mapData.hasOwnProperty(c) && (b = this.mapData[c], a.writeString(c), a.writeString(b))
      }
      a.writeMapEnd();
      a.writeFieldEnd()
    }
    a.writeFieldStop();
    a.writeStructEnd()
  };
  B = function(a) {
    this.clientData = this.clientId = this.state = null;
    if(a) {
      if(a.state !== void 0) {
        this.state = a.state
      }
      if(a.clientId !== void 0) {
        this.clientId = a.clientId
      }
      if(a.clientData !== void 0) {
        this.clientData = a.clientData
      }
    }
  };
  B.prototype = {};
  B.prototype.read = function(a) {
    for(a.readStructBegin();;) {
      var b = a.readFieldBegin(), c = b.ftype;
      if(c == d.Type.STOP) {
        break
      }
      switch(b.fid) {
        case 1:
          c == d.Type.I32 ? this.state = a.readI32() : a.skip(c);
          break;
        case 2:
          c == d.Type.STRING ? this.clientId = a.readString() : a.skip(c);
          break;
        case 3:
          c == d.Type.STRUCT ? (this.clientData = new z, this.clientData.read(a)) : a.skip(c);
          break;
        default:
          a.skip(c)
      }
      a.readFieldEnd()
    }
    a.readStructEnd()
  };
  B.prototype.write = function(a) {
    a.writeStructBegin("TPresence");
    this.state !== null && (a.writeFieldBegin("state", d.Type.I32, 1), a.writeI32(this.state), a.writeFieldEnd());
    this.clientId !== null && (a.writeFieldBegin("clientId", d.Type.STRING, 2), a.writeString(this.clientId), a.writeFieldEnd());
    this.clientData !== null && (a.writeFieldBegin("clientData", d.Type.STRUCT, 3), this.clientData.write(a), a.writeFieldEnd());
    a.writeFieldStop();
    a.writeStructEnd()
  };
  E = function(a) {
    this.tags = this.payload = this.timestamp = this.clientId = this.name = null;
    if(a) {
      if(a.name !== void 0) {
        this.name = a.name
      }
      if(a.clientId !== void 0) {
        this.clientId = a.clientId
      }
      if(a.timestamp !== void 0) {
        this.timestamp = a.timestamp
      }
      if(a.payload !== void 0) {
        this.payload = a.payload
      }
      if(a.tags !== void 0) {
        this.tags = a.tags
      }
    }
  };
  E.prototype = {};
  E.prototype.read = function(a) {
    for(a.readStructBegin();;) {
      var b = a.readFieldBegin(), c = b.ftype;
      if(c == d.Type.STOP) {
        break
      }
      switch(b.fid) {
        case 1:
          c == d.Type.STRING ? this.name = a.readString() : a.skip(c);
          break;
        case 2:
          c == d.Type.STRING ? this.clientId = a.readString() : a.skip(c);
          break;
        case 4:
          c == d.Type.I64 ? this.timestamp = a.readI64() : a.skip(c);
          break;
        case 5:
          c == d.Type.STRUCT ? (this.payload = new z, this.payload.read(a)) : a.skip(c);
          break;
        case 6:
          if(c == d.Type.LIST) {
            b = 0;
            this.tags = [];
            b = a.readListBegin().size;
            for(c = 0;c < b;++c) {
              var g = null, g = a.readString();
              this.tags.push(g)
            }
            a.readListEnd()
          }else {
            a.skip(c)
          }
          break;
        default:
          a.skip(c)
      }
      a.readFieldEnd()
    }
    a.readStructEnd()
  };
  E.prototype.write = function(a) {
    a.writeStructBegin("TMessage");
    this.name !== null && (a.writeFieldBegin("name", d.Type.STRING, 1), a.writeString(this.name), a.writeFieldEnd());
    this.clientId !== null && (a.writeFieldBegin("clientId", d.Type.STRING, 2), a.writeString(this.clientId), a.writeFieldEnd());
    this.timestamp !== null && (a.writeFieldBegin("timestamp", d.Type.I64, 4), a.writeI64(this.timestamp), a.writeFieldEnd());
    this.payload !== null && (a.writeFieldBegin("payload", d.Type.STRUCT, 5), this.payload.write(a), a.writeFieldEnd());
    if(this.tags !== null) {
      a.writeFieldBegin("tags", d.Type.LIST, 6);
      a.writeListBegin(d.Type.STRING, this.tags.length);
      for(var b in this.tags) {
        this.tags.hasOwnProperty(b) && (b = this.tags[b], a.writeString(b))
      }
      a.writeListEnd();
      a.writeFieldEnd()
    }
    a.writeFieldStop();
    a.writeStructEnd()
  };
  G = function(a) {
    this.presence = this.messages = this.size = this.timestamp = this.name = this.channelSerial = this.channel = this.connectionSerial = this.connectionId = this.clientId = this.applicationId = this.reason = this.statusCode = this.action = null;
    if(a) {
      if(a.action !== void 0) {
        this.action = a.action
      }
      if(a.statusCode !== void 0) {
        this.statusCode = a.statusCode
      }
      if(a.reason !== void 0) {
        this.reason = a.reason
      }
      if(a.applicationId !== void 0) {
        this.applicationId = a.applicationId
      }
      if(a.clientId !== void 0) {
        this.clientId = a.clientId
      }
      if(a.connectionId !== void 0) {
        this.connectionId = a.connectionId
      }
      if(a.connectionSerial !== void 0) {
        this.connectionSerial = a.connectionSerial
      }
      if(a.channel !== void 0) {
        this.channel = a.channel
      }
      if(a.channelSerial !== void 0) {
        this.channelSerial = a.channelSerial
      }
      if(a.name !== void 0) {
        this.name = a.name
      }
      if(a.timestamp !== void 0) {
        this.timestamp = a.timestamp
      }
      if(a.size !== void 0) {
        this.size = a.size
      }
      if(a.messages !== void 0) {
        this.messages = a.messages
      }
      if(a.presence !== void 0) {
        this.presence = a.presence
      }
    }
  };
  G.prototype = {};
  G.prototype.read = function(a) {
    for(a.readStructBegin();;) {
      var b = a.readFieldBegin(), c = b.ftype;
      if(c == d.Type.STOP) {
        break
      }
      switch(b.fid) {
        case 1:
          c == d.Type.I32 ? this.action = a.readI32() : a.skip(c);
          break;
        case 2:
          c == d.Type.I16 ? this.statusCode = a.readI16() : a.skip(c);
          break;
        case 3:
          c == d.Type.STRING ? this.reason = a.readString() : a.skip(c);
          break;
        case 4:
          c == d.Type.STRING ? this.applicationId = a.readString() : a.skip(c);
          break;
        case 5:
          c == d.Type.STRING ? this.clientId = a.readString() : a.skip(c);
          break;
        case 6:
          c == d.Type.STRING ? this.connectionId = a.readString() : a.skip(c);
          break;
        case 7:
          c == d.Type.I32 ? this.connectionSerial = a.readI32() : a.skip(c);
          break;
        case 8:
          c == d.Type.STRING ? this.channel = a.readString() : a.skip(c);
          break;
        case 9:
          c == d.Type.STRING ? this.channelSerial = a.readString() : a.skip(c);
          break;
        case 10:
          c == d.Type.STRING ? this.name = a.readString() : a.skip(c);
          break;
        case 11:
          c == d.Type.I64 ? this.timestamp = a.readI64() : a.skip(c);
          break;
        case 12:
          c == d.Type.I32 ? this.size = a.readI32() : a.skip(c);
          break;
        case 13:
          if(c == d.Type.LIST) {
            b = 0;
            this.messages = [];
            b = a.readListBegin().size;
            for(c = 0;c < b;++c) {
              var g = null, g = new E;
              g.read(a);
              this.messages.push(g)
            }
            a.readListEnd()
          }else {
            a.skip(c)
          }
          break;
        case 14:
          if(c == d.Type.SET) {
            b = 0;
            this.presence = [];
            b = a.readSetBegin().size;
            for(c = 0;c < b;++c) {
              g = null, g = new B, g.read(a), this.presence.push(g)
            }
            a.readSetEnd()
          }else {
            a.skip(c)
          }
          break;
        default:
          a.skip(c)
      }
      a.readFieldEnd()
    }
    a.readStructEnd()
  };
  G.prototype.write = function(a) {
    a.writeStructBegin("TChannelMessage");
    this.action !== null && (a.writeFieldBegin("action", d.Type.I32, 1), a.writeI32(this.action), a.writeFieldEnd());
    this.statusCode !== null && (a.writeFieldBegin("statusCode", d.Type.I16, 2), a.writeI16(this.statusCode), a.writeFieldEnd());
    this.reason !== null && (a.writeFieldBegin("reason", d.Type.STRING, 3), a.writeString(this.reason), a.writeFieldEnd());
    this.applicationId !== null && (a.writeFieldBegin("applicationId", d.Type.STRING, 4), a.writeString(this.applicationId), a.writeFieldEnd());
    this.clientId !== null && (a.writeFieldBegin("clientId", d.Type.STRING, 5), a.writeString(this.clientId), a.writeFieldEnd());
    this.connectionId !== null && (a.writeFieldBegin("connectionId", d.Type.STRING, 6), a.writeString(this.connectionId), a.writeFieldEnd());
    this.connectionSerial !== null && (a.writeFieldBegin("connectionSerial", d.Type.I32, 7), a.writeI32(this.connectionSerial), a.writeFieldEnd());
    this.channel !== null && (a.writeFieldBegin("channel", d.Type.STRING, 8), a.writeString(this.channel), a.writeFieldEnd());
    this.channelSerial !== null && (a.writeFieldBegin("channelSerial", d.Type.STRING, 9), a.writeString(this.channelSerial), a.writeFieldEnd());
    this.name !== null && (a.writeFieldBegin("name", d.Type.STRING, 10), a.writeString(this.name), a.writeFieldEnd());
    this.timestamp !== null && (a.writeFieldBegin("timestamp", d.Type.I64, 11), a.writeI64(this.timestamp), a.writeFieldEnd());
    this.size !== null && (a.writeFieldBegin("size", d.Type.I32, 12), a.writeI32(this.size), a.writeFieldEnd());
    if(this.messages !== null) {
      a.writeFieldBegin("messages", d.Type.LIST, 13);
      a.writeListBegin(d.Type.STRUCT, this.messages.length);
      for(var b in this.messages) {
        this.messages.hasOwnProperty(b) && (b = this.messages[b], b.write(a))
      }
      a.writeListEnd();
      a.writeFieldEnd()
    }
    if(this.presence !== null) {
      a.writeFieldBegin("presence", d.Type.SET, 14);
      a.writeSetBegin(d.Type.STRUCT, this.presence.length);
      for(var c in this.presence) {
        this.presence.hasOwnProperty(c) && (c = this.presence[c], c.write(a))
      }
      a.writeSetEnd();
      a.writeFieldEnd()
    }
    a.writeFieldStop();
    a.writeStructEnd()
  };
  A = function(a) {
    this.items = null;
    if(a && a.items !== void 0) {
      this.items = a.items
    }
  };
  A.prototype = {};
  A.prototype.read = function(a) {
    for(a.readStructBegin();;) {
      var b = a.readFieldBegin(), c = b.ftype;
      if(c == d.Type.STOP) {
        break
      }
      switch(b.fid) {
        case 1:
          if(c == d.Type.LIST) {
            b = 0;
            this.items = [];
            b = a.readListBegin().size;
            for(c = 0;c < b;++c) {
              var g = null, g = new G;
              g.read(a);
              this.items.push(g)
            }
            a.readListEnd()
          }else {
            a.skip(c)
          }
          break;
        case 0:
          a.skip(c);
          break;
        default:
          a.skip(c)
      }
      a.readFieldEnd()
    }
    a.readStructEnd()
  };
  A.prototype.write = function(a) {
    a.writeStructBegin("TMessageSet");
    if(this.items !== null) {
      a.writeFieldBegin("items", d.Type.LIST, 1);
      a.writeListBegin(d.Type.STRUCT, this.items.length);
      for(var b in this.items) {
        this.items.hasOwnProperty(b) && (b = this.items[b], b.write(a))
      }
      a.writeListEnd();
      a.writeFieldEnd()
    }
    a.writeFieldStop();
    a.writeStructEnd()
  };
  var s = {TAction:TAction, TType:TType, TData:z, TPresence:B, TMessage:E, TChannelMessage:G, TMessageSet:A}, K = function() {
    function a() {
      if(!J) {
        try {
          var a = m.getElementsByTagName("body")[0].appendChild(m.createElement("span"));
          a.parentNode.removeChild(a)
        }catch(c) {
          return
        }
        J = !0;
        for(var a = x.length, b = 0;b < a;b++) {
          x[b]()
        }
      }
    }
    function b(a) {
      J ? a() : x[x.length] = a
    }
    function c(a) {
      if(typeof C.addEventListener != q) {
        C.addEventListener("load", a, !1)
      }else {
        if(typeof m.addEventListener != q) {
          m.addEventListener("load", a, !1)
        }else {
          if(typeof C.attachEvent != q) {
            o(C, "onload", a)
          }else {
            if(typeof C.onload == "function") {
              var c = C.onload;
              C.onload = function() {
                c();
                a()
              }
            }else {
              C.onload = a
            }
          }
        }
      }
    }
    function g() {
      var a = m.getElementsByTagName("body")[0], c = m.createElement(r);
      c.setAttribute("type", u);
      var b = a.appendChild(c);
      if(b) {
        var g = 0;
        (function() {
          if(typeof b.GetVariable != q) {
            var f = b.GetVariable("$version");
            if(f) {
              f = f.split(" ")[1].split(","), k.pv = [parseInt(f[0], 10), parseInt(f[1], 10), parseInt(f[2], 10)]
            }
          }else {
            if(g < 10) {
              g++;
              setTimeout(arguments.callee, 10);
              return
            }
          }
          a.removeChild(c);
          b = null;
          e()
        })()
      }else {
        e()
      }
    }
    function e() {
      var a = I.length;
      if(a > 0) {
        for(var c = 0;c < a;c++) {
          var b = I[c].id, e = I[c].callbackFn, g = {success:!1, id:b};
          if(k.pv[0] > 0) {
            var p = l(b);
            if(p) {
              if(O(I[c].swfVersion) && !(k.wk && k.wk < 312)) {
                if(n(b, !0), e) {
                  g.success = !0, g.ref = f(b), e(g)
                }
              }else {
                if(I[c].expressInstall && i()) {
                  g = {};
                  g.data = I[c].expressInstall;
                  g.width = p.getAttribute("width") || "0";
                  g.height = p.getAttribute("height") || "0";
                  if(p.getAttribute("class")) {
                    g.styleclass = p.getAttribute("class")
                  }
                  if(p.getAttribute("align")) {
                    g.align = p.getAttribute("align")
                  }
                  for(var j = {}, p = p.getElementsByTagName("param"), N = p.length, m = 0;m < N;m++) {
                    p[m].getAttribute("name").toLowerCase() != "movie" && (j[p[m].getAttribute("name")] = p[m].getAttribute("value"))
                  }
                  d(g, j, b, e)
                }else {
                  h(p), e && e(g)
                }
              }
            }
          }else {
            if(n(b, !0), e) {
              if((b = f(b)) && typeof b.SetVariable != q) {
                g.success = !0, g.ref = b
              }
              e(g)
            }
          }
        }
      }
    }
    function f(a) {
      var c = null;
      if((a = l(a)) && a.nodeName == "OBJECT") {
        typeof a.SetVariable != q ? c = a : (a = a.getElementsByTagName(r)[0]) && (c = a)
      }
      return c
    }
    function i() {
      return!D && O("6.0.65") && (k.win || k.mac) && !(k.wk && k.wk < 312)
    }
    function d(a, c, b, e) {
      D = !0;
      E = e || null;
      G = {success:!1, id:b};
      var g = l(b);
      if(g) {
        g.nodeName == "OBJECT" ? (y = p(g), B = null) : (y = g, B = b);
        a.id = v;
        if(typeof a.width == q || !/%$/.test(a.width) && parseInt(a.width, 10) < 310) {
          a.width = "310"
        }
        if(typeof a.height == q || !/%$/.test(a.height) && parseInt(a.height, 10) < 137) {
          a.height = "137"
        }
        m.title = m.title.slice(0, 47) + " - Flash Player Installation";
        e = k.ie && k.win ? "ActiveX" : "PlugIn";
        e = "MMredirectURL=" + C.location.toString().replace(/&/g, "%26") + "&MMplayerType=" + e + "&MMdoctitle=" + m.title;
        typeof c.flashvars != q ? c.flashvars += "&" + e : c.flashvars = e;
        if(k.ie && k.win && g.readyState != 4) {
          e = m.createElement("div"), b += "SWFObjectNew", e.setAttribute("id", b), g.parentNode.insertBefore(e, g), g.style.display = "none", function() {
            g.readyState == 4 ? g.parentNode.removeChild(g) : setTimeout(arguments.callee, 10)
          }()
        }
        N(a, c, b)
      }
    }
    function h(a) {
      if(k.ie && k.win && a.readyState != 4) {
        var c = m.createElement("div");
        a.parentNode.insertBefore(c, a);
        c.parentNode.replaceChild(p(a), c);
        a.style.display = "none";
        (function() {
          a.readyState == 4 ? a.parentNode.removeChild(a) : setTimeout(arguments.callee, 10)
        })()
      }else {
        a.parentNode.replaceChild(p(a), a)
      }
    }
    function p(a) {
      var c = m.createElement("div");
      if(k.win && k.ie) {
        c.innerHTML = a.innerHTML
      }else {
        if(a = a.getElementsByTagName(r)[0]) {
          if(a = a.childNodes) {
            for(var b = a.length, e = 0;e < b;e++) {
              !(a[e].nodeType == 1 && a[e].nodeName == "PARAM") && a[e].nodeType != 8 && c.appendChild(a[e].cloneNode(!0))
            }
          }
        }
      }
      return c
    }
    function N(a, c, b) {
      var e, g = l(b);
      if(k.wk && k.wk < 312) {
        return e
      }
      if(g) {
        if(typeof a.id == q) {
          a.id = b
        }
        if(k.ie && k.win) {
          var f = "", i;
          for(i in a) {
            if(a[i] != Object.prototype[i]) {
              i.toLowerCase() == "data" ? c.movie = a[i] : i.toLowerCase() == "styleclass" ? f += ' class="' + a[i] + '"' : i.toLowerCase() != "classid" && (f += " " + i + '="' + a[i] + '"')
            }
          }
          i = "";
          for(var d in c) {
            c[d] != Object.prototype[d] && (i += '<param name="' + d + '" value="' + c[d] + '" />')
          }
          g.outerHTML = '<object classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"' + f + ">" + i + "</object>";
          z[z.length] = a.id;
          e = l(a.id)
        }else {
          d = m.createElement(r);
          d.setAttribute("type", u);
          for(var h in a) {
            a[h] != Object.prototype[h] && (h.toLowerCase() == "styleclass" ? d.setAttribute("class", a[h]) : h.toLowerCase() != "classid" && d.setAttribute(h, a[h]))
          }
          for(f in c) {
            c[f] != Object.prototype[f] && f.toLowerCase() != "movie" && (a = d, i = f, h = c[f], b = m.createElement("param"), b.setAttribute("name", i), b.setAttribute("value", h), a.appendChild(b))
          }
          g.parentNode.replaceChild(d, g);
          e = d
        }
      }
      return e
    }
    function j(a) {
      var c = l(a);
      if(c && c.nodeName == "OBJECT") {
        k.ie && k.win ? (c.style.display = "none", function() {
          if(c.readyState == 4) {
            var b = l(a);
            if(b) {
              for(var e in b) {
                typeof b[e] == "function" && (b[e] = null)
              }
              b.parentNode.removeChild(b)
            }
          }else {
            setTimeout(arguments.callee, 10)
          }
        }()) : c.parentNode.removeChild(c)
      }
    }
    function l(a) {
      var c = null;
      try {
        c = m.getElementById(a)
      }catch(b) {
      }
      return c
    }
    function o(a, c, b) {
      a.attachEvent(c, b);
      w[w.length] = [a, c, b]
    }
    function O(a) {
      var c = k.pv, a = a.split(".");
      a[0] = parseInt(a[0], 10);
      a[1] = parseInt(a[1], 10) || 0;
      a[2] = parseInt(a[2], 10) || 0;
      return c[0] > a[0] || c[0] == a[0] && c[1] > a[1] || c[0] == a[0] && c[1] == a[1] && c[2] >= a[2] ? !0 : !1
    }
    function X(a, c, b, e) {
      if(!k.ie || !k.mac) {
        var g = m.getElementsByTagName("head")[0];
        if(g) {
          b = b && typeof b == "string" ? b : "screen";
          e && (F = H = null);
          if(!H || F != b) {
            e = m.createElement("style"), e.setAttribute("type", "text/css"), e.setAttribute("media", b), H = g.appendChild(e), k.ie && k.win && typeof m.styleSheets != q && m.styleSheets.length > 0 && (H = m.styleSheets[m.styleSheets.length - 1]), F = b
          }
          k.ie && k.win ? H && typeof H.addRule == r && H.addRule(a, c) : H && typeof m.createTextNode != q && H.appendChild(m.createTextNode(a + " {" + c + "}"))
        }
      }
    }
    function n(a, c) {
      if(L) {
        var b = c ? "visible" : "hidden";
        J && l(a) ? l(a).style.visibility = b : X("#" + a, "visibility:" + b)
      }
    }
    function t(a) {
      return/[\\\"<>\.;]/.exec(a) != null && typeof encodeURIComponent != q ? encodeURIComponent(a) : a
    }
    var q = "undefined", r = "object", u = "application/x-shockwave-flash", v = "SWFObjectExprInst", C = window, m = document, s = navigator, A = !1, x = [function() {
      A ? g() : e()
    }], I = [], z = [], w = [], y, B, E, G, J = !1, D = !1, H, F, L = !0, k = function() {
      var a = typeof m.getElementById != q && typeof m.getElementsByTagName != q && typeof m.createElement != q, c = s.userAgent.toLowerCase(), b = s.platform.toLowerCase(), e = b ? /win/.test(b) : /win/.test(c), b = b ? /mac/.test(b) : /mac/.test(c), c = /webkit/.test(c) ? parseFloat(c.replace(/^.*webkit\/(\d+(\.\d+)?).*$/, "$1")) : !1, g = !+"\u000b1", f = [0, 0, 0], i = null;
      if(typeof s.plugins != q && typeof s.plugins["Shockwave Flash"] == r) {
        if((i = s.plugins["Shockwave Flash"].description) && !(typeof s.mimeTypes != q && s.mimeTypes[u] && !s.mimeTypes[u].enabledPlugin)) {
          A = !0, g = !1, i = i.replace(/^.*\s+(\S+\s+\S+$)/, "$1"), f[0] = parseInt(i.replace(/^(.*)\..*$/, "$1"), 10), f[1] = parseInt(i.replace(/^.*\.(.*)\s.*$/, "$1"), 10), f[2] = /[a-zA-Z]/.test(i) ? parseInt(i.replace(/^.*[a-zA-Z]+(.*)$/, "$1"), 10) : 0
        }
      }else {
        if(typeof C.ActiveXObject != q) {
          try {
            var d = new ActiveXObject("ShockwaveFlash.ShockwaveFlash");
            if(d && (i = d.GetVariable("$version"))) {
              g = !0, i = i.split(" ")[1].split(","), f = [parseInt(i[0], 10), parseInt(i[1], 10), parseInt(i[2], 10)]
            }
          }catch(h) {
          }
        }
      }
      return{w3:a, pv:f, wk:c, ie:g, win:e, mac:b}
    }();
    (function() {
      k.w3 && ((typeof m.readyState != q && m.readyState == "complete" || typeof m.readyState == q && (m.getElementsByTagName("body")[0] || m.body)) && a(), J || (typeof m.addEventListener != q && m.addEventListener("DOMContentLoaded", a, !1), k.ie && k.win && (m.attachEvent("onreadystatechange", function() {
        m.readyState == "complete" && (m.detachEvent("onreadystatechange", arguments.callee), a())
      }), C == top && function() {
        if(!J) {
          try {
            m.documentElement.doScroll("left")
          }catch(c) {
            setTimeout(arguments.callee, 0);
            return
          }
          a()
        }
      }()), k.wk && function() {
        J || (/loaded|complete/.test(m.readyState) ? a() : setTimeout(arguments.callee, 0))
      }(), c(a)))
    })();
    (function() {
      k.ie && k.win && window.attachEvent("onunload", function() {
        for(var a = w.length, c = 0;c < a;c++) {
          w[c][0].detachEvent(w[c][1], w[c][2])
        }
        a = z.length;
        for(c = 0;c < a;c++) {
          j(z[c])
        }
        for(var b in k) {
          k[b] = null
        }
        k = null;
        for(var e in K) {
          K[e] = null
        }
        K = null
      })
    })();
    return{registerObject:function(a, c, b, e) {
      if(k.w3 && a && c) {
        var g = {};
        g.id = a;
        g.swfVersion = c;
        g.expressInstall = b;
        g.callbackFn = e;
        I[I.length] = g;
        n(a, !1)
      }else {
        e && e({success:!1, id:a})
      }
    }, getObjectById:function(a) {
      if(k.w3) {
        return f(a)
      }
    }, embedSWF:function(a, c, e, g, f, h, M, p, j, m) {
      var l = {success:!1, id:c};
      k.w3 && !(k.wk && k.wk < 312) && a && c && e && g && f ? (n(c, !1), b(function() {
        e += "";
        g += "";
        var b = {};
        if(j && typeof j === r) {
          for(var k in j) {
            b[k] = j[k]
          }
        }
        b.data = a;
        b.width = e;
        b.height = g;
        k = {};
        if(p && typeof p === r) {
          for(var P in p) {
            k[P] = p[P]
          }
        }
        if(M && typeof M === r) {
          for(var o in M) {
            typeof k.flashvars != q ? k.flashvars += "&" + o + "=" + M[o] : k.flashvars = o + "=" + M[o]
          }
        }
        if(O(f)) {
          P = N(b, k, c), b.id == c && n(c, !0), l.success = !0, l.ref = P
        }else {
          if(h && i()) {
            b.data = h;
            d(b, k, c, m);
            return
          }else {
            n(c, !0)
          }
        }
        m && m(l)
      })) : m && m(l)
    }, switchOffAutoHideShow:function() {
      L = !1
    }, ua:k, getFlashPlayerVersion:function() {
      return{major:k.pv[0], minor:k.pv[1], release:k.pv[2]}
    }, hasFlashPlayerVersion:O, createSWF:function(a, c, b) {
      if(k.w3) {
        return N(a, c, b)
      }
    }, showExpressInstall:function(a, c, b, e) {
      k.w3 && i() && d(a, c, b, e)
    }, removeSWF:function(a) {
      k.w3 && j(a)
    }, createCSS:function(a, c, b, e) {
      k.w3 && X(a, c, b, e)
    }, addDomLoadEvent:b, addLoadEvent:c, getQueryParamValue:function(a) {
      var c = m.location.search || m.location.hash;
      if(c) {
        /\?/.test(c) && (c = c.split("?")[1]);
        if(a == null) {
          return t(c)
        }
        for(var c = c.split("&"), b = 0;b < c.length;b++) {
          if(c[b].substring(0, c[b].indexOf("=")) == a) {
            return t(c[b].substring(c[b].indexOf("=") + 1))
          }
        }
      }
      return""
    }, expressInstallCallback:function() {
      if(D) {
        var a = l(v);
        if(a && y) {
          a.parentNode.replaceChild(y, a);
          if(B && (n(B, !0), k.ie && k.win)) {
            y.style.display = "block"
          }
          E && E(G)
        }
        D = !1
      }
    }}
  }(), Y = function() {
    var a = window.location.protocol, b = a + "//" + o.HOST_CDN + ":" + (a == "https:" ? o.HTTPS_PORT : o.HTTP_PORT) + o.STATIC_PATH + "WebSocketMainInsecure.swf";
    console.log("swf at: " + b);
    logger = window.console && window.console.log && window.console.error ? window.console : {log:function() {
    }, error:function() {
    }};
    var c = function(a, b, f, i, d) {
      var h = this;
      h.__id = c.__nextId++;
      c.__instances[h.__id] = h;
      h.readyState = c.CONNECTING;
      h.bufferedAmount = 0;
      h.__events = {};
      b ? typeof b == "string" && (b = [b]) : b = [];
      h.__createTask = setTimeout(function() {
        c.__addTask(function() {
          h.__createTask = null;
          c.__flash.create(h.__id, a, b, f || null, i || 0, d || null)
        })
      }, 0)
    };
    c.prototype.send = function(a) {
      if(this.readyState == c.CONNECTING) {
        throw"INVALID_STATE_ERR: Web Socket connection has not been established";
      }
      a = c.__flash.send(this.__id, encodeURIComponent(a));
      return a < 0 ? !0 : (this.bufferedAmount += a, !1)
    };
    c.prototype.close = function() {
      if(this.__createTask) {
        clearTimeout(this.__createTask), this.__createTask = null, this.readyState = c.CLOSED
      }else {
        if(!(this.readyState == c.CLOSED || this.readyState == c.CLOSING)) {
          this.readyState = c.CLOSING, c.__flash.close(this.__id)
        }
      }
    };
    c.prototype.addEventListener = function(a, c) {
      a in this.__events || (this.__events[a] = []);
      this.__events[a].push(c)
    };
    c.prototype.removeEventListener = function(a, c) {
      if(a in this.__events) {
        for(var b = this.__events[a], i = b.length - 1;i >= 0;--i) {
          if(b[i] === c) {
            b.splice(i, 1);
            break
          }
        }
      }
    };
    c.prototype.dispatchEvent = function(a) {
      for(var c = this.__events[a.type] || [], b = 0;b < c.length;++b) {
        c[b](a)
      }
      (c = this["on" + a.type]) && c.apply(this, [a])
    };
    c.prototype.__handleEvent = function(a) {
      if("readyState" in a) {
        this.readyState = a.readyState
      }
      if("protocol" in a) {
        this.protocol = a.protocol
      }
      var c;
      if(a.type == "open" || a.type == "error") {
        c = this.__createSimpleEvent(a.type)
      }else {
        if(a.type == "close") {
          c = this.__createSimpleEvent("close"), c.wasClean = a.wasClean ? !0 : !1, c.code = a.code, c.reason = a.reason
        }else {
          if(a.type == "message") {
            c = this.__createMessageEvent("message", decodeURIComponent(a.message))
          }else {
            throw"unknown event type: " + a.type;
          }
        }
      }
      this.dispatchEvent(c)
    };
    c.prototype.__createSimpleEvent = function(a) {
      if(document.createEvent && window.Event) {
        var c = document.createEvent("Event");
        c.initEvent(a, !1, !1);
        return c
      }else {
        return{type:a, bubbles:!1, cancelable:!1}
      }
    };
    c.prototype.__createMessageEvent = function(a, c) {
      if(document.createEvent && window.MessageEvent && !window.opera) {
        var b = document.createEvent("MessageEvent");
        b.initMessageEvent("message", !1, !1, c, null, null, window, null);
        return b
      }else {
        return{type:a, data:c, bubbles:!1, cancelable:!1}
      }
    };
    c.CONNECTING = 0;
    c.OPEN = 1;
    c.CLOSING = 2;
    c.CLOSED = 3;
    c.__initialized = !1;
    c.__flash = null;
    c.__instances = {};
    c.__tasks = [];
    c.__nextId = 0;
    c.loadFlashPolicyFile = function(a) {
      c.__addTask(function() {
        c.__flash.loadManualPolicyFile(a)
      })
    };
    c.__initialize = function() {
      if(!c.__initialized) {
        c.__initialized = !0;
        var a = document.createElement("div");
        a.id = "webSocketContainer";
        a.style.position = "absolute";
        c.__isFlashLite() ? (a.style.left = "0px", a.style.top = "0px") : (a.style.left = "-100px", a.style.top = "-100px");
        var e = document.createElement("div");
        e.id = "webSocketFlash";
        a.appendChild(e);
        document.body.appendChild(a);
        K.embedSWF(b, "webSocketFlash", "1", "1", "10.0.0", null, null, {hasPriority:!0, swliveconnect:!0, allowScriptAccess:"always"}, null, function(a) {
          a.success || logger.error("[WebSocket] swfobject.embedSWF failed")
        })
      }
    };
    c.__onFlashInitialized = function() {
      setTimeout(function() {
        c.__flash = document.getElementById("webSocketFlash");
        c.__flash.setCallerUrl(location.href);
        c.__flash.setDebug(!!window.WEB_SOCKET_DEBUG);
        for(var a = 0;a < c.__tasks.length;++a) {
          c.__tasks[a]()
        }
        c.__tasks = []
      }, 0)
    };
    c.__onFlashEvent = function() {
      setTimeout(function() {
        try {
          for(var a = c.__flash.receiveEvents(), b = 0;b < a.length;++b) {
            c.__instances[a[b].webSocketId].__handleEvent(a[b])
          }
        }catch(f) {
          logger.error(f)
        }
      }, 0);
      return!0
    };
    c.__log = function(a) {
      logger.log(decodeURIComponent(a))
    };
    c.__error = function(a) {
      logger.error(decodeURIComponent(a))
    };
    c.__addTask = function(a) {
      c.__flash ? a() : c.__tasks.push(a)
    };
    c.__isFlashLite = function() {
      if(!window.navigator || !window.navigator.mimeTypes) {
        return!1
      }
      var a = window.navigator.mimeTypes["application/x-shockwave-flash"];
      if(!a || !a.enabledPlugin || !a.enabledPlugin.filename) {
        return!1
      }
      return a.enabledPlugin.filename.match(/flashlite/i) ? !0 : !1
    };
    K.addDomLoadEvent(function() {
      c.__initialize()
    });
    return c
  }(), u = function() {
    function a() {
      this.any = [];
      this.events = {};
      this.anyOnce = [];
      this.eventsOnce = {}
    }
    a.prototype.on = function(a, c) {
      arguments.length == 2 ? (this.events[a] = this.events[a] || []).push(c) : typeof a == "function" && this.any.push(a)
    };
    a.prototype.off = function(a, c) {
      if(arguments.length == 2) {
        if(c) {
          var g, e = -1;
          if(!(g = this.events[a]) || (e = g.indexOf(c)) == -1) {
            if(g = this.eventsOnce[a]) {
              e = g.indexOf(c)
            }
          }
          e > -1 && g.splice(e, 1)
        }else {
          delete this.events[a], delete this.eventsOnce[a]
        }
      }else {
        if(typeof a == "function") {
          g = this.any;
          e = g.indexOf(a);
          if(e == -1) {
            g = this.anyOnce, e = g.indexOf(a)
          }
          e > -1 && g.splice(e, 1)
        }else {
          this.any = [], this.events = {}, this.anyOnce = [], this.eventsOnce = {}
        }
      }
    };
    a.prototype.listeners = function(a) {
      if(a) {
        return this.events[a]
      }
      return this.any.length ? this.any : null
    };
    a.prototype.emit = function(a) {
      var c = Array.prototype.slice.call(arguments, 1), g = {event:a};
      if(this.anyOnce.length) {
        var e = this.anyOnce;
        this.anyOnce = [];
        for(var f = 0;f < e.length;f++) {
          e[f].apply(g, c)
        }
      }
      for(f = 0;f < this.any.length;f++) {
        this.any[f].apply(g, c)
      }
      if(e = this.eventsOnce[a]) {
        delete this.eventsOnce[a];
        for(f = 0;f < e.length;f++) {
          e[f].apply(g, c)
        }
      }
      if(e = this.events[a]) {
        for(f = 0;f < e.length;f++) {
          e[f].apply(g, c)
        }
      }
    };
    a.prototype.once = function(a, c) {
      arguments.length == 2 ? (this.eventsOnce[a] = this.eventsOnce[a] || []).push(c) : typeof a == "function" && this.anyOnce.push(a)
    };
    return a
  }(), h = function() {
    function a() {
    }
    var b = 4, c = function() {
    };
    a.LOG_NONE = 0;
    a.LOG_ERROR = 1;
    a.LOG_MAJOR = 2;
    a.LOG_MINOR = 3;
    a.LOG_MICRO = 4;
    a.LOG_DEFAULT = 3;
    a.LOG_DEBUG = 4;
    a.logAction = function(a, e, f) {
      a <= b && c("Ably: " + e + ": " + f)
    };
    a.setLog = function(a, e) {
      b = a || 3;
      c = e || console.log.bind(console)
    };
    return a
  }(), l = function() {
    function a() {
    }
    var b;
    a.addProperties = a.mixin = function(a, c) {
      for(var b in c) {
        a[b] = c[b]
      }
      return a
    };
    a.copy = function(c) {
      return a.mixin({}, c)
    };
    a.mkdirs = function(a) {
      for(var c = a.split("/"), a = a[0] == "/" ? "/" : "";c.length;) {
        var b = c.shift();
        if(b != "") {
          a = path.resolve(a, b);
          if(path.existsSync(a)) {
            b = fs.statSync(a);
            if(b.isFile()) {
              throw Error("Utils.mkdirs: specified path is a file");
            }
            if(b.isDirectory()) {
              continue
            }
          }
          fs.mkdirSync(a)
        }
      }
      return a
    };
    a.deleteDir = function(c) {
      if(path.existsSync(c)) {
        var b = fs.statSync(c);
        if(!b.isDirectory()) {
          throw Error("Utils.deleteDir: specified path is not a directory");
        }
        var f = fs.readdirSync(c), i;
        for(i in f) {
          var d = path.resolve(c, f[i]), b = fs.statSync(d);
          b.isFile() ? fs.unlinkSync(d) : a.deleteDir(d)
        }
        fs.rmdirSync(c)
      }
    };
    a.copyFile = function(c, b, f) {
      if(!path.existsSync(c)) {
        throw Error("Utils.copyFile: specified source file does not exist");
      }
      if(path.existsSync(b)) {
        if(!f) {
          throw Error("Utils.copyFile: specified dest file aleady exists");
        }
        fs.unlink(b)
      }
      f = path.dirname(b);
      a.mkdirs(f);
      for(var f = new r(1024), c = fs.openSync(c, "r"), b = fs.openSync(b, "w"), i;(i = fs.readSync(c, f, 0, 1024)) > 0;) {
        fs.writeSync(b, f, 0, i)
      }
      fs.closeSync(c);
      fs.fsyncSync(b);
      fs.closeSync(b)
    };
    a.copyDir = function(c, b, f) {
      if(!path.existsSync(c)) {
        throw Error("Utils.copyDir: specified source dir does not exist");
      }
      if(path.existsSync(b)) {
        if(!f) {
          throw Error("Utils.copyDir: specified dest dir aleady exists");
        }
        a.deleteDir(b)
      }
      a.mkdirs(b);
      var f = fs.readdirSync(c), i;
      for(i in f) {
        var d = path.resolve(c, f[i]);
        stat = fs.statSync(d);
        stat.isFile() ? a.copyFile(d, path.resolve(b, f[i]), !1) : a.copyDir(d, path.resolve(b, f[i]), !1)
      }
    };
    a.isEmpty = function(a) {
      for(var c in a) {
        return!1
      }
      return!0
    };
    a.shallowClone = function(a) {
      var c = {}, b;
      for(b in a) {
        c[b] = a[b]
      }
      return c
    };
    a.prototypicalClone = function(c, b) {
      function f() {
      }
      f.prototype = c;
      var i = new f;
      b && a.mixin(i, b);
      return i
    };
    a.inherits = function(a, c) {
      a.super_ = c;
      a.prototype = Object.create(c.prototype, {constructor:{value:a, enumerable:!1, writable:!0, configurable:!0}})
    };
    a.containsValue = function(a, c) {
      for(var b in a) {
        if(a[b] == c) {
          return!0
        }
      }
      return!1
    };
    a.valuesArray = function(a, c) {
      var b = [], i;
      for(i in a) {
        (!c || a.hasOwnProperty(i)) && b.push(a[i])
      }
      return b.length ? b : void 0
    };
    a.nextTick = typeof window == "object" ? function(a) {
      setTimeout(a, 0)
    } : process.nextTick;
    var c = {json:"application/json", jsonp:"application/javascript", xml:"application/xml", html:"text/html"};
    a.defaultHeaders = function(a) {
      a = c[a];
      return{accept:a, "content-type":a}
    };
    return a
  }(), U = function() {
    function a(a) {
      var a = a || [], c = function(c, e) {
        for(var f in a) {
          try {
            a[f](c, e)
          }catch(i) {
          }
        }
      };
      c.__proto__ = this.__proto__;
      c.members = a;
      return c
    }
    l.inherits(a, Function);
    a.prototype.push = function() {
      Array.prototype.push.apply(this.members, arguments)
    };
    return a
  }(), x = function() {
    function a(b, e) {
      u.call(this);
      this.ably = b;
      this.options = e;
      this.pendingMessages = [];
      this.state = c.initialized;
      e.transports = e.transports || o.transports;
      var f = this.transports = [], i;
      for(i in e.transports) {
        e.transports[i] in a.availableTransports && f.push(e.transports[i])
      }
      h.logAction(h.LOG_MINOR, "Ably.ConnectionManager()", "started");
      h.logAction(h.LOG_MICRO, "Ably.ConnectionManager()", "requested transports = [" + e.transports + "]");
      h.logAction(h.LOG_MICRO, "Ably.ConnectionManager()", "available transports = [" + f + "]");
      if(!f.length) {
        throw h.logAction(h.LOG_ERROR, "Ably.ConnectionManager()", "no requested transports available"), Error("no requested transports available");
      }
    }
    var b = function() {
    }, c = {initialized:{state:"initialized", terminal:!1, queueEvents:!0, sendEvents:!1}, connecting:{state:"connecting", terminal:!1, queueEvents:!0, sendEvents:!1, retryDelay:o.connectTimeout, failState:"disconnected"}, connected:{state:"connected", terminal:!1, queueEvents:!1, sendEvents:!0, failState:"disconnected"}, disconnected:{state:"disconnected", terminal:!1, queueEvents:!0, sendEvents:!1, retryDelay:o.disconnectTimeout, defaultMessage:t.FAIL_REASON_DISCONNECTED}, suspended:{state:"suspended", 
    terminal:!1, queueEvents:!1, sendEvents:!1, retryDelay:o.suspendedTimeout, defaultMessage:t.FAIL_REASON_SUSPENDED}, closed:{state:"closed", terminal:!1, queueEvents:!1, sendEvents:!1, defaultMessage:t.FAIL_REASON_CLOSED}, failed:{state:"failed", terminal:!0, queueEvents:!1, sendEvents:!1, defaultMessage:t.FAIL_REASON_FAILED}};
    l.inherits(a, u);
    a.availableTransports = {};
    a.prototype.chooseTransport = function(c) {
      if(this.transport) {
        c(this.transport)
      }else {
        var b = this, f = this.transports.slice(), i = function(c) {
          var g = f.shift();
          g ? (h.logAction(h.LOG_MICRO, "ConnectionManager.chooseTransport()", "trying " + g), a.availableTransports[g].tryConnect(b, b.ably.auth, b.options, function(a, f) {
            a ? i(c) : (h.logAction(h.LOG_MICRO, "ConnectionManager.chooseTransport()", "transport " + g + " connecting"), b.setupTransport(f), c(f))
          })) : c(null)
        };
        i(c)
      }
    };
    a.prototype.setupTransport = function(a) {
      var c = this;
      this.transport = a;
      ["connected", "closed", "failed"].forEach(function(b) {
        a.on(b, function(a, g) {
          h.logAction(h.LOG_MICRO, "ConnectionManager.setupTransport; on state = " + b, "reason =  " + a + "; connectionId = " + g);
          c.ably.connection.id = g;
          c.notifyState({state:b, reason:a})
        })
      })
    };
    a.activeState = function(a) {
      return a.queueEvents || a.sendEvents
    };
    a.prototype.enactStateChange = function(a) {
      h.logAction(h.LOG_MINOR, "ConnectionManager.enactStateChange", "setting new state: " + a.current);
      this.state = c[a.current];
      this.emit(a.current, a, this.transport)
    };
    a.prototype.startConnectTimer = function() {
      var a = this;
      this.connectTimer = setTimeout(function() {
        a.connectTimer && (h.logAction(h.LOG_MINOR, "ConnectionManager connect timer expired", "requesting new state: " + c.connecting.failState), a.notifyState({state:c.connecting.failState}))
      }, o.connectTimeout)
    };
    a.prototype.cancelConnectTimer = function() {
      if(this.connectTimer) {
        clearTimeout(this.connectTimer), this.connectTimer = void 0
      }
    };
    a.prototype.startSuspendTimer = function() {
      var a = this;
      if(!this.suspendTimer) {
        this.suspendTimer = setTimeout(function() {
          if(a.suspendTimer) {
            h.logAction(h.LOG_MINOR, "ConnectionManager suspend timer expired", "requesting new state: suspended"), c.connecting.failState = "suspended", c.connecting.queueEvents = !1, a.notifyState({state:"suspended"})
          }
        }, o.suspendedTimeout)
      }
    };
    a.prototype.cancelSuspendTimer = function() {
      c.connecting.failState = "disconnected";
      c.connecting.queueEvents = !0;
      this.suspendTimer && (clearTimeout(this.suspendTimer), delete this.suspendTimer)
    };
    a.prototype.startRetryTimer = function(a) {
      var c = this;
      this.retryTimer = setTimeout(function() {
        h.logAction(h.LOG_MINOR, "ConnectionManager retry timer expired", "retrying");
        c.requestState({state:"connecting"})
      }, a)
    };
    a.prototype.cancelRetryTimer = function() {
      this.retryTimer && (clearTimeout(this.retryTimer), delete this.retryTimer)
    };
    a.prototype.start = function() {
      this.requestState({state:"connecting"})
    };
    a.prototype.notifyState = function(b) {
      if(!(this.state.terminal || b.state == this.state.state)) {
        h.logAction(h.LOG_MINOR, "ConnectionManager.notifyState()", "new state: " + b.state);
        var e = c[b.state];
        !a.activeState(e) && this.transport && (h.logAction(h.LOG_MINOR, "ConnectionManager.notifyState()", "deleting transport " + this.transport), this.transport.dispose(), delete this.transport);
        this.cancelConnectTimer();
        this.cancelRetryTimer();
        b.state == "connected" && this.cancelSuspendTimer();
        b = new V(this.state.state, e.state, e.retryDelay, b.reason || e.defaultMessage);
        e.retryDelay && this.startRetryTimer(e.retryDelay);
        this.enactStateChange(b);
        this.state.sendEvents && this.sendPendingMessages()
      }
    };
    a.prototype.requestState = function(a) {
      this.cancelConnectTimer();
      this.cancelRetryTimer();
      if(a.state != this.state.state) {
        if(this.state.terminal) {
          throw Error(this.state.defaultMessage);
        }
        if(a.state == "connecting") {
          if(this.state.state == "connected") {
            return
          }
          this.connectImpl()
        }else {
          if(a.state == "failed") {
            this.transport && (this.transport.abort(a.reason), delete this.transport)
          }else {
            if((a.state = "closed") && this.transport) {
              this.transport.close(), delete this.transport, this.cancelConnectTimer(), this.cancelRetryTimer(), this.cancelSuspendTimer()
            }
          }
        }
        var b = c[a.state];
        this.enactStateChange(new V(this.state.state, b.state, b.retryIn, a.reason || b.defaultMessage))
      }
    };
    a.prototype.connectImpl = function() {
      h.logAction(h.LOG_MINOR, "ConnectionManager.connectImpl()", "starting connection");
      this.startSuspendTimer();
      this.startConnectTimer();
      var a = this, b = this.ably.auth, f = function(i) {
        h.logAction(h.LOG_ERROR, "ConnectionManager.connectImpl()", i);
        i.statusCode == 401 && i.message.indexOf("expire") != -1 && b.method == "token" && b.getToken(!0, function(c) {
          c ? f(c) : a.connectImpl()
        });
        a.notifyState({state:c.connecting.failState, reason:t.FAIL_REASON_SUSPENDED + "(" + i + ")"})
      }, i = function() {
        a.chooseTransport(function(a) {
          a || f(Error("Unable to connect using any available transport"))
        })
      };
      b.method == "basic" ? i() : b.getToken(!1, function(a) {
        a ? f(a) : i()
      })
    };
    a.prototype.send = function(a, c, f) {
      f = f || b;
      if(this.state.queueEvents) {
        if(c) {
          if(h.logAction(h.LOG_MICRO, "ConnectionManager.send()", "queueing event"), (c = this.pendingMessages[this.pendingMessages.length - 1]) && L.mergeTo(c.msg, a)) {
            if(!c.isMerged) {
              c.callback = new U([c.callback]), c.isMerged = !0
            }
            c.listener.push(f)
          }else {
            this.pendingMessages.push({msg:a, callback:f})
          }
        }else {
          h.logAction(h.LOG_MICRO, "ConnectionManager.send()", "rejecting event"), f(this.state.defaultMessage)
        }
      }
      this.state.sendEvents && (h.logAction(h.LOG_MICRO, "ConnectionManager.send()", "sending event"), this.transport.send(a, f))
    };
    a.prototype.sendPendingMessages = function() {
      h.logAction(h.LOG_MICRO, "ConnectionManager.sendPendingMessages()", "sending " + this.pendingMessages.length + " queued messages");
      var a = this.pendingMessages.shift();
      if(a) {
        try {
          this.transport.send(a.msg, a.callback)
        }catch(c) {
          h.logAction(h.LOG_ERROR, "ConnectionManager.sendPendingMessages()", "Unexpected exception in transport.send(): " + c)
        }
      }
    };
    return a
  }(), v = function() {
    function a(a, e, f) {
      u.call(this);
      this.connectionManager = a;
      this.auth = e;
      this.options = f;
      f.useTextProtocol ? (this.thriftTransport = b.TStringTransport, this.thriftProtocol = b.TJSONProtocol) : (this.thriftTransport = b.TTransport, this.thriftProtocol = b.TBinaryProtocol, this.protocolBuffer = new b.CheckedBuffer(c));
      this.isConnected = !1
    }
    var b = typeof window == "object" ? d : require("thrift"), c = 1024;
    l.inherits(a, u);
    a.prototype.connect = function() {
    };
    a.prototype.close = function() {
      this.isConnected = !1;
      this.emit("closed", t.FAIL_REASON_CLOSED)
    };
    a.prototype.abort = function(a) {
      this.isConnected = !1;
      this.emit("failed", a)
    };
    a.prototype.onChannelMessage = function(a) {
      switch(a.action) {
        case 0:
          this.emit("heartbeat");
          break;
        case 2:
          this.connectionId = a.connectionId;
          this.isConnected = !0;
          this.onConnect();
          this.emit("connected", "", this.connectionId);
          break;
        default:
          this.emit("channelmessage", a)
      }
    };
    a.prototype.sendMessage = function(a, c) {
      h.logAction(h.LOG_MICRO, "Transport.sendMessage()", "");
      var b = this;
      try {
        var i = new this.thriftProtocol(new this.thriftTransport(void 0, function(a) {
          b.sendData(a, c)
        }));
        a.write(i);
        i.flush()
      }catch(d) {
        i = "Unexpected send exception: " + d, h.logAction(h.LOG_ERROR, "Transport.sendMessage()", i), c(Error(i))
      }
    };
    a.prototype.onConnect = function() {
    };
    a.prototype.onClose = function(a, c) {
      if(this.connectionManager.state.state != "closed") {
        var b;
        a ? (b = "closed", c = t.FAIL_REASON_CLOSED) : (b = "disconnected", c = t.FAIL_REASON_DISCONNECTED);
        this.isConnected = !1;
        this.connectionManager.notifyState({state:b, reason:c})
      }
    };
    a.prototype.dispose = function() {
      this.off()
    };
    return a
  }(), Z = function() {
    function a(a, c, b) {
      var e = !(b.useTextProtocol |= !g);
      if(!g) {
        b.useTextProtocol = !0
      }
      this.sendOptions = {binary:e};
      v.call(this, a, c, b)
    }
    var b = typeof window == "object", c = b ? window.WebSocket || window.MozWebSocket : require("ws"), g = b ? window.ArrayBuffer : r, e = typeof s == "object" ? s : require("../nodejs/lib/protocol/clientmessage_types"), f = b ? d : require("thrift");
    l.inherits(a, v);
    a.isAvailable = function() {
      return!!c
    };
    if(a.isAvailable()) {
      x.availableTransports.web_socket = a
    }
    a.tryConnect = function(c, b, e, f) {
      var g = new a(c, b, e), d = function(a) {
        f(a)
      };
      g.on("wserror", d);
      g.on("wsopen", function() {
        h.logAction(h.LOG_MINOR, "WebSocketTransport.tryConnect()", "viable transport " + g);
        g.off("wserror", d);
        f(null, g)
      });
      g.connect()
    };
    a.prototype.createWebSocket = function(a, b) {
      var e = 0;
      if(b) {
        for(var f in b) {
          a += (e++ ? "&" : "?") + f + "=" + b[f]
        }
      }
      this.uri = a;
      return new c(a)
    };
    a.prototype.toString = function() {
      return"WebSocketTransport; uri=" + this.uri
    };
    a.prototype.connect = function() {
      h.logAction(h.LOG_MINOR, "WebSocketTransport.connect()", "starting");
      v.prototype.connect.call(this);
      var a = this, c = (this.options.encrypted ? "wss://" : "ws://") + this.options.host + ":" + this.options.wsPort + "/applications/" + this.options.appId;
      h.logAction(h.LOG_MINOR, "WebSocketTransport.connect()", "uri: " + c);
      this.auth.getAuthParams(function(b, e) {
        var f = "", g;
        for(g in e) {
          f += " " + g + ": " + e[g] + ";"
        }
        h.logAction(h.LOG_MINOR, "WebSocketTransport.connect()", "authParams:" + f);
        if(b) {
          a.abort(t.FAIL_REASON_REFUSED)
        }else {
          try {
            var d = a.wsConnection = a.createWebSocket(c, e);
            d.binaryType = "arraybuffer";
            d.onopen = function() {
              a.onWsOpen()
            };
            d.onclose = function(c, b) {
              a.onWsClose(c, b)
            };
            d.onmessage = function(c) {
              a.onWsData(c.data, typeof c.data != "string")
            };
            d.onerror = function(c) {
              a.onWsError(c)
            }
          }catch(j) {
            a.onWsError(j)
          }
        }
      })
    };
    a.prototype.close = function() {
      this.dispose();
      v.prototype.close.call(this)
    };
    a.prototype.abort = function() {
      this.dispose();
      v.prototype.abort.call(this)
    };
    a.prototype.send = function(a, c) {
      var b = this;
      try {
        var e = new this.thriftProtocol(new this.thriftTransport(this.protocolBuffer, function(a) {
          b.wsConnection.send(a, b.sendOptions);
          c(null)
        }));
        a.write(e);
        e.flush()
      }catch(f) {
        a = "Unexpected send exception: " + f, h.logAction(h.LOG_ERROR, "WebSocketTransport.send()", a), c(Error(a))
      }
    };
    a.prototype.onWsData = function(a, c) {
      var b = c ? new f.TBinaryProtocol(new f.TTransport(a)) : new f.TJSONProtocol(new f.TStringTransport(a)), g = new e.TChannelMessage;
      try {
        g.read(b), this.onChannelMessage(g)
      }catch(d) {
        h.logAction(h.LOG_ERROR, "Transport.onChannelEvent()", "Unexpected exception handing channel event: " + d.stack)
      }
    };
    a.prototype.onWsOpen = function() {
      h.logAction(h.LOG_MINOR, "WebSocketTransport.onWsOpen()", "opened WebSocket");
      this.emit("wsopen")
    };
    a.prototype.onWsClose = function(a, c) {
      var b, e, f;
      typeof a == "object" ? (b = a.wasClean, e = a.code, f = a.reason) : (e = a, f = c || "", b = e == 1E3);
      h.logAction(h.LOG_MINOR, "WebSocketTransport.onWsClose()", "closed WebSocket; wasClean = " + b + "; code = " + e);
      delete this.wsConnection;
      v.prototype.onClose.call(this, b, f)
    };
    a.prototype.onWsError = function(a) {
      h.logAction(h.LOG_ERROR, "WebSocketTransport.onError()", "Unexpected error from WebSocket: " + a);
      this.emit("wserror", a);
      this.abort()
    };
    a.prototype.dispose = function() {
      this.wsConnection && (this.wsConnection.close(), delete this.wsConnection)
    };
    return a
  }(), D = function() {
    function a(a, b, e) {
      v.call(this, a, b, e);
      this.binary = !e.useTextProtocol
    }
    var b = typeof s == "object" ? s : require("../nodejs/lib/protocol/clientmessage_types");
    (l || require("util")).inherits(a, v);
    a.paramStr = function(a, b) {
      var e = 0, f = b || "";
      if(a) {
        for(var i in a) {
          f += (e++ ? "&" : "?") + i + "=" + a[i]
        }
      }
      return f
    };
    a.prototype.connect = function() {
      h.logAction(h.LOG_MINOR, "CometTransport.connect()", "starting");
      v.prototype.connect.call(this);
      var c = this;
      this.baseUri = (this.options.encrypted ? "https://" : "http://") + this.options.host + ":" + this.options.wsPort + "/comet/" + this.options.appId;
      var b = this.baseUri + "/recv";
      h.logAction(h.LOG_MINOR, "CometTransport.connect()", "uri: " + b);
      this.auth.getAuthParams(function(e, f) {
        c.params = f;
        h.logAction(h.LOG_MINOR, "CometTransport.connect()", "authParams:" + a.paramStr(f));
        if(e) {
          c.abort(t.FAIL_REASON_REFUSED)
        }else {
          try {
            c.request(b, c.params, null, !1, function(a, b) {
              a ? c.emit("error", a) : (c.emit("preconnect"), c.onRecvResponse(b))
            })
          }catch(i) {
            c.emit("error", i)
          }
        }
      })
    };
    a.prototype.close = function() {
      v.prototype.close.call(this);
      this.isConnected = !1;
      this.recvRequest && (this.recvRequest.abort(), delete this.recvRequest);
      var a = this;
      this.recvRequest = this.request(this.closeUri, this.params, null, !1, function(b) {
        delete a.recvRequest;
        b && a.emit("error", b)
      })
    };
    a.prototype.abort = function(a) {
      v.prototype.abort.call(this, a)
    };
    a.prototype.onConnect = function() {
      this.sendUri = this.baseUri + "/send/" + this.connectionId;
      this.recvUri = this.baseUri + "/recv/" + this.connectionId;
      this.closeUri = this.baseUri + "/close/" + this.connectionId;
      this.recv()
    };
    a.prototype.send = function(a, g) {
      if(this.sendRequest) {
        this.pendingMessage = this.pendingMessage || new b.TMessageSet({items:[]}), this.pendingMessage.push(a), this.pendingCallback = this.pendingCallback || new U, this.pendingCallback.push(g)
      }else {
        var e = this.pendingMessage || new b.TMessageSet({items:[]});
        e.items.push(a);
        delete this.pendingMessage;
        var f = this.pendingCallback;
        f && (f.push(g), g = f, delete this.pendingCallback);
        this.sendMessage(e, g)
      }
    };
    a.prototype.sendMessage = function(a, b) {
      var e = this;
      try {
        var f = new this.thriftProtocol(new this.thriftTransport(this.protocolBuffer, function(a) {
          e.sendRequest = e.request(e.sendUri, e.params, a, !1, function(a, c) {
            delete e.sendRequest;
            e.pendingMessage && (e.sendMessage(e.pendingMessage, e.pendingCallback), delete e.pendingMessage, delete e.pendingCallback);
            a ? b(a) : (e.onResponseData(c), b(null))
          })
        }));
        a.write(f);
        f.flush()
      }catch(i) {
        f = "Unexpected send exception: " + i, h.logAction(h.LOG_ERROR, "CometTransport.sendMessage()", f), b(Error(f))
      }
    };
    a.prototype.recv = function() {
      this.recvRequest && (this.recvRequest.abort(), delete this.recvRequest);
      if(this.isConnected) {
        var a = this;
        this.recvRequest = this.request(this.recvUri, this.params, null, !0, function(b, e) {
          b ? a.emit("error", b) : (a.onRecvResponse(e), delete a.recvRequest, a.recv())
        })
      }
    };
    a.prototype.onResponseData = function(a) {
      var a = new this.thriftProtocol(new this.thriftTransport(a)), g = new b.TMessageSet;
      try {
        g.read(a);
        var e = g.items;
        if(e && e.length) {
          for(var f in e) {
            this.onChannelMessage(e[f])
          }
        }
      }catch(i) {
        h.logAction(h.LOG_ERROR, "CometTransport.onSendResponse()", "Unexpected exception handing channel event: " + i.stack)
      }
    };
    a.prototype.onRecvResponse = function(a) {
      this.onResponseData(a)
    };
    return a
  }();
  (function() {
    function a(a, b, e) {
      D.call(this, a, b, e)
    }
    var b = function() {
      var a = new XMLHttpRequest;
      if("withCredentials" in a) {
        return a
      }
      if(typeof XDomainRequest !== "undefined") {
        return new XDomainRequest
      }
      return null
    };
    l.inherits(a, D);
    a.isAvailable = function() {
      var c = b();
      if(!c) {
        return!1
      }
      a.binary = window.ArrayBuffer && c.responseType;
      return!0
    };
    if(a.isAvailable()) {
      x.availableTransports.xhr = a
    }
    a.tryConnect = function(c, b, e, f) {
      var i = new a(c, b, e), d = function(a) {
        f(a)
      };
      i.on("error", d);
      i.on("preconnect", function() {
        h.logAction(h.LOG_MINOR, "XHRTransport.tryConnect()", "viable transport " + i);
        i.off("error", d);
        f(null, i)
      });
      i.connect()
    };
    a.prototype.request = function(c, b, e, f, i) {
      return new a.Request(c, b, e, f, this.binary, i)
    };
    a.prototype.toString = function() {
      return"XHRTransport; uri=" + this.baseUri + "; isConnected=" + this.isConnected
    };
    a.Request = function(a, g, e, f, i, d) {
      var a = D.paramStr(g, a), h;
      e ? (g = "POST", h = 201) : (g = "GET", h = 200);
      var j = this.xhr = b();
      if(i) {
        j.responseType = "arraybuffer"
      }
      var l = setTimeout(f ? o.cometRecvTimeout : o.cometSendTimeout, function() {
        j.abort()
      });
      j.open(g, a, !0);
      j.setRequestHeader("Accept", i ? "application/x-thrift" : "application/json");
      j.onreadystatechange = function() {
        if(j.readyState == 4) {
          clearTimeout(l);
          var a = null;
          if(j.status != h) {
            a = Error("Unexpected response: statusCode = " + j.status), a.statusCode = j.status, a.statusText = j.statusText, d(a)
          }else {
            a = null;
            if(i) {
              if(j.response) {
                a = new r, a.buf = j.response, a.view = new DataView(a.buf)
              }
            }else {
              a = j.responseText
            }
            d(null, a)
          }
        }
      };
      j.send(e)
    };
    a.Request.prototype.abort = function() {
      this.xhr && this.xhr.abort()
    };
    return a
  })();
  (function() {
    function a(a, b, e) {
      e.useTextProtocol = !0;
      D.call(this, a, b, e);
      Ably._ = {}
    }
    l.inherits(a, D);
    a.isAvailable = function() {
      return!0
    };
    x.availableTransports.jsonp = a;
    a.tryConnect = function(c, b, e, f) {
      var i = new a(c, b, e), d = function(a) {
        f(a)
      };
      i.on("error", d);
      i.on("preconnect", function() {
        h.logAction(h.LOG_MINOR, "JSONPTransport.tryConnect()", "viable transport " + i);
        i.off("error", d);
        f(null, i)
      });
      i.connect()
    };
    a.prototype.toString = function() {
      return"JSONPTransport; uri=" + uri + "; state=" + this.state
    };
    a.prototype.toString = function() {
      return"JSONPTransport; uri=" + this.baseUri + "; isConnected=" + this.isConnected
    };
    a.prototype.request = function(c, b, e, f, i) {
      return new a.Request(c, b, e, f, i)
    };
    var b = 0;
    a.Request = function(a, d, e, f, i) {
      var h = Ably._;
      this.callback = i;
      var j = this.requestId = b++, p = this.timer = setTimeout(f ? o.cometRecvTimeout : o.cometSendTimeout, function() {
        n.abort()
      });
      d.callback = "Ably._._" + j;
      e ? d.body = encodeUriComponent(e) : delete d.body;
      var l = document.createElement("script");
      l.async = !0;
      l.onerror = function() {
        n.abort()
      };
      l.src = D.paramStr(d, a);
      var n = this;
      Ably._["_" + j] = function(a) {
        clearTimeout(p);
        delete h["_" + j];
        n.aborted || (l.parentNode.removeChild(l), i(null, a))
      };
      a = document.getElementsByTagName("script")[0];
      a.parentNode.insertBefore(l, a);
      this.script = l
    };
    a.Request.prototype.abort = function() {
      clearTimeout(this.timer);
      this.aborted = !0;
      delete Ably._["_" + this.requestId];
      this.callback(Error("JSONPTransport: requestId " + this.requestId + " aborted"))
    };
    return a
  })();
  (function() {
    function a(a, b, e) {
      e.useTextProtocol = !0;
      Z.call(this, a, b, e)
    }
    var b = typeof window == "object";
    l.inherits(a, Z);
    a.isAvailable = function() {
      return b && K && K.getFlashPlayerVersion().major >= 10 && Y
    };
    if(a.isAvailable()) {
      x.availableTransports.flash_socket = a
    }
    a.tryConnect = function(c, b, e, f) {
      var d = new a(c, b, e);
      errorCb = function(a) {
        f(a)
      };
      d.on("wserror", errorCb);
      d.on("wsopen", function() {
        h.logAction(h.LOG_MINOR, "FlashTransport.tryConnect()", "viable transport " + d);
        d.off("wsopen", errorCb);
        f(null, d)
      });
      d.connect()
    };
    a.prototype.createWebSocket = function(a, b) {
      var e = 0;
      if(b) {
        for(var f in b) {
          a += (e++ ? "&" : "?") + f + "=" + b[f]
        }
      }
      this.uri = a;
      return new Y(a, [], this.options.proxyHost, this.options.proxyPort)
    };
    a.prototype.toString = function() {
      return"FlashTransport; uri=" + this.uri
    };
    return a
  })();
  var F = function() {
    function a(a, c) {
      this.rest = a;
      this.uri = a.baseUri + c
    }
    a.prototype.get = function(a, c) {
      arguments.length == 1 && typeof a == "function" && (c = a, a = null);
      var d = this.rest, e = this.uri;
      d.auth.getAuthHeaders(function(f, i) {
        f ? c(f) : Http.get(e, l.mixin(i, d.headers), a, c)
      })
    };
    a.prototype.post = function(a, c, d) {
      arguments.length == 2 && typeof c == "function" && (d = c, c = null);
      var e = this.rest, f = this.uri;
      e.auth.getAuthHeaders(function(i, h) {
        i ? d(i) : Http.post(f, l.mixin(h, e.headers), a, c, d)
      })
    };
    return a
  }(), aa = function() {
    function a() {
    }
    function b(a) {
      if(!a) {
        return""
      }
      typeof a == "string" && (a = JSON.parse(a));
      var c = {};
      Object.keys(a).sort().forEach(function(b) {
        c[b] = a[b].sort()
      });
      return JSON.stringify(c)
    }
    function c(a, c) {
      this.rest = a;
      this.tokenUri = a.baseUri + "/authorise";
      var b = this.authOptions = {};
      if(c.key) {
        var e = c.key.split(":");
        if(e.length != 2) {
          throw h.logAction(h.LOG_ERROR, "Auth()", "invalid key parameter"), Error("invalid key parameter");
        }
        this.key = c.key;
        this.keyId = e[0];
        this.keyValue = e[1];
        if(!c.clientId) {
          h.logAction(h.LOG_MINOR, "Auth()", "anonymous, using basic auth");
          this.method = "basic";
          b.key = c.key;
          b.key_id = this.keyId;
          b.key_value = this.keyValue;
          return
        }
        if(!f) {
          throw Error("Auth(): client-side token request signing not supported");
        }
      }
      this.method = "token";
      if(c.authToken) {
        this.token = {id:c.authToken}
      }
      if(c.auth_callback) {
        h.logAction(h.LOG_MINOR, "Auth()", "using token auth with authCallback"), b.auth_callback = c.authCallback
      }else {
        if(c.authURL) {
          h.logAction(h.LOG_MINOR, "Auth()", "using token auth with authURL"), b.auth_url = c.auth_url
        }else {
          if(c.key) {
            h.logAction(h.LOG_MINOR, "Auth()", "anonymous, using token auth with client-side signing"), b.key = c.key, b.key_id = this.keyId, b.key_value = this.keyValue
          }else {
            if(this.token) {
              h.logAction(h.LOG_MINOR, "Auth()", "using token auth with supplied token only")
            }else {
              throw Error("Auth(): options must include valid authentication parameters");
            }
          }
        }
      }
    }
    var d = typeof window == "object", e = d ? null : require("crypto"), f = void 0;
    d && window.CryptoJS && CryptoJS.HmacSHA256 && CryptoJS.enc.Base64 && (f = function(a, c) {
      return CryptoJS.HmacSHA256(a, c).toString(CryptoJS.enc.Base64)
    });
    d || (f = function(a, c) {
      var b = e.createHmac("SHA256", c);
      b.update(a);
      return b.digest("base64")
    });
    c.prototype.authorise = function(a, c) {
      if(this.token) {
        if(this.token.expires > Math.floor(Date.now() / 1E3)) {
          if(!a.force) {
            h.logAction(h.LOG_MINOR, "Auth.getToken()", "using cached token; expires = " + this.token.expires);
            c();
            return
          }
        }else {
          h.logAction(h.LOG_MINOR, "Auth.getToken()", "deleting expired token"), delete this.token
        }
      }
      var b = this;
      this.requestToken(a, function(a, e) {
        a ? c(a) : c(null, b.token = e)
      })
    };
    c.prototype.requestToken = function(c, e) {
      typeof c == "function" && !e && (e = c, c = {});
      var c = c || {}, e = e || a, c = l.mixin(l.copy(this.authOptions), c), f;
      if(c.auth_callback) {
        h.logAction(h.LOG_MINOR, "Auth.requestToken()", "using token auth with auth_callback"), f = c.auth_callback
      }else {
        if(c.auth_url) {
          h.logAction(h.LOG_MINOR, "Auth.requestToken()", "using token auth with auth_url"), f = function(a, b) {
            Http.get(c.auth_url, c.auth_headers || {}, l.mixin(a, c.auth_params), b)
          }
        }else {
          if(c.key) {
            f = c.key.split(":");
            c.key_id = f[0];
            c.key_value = f[1];
            var d = this;
            h.logAction(h.LOG_MINOR, "Auth.requestToken()", "using token auth with client-side signing");
            f = function(a, b) {
              d.createTokenRequest(l.mixin(l.copy(c), a), b)
            }
          }else {
            throw Error("Auth.requestToken(): options must include valid authentication parameters");
          }
        }
      }
      var g = {}, j = c.client_id || this.rest.clientId;
      if(j) {
        g.client_id = j
      }
      j = c.expires || "";
      if("expires" in c) {
        g.expires = j
      }
      if("capability" in c) {
        g.capability = b(c.capability)
      }
      var d = this, n = function(a, c) {
        Http.post ? Http.post(d.tokenUri, null, a, null, c) : Http.get(d.tokenUri, null, a, c)
      };
      f(g, function(a, c) {
        a ? (h.logAction(h.LOG_ERROR, "Auth.requestToken()", "token request signing call returned error; err = " + a), e(a)) : n(c, function(a, c) {
          a ? (h.logAction(h.LOG_ERROR, "Auth.requestToken()", "token request API call returned error; err = " + a), e(a)) : (h.logAction(h.LOG_MINOR, "Auth.getToken()", "token received"), e(null, c.access_token))
        })
      })
    };
    c.prototype.createTokenRequest = function(a, c) {
      var b = a.key_id, e = a.key_value;
      if(!b || !e) {
        c(Error("No key specified"))
      }else {
        var d = {id:b}, g = a.clientId || "";
        if(g) {
          d.client_id = a.clientId
        }
        var j = a.expires || "";
        if(j) {
          d.expires = j
        }
        var l = a.capability || "";
        if(l) {
          d.capability = l
        }
        var n = this.rest;
        (function(b) {
          a.timestamp ? b() : a.queryTime ? n.time(function(e, f) {
            e ? c(e) : (a.timestamp = Math.floor(f / 1E3), b())
          }) : (a.timestamp = Math.floor(Date.now() / 1E3), b())
        })(function() {
          var b = d.nonce = a.nonce || ("000000" + Math.floor(Math.random() * 1E16)).slice(-16), n = d.timestamp = a.timestamp, b = d.id + "\n" + j + "\n" + l + "\n" + g + "\n" + n + "\n" + b + "\n";
          d.mac = a.mac || f(b, e);
          h.logAction(h.LOG_MINOR, "Auth.getTokenRequest()", "generated signed request");
          c(null, d)
        })
      }
    };
    c.prototype.getAuthParams = function(a) {
      this.method == "basic" ? a(null, {key_id:this.keyId, key_value:this.keyValue}) : this.getToken(!1, function(c, b) {
        c ? a(c) : a(null, {access_token:b.id})
      })
    };
    c.prototype.getAuthHeaders = function(a) {
      this.method == "basic" ? a(null, {authorization:"Basic " + (new r(this.key || this.key_id + ":" + this.key_value, "ascii")).toString("base64")}) : this.authorise({}, function(c, b) {
        c ? a(c) : a(null, {authorization:"Bearer " + b.id})
      })
    };
    return c
  }();
  this.Realtime = function() {
    function a(a) {
      this.options = a = a || {};
      a.log && h.setLog(a.log.level, a.log.handler);
      h.logAction(h.LOG_MINOR, "Realtime()", "started");
      if(!a.appId) {
        throw Error("Realtime(): no appId provided");
      }
      this.clientId = a.clientId;
      var d = a.host = a.host || (a.debug ? o.HOST_DEBUG : o.HOST), e = a.restPort = a.tlsPort || a.encrypted && a.port || o.WSS_PORT;
      a.wsPort = a.encrypted ? e : a.port || o.WS_PORT;
      this.baseUri = (this.authority = "https://" + d + ":" + e) + "/apps/" + this.options.appId;
      d = l.defaultHeaders[a.format == "json"];
      a.headers && (d = l.mixin(l.copy(a.headers), this.headers));
      this.headers = d;
      this.auth = new aa(this, a);
      this.connection = new ba(this, a);
      this.channels = new b(this);
      this.events = new F(this, "/events");
      this.stats = new F(this, "/stats");
      this.connection.connectionManager.start()
    }
    function b(a) {
      this.realtime = a;
      var b = this.attached = {}, e = a.connection.connectionManager;
      e.on(function(a, c) {
        h.logAction(h.LOG_MICRO, "Channels on connection state", "newState = " + a.current);
        switch(a.current) {
          case "connected":
            h.logAction(h.LOG_MINOR, "Channels on connection state", "connected; transport = " + c);
            c.on("channelmessage", function(a) {
              var c = a.channel;
              if(c) {
                var e = b[c];
                if(e) {
                  e.onMessage(a)
                }else {
                  h.logAction(h.LOG_ERROR, "Channels", "connected: received event for non-existent channel: " + c)
                }
              }else {
                h.logAction(h.LOG_ERROR, "Channels", "connected: received event unspecified channel: " + c)
              }
            });
            break;
          case "suspended":
          ;
          case "closed":
          ;
          case "failed":
            var d = e.state, j;
            for(j in b) {
              b[j].setSuspended(d)
            }
        }
      })
    }
    a.prototype.close = function() {
      h.logAction(h.LOG_MINOR, "Realtime.close()", "");
      this.connection.connectionManager.requestState({state:"closed"})
    };
    a.prototype.time = function(a) {
      Http.get(this.authority + "/time", null, null, function(b, e) {
        if(b) {
          a(b)
        }else {
          var f = e[0];
          f ? a(null, f) : (b = Error("Internal error (unexpected result type from GET /time"), b.statusCode = 500, a(b))
        }
      })
    };
    b.prototype.get = function(a, b) {
      var e = this.attached[a];
      e || (this.attached[a] = e = new ca(this.realtime, a, b || {}));
      return e
    };
    return a
  }();
  var V = function() {
    return function(a, b, c, d) {
      this.previous = a;
      this.current = b;
      if(c) {
        this.retryIn = c
      }
      if(d) {
        this.reason = d
      }
    }
  }(), ba = function() {
    function a(a, c) {
      u.call(this);
      this.ably = a;
      this.connectionManager = new x(a, c);
      this.state = this.connectionManager.state.state;
      this.id = void 0;
      var d = this;
      this.connectionManager.on(function(a) {
        d.state = a.current;
        l.nextTick(function() {
          d.emit(d.state, a)
        })
      })
    }
    l.inherits(a, u);
    a.prototype.on = function(a, c) {
      u.prototype.on.call(this, a, c);
      if(this.state == a && c) {
        try {
          c(new V(void 0, a))
        }catch(d) {
        }
      }
    };
    a.prototype.connect = function() {
      this.connectionManager.requestState({state:"connecting"})
    };
    return a
  }(), L = function() {
    function a(a, b) {
      h.logAction(h.LOG_MINOR, "Channel()", "started; name = " + b);
      u.call(this);
      this.rest = a;
      this.name = b;
      this.presence = new F(a, "/channels/" + b + "/presence");
      this.events = new F(a, "/channels/" + b + "/events");
      this.stats = new F(a, "/channels/" + b + "/stats")
    }
    var b = function() {
    };
    l.inherits(a, u);
    a.prototype.publish = function(a, d, e) {
      h.logAction(h.LOG_MICRO, "Channel.publish()", "name = " + a);
      e = e || b;
      (this._publish = this._publish || new F(this.rest, "/channels/" + this.name + "/publish")).post({name:a, payload:d}, e)
    };
    return a
  }(), ca = function() {
    function a(a, b, c) {
      h.logAction(h.LOG_MINOR, "RealtimeChannel()", "started; name = " + b);
      L.call(this, a, b, c);
      this.presence = new da(this, c);
      this.connectionManager = a.connection.connectionManager;
      this.options = l.prototypicalClone(d, c);
      this.state = "initialized";
      this.subscriptions = new u;
      this.pendingSubscriptions = {};
      this.pendingEvents = []
    }
    var b = typeof s == "object" ? s : require("../nodejs/lib/protocol/clientmessage_types"), c = function() {
    }, d = {queueEvents:!0};
    l.inherits(a, L);
    a.prototype.publish = function(a, c, d) {
      h.logAction(h.LOG_MICRO, "RealtimeChannel.publish()", "name = " + a);
      var g = this.connectionManager.state;
      x.activeState(g) ? (g = new b.TMessage, g.name = a, g.payload = Q.createPayload(c), this.state == "attached" ? (h.logAction(h.LOG_MICRO, "RealtimeChannel.publish()", "sending message"), c = new b.TChannelMessage, c.action = b.TAction.EVENT, c.name = a, c.channel = this.name, c.messages = [g], this.sendMessage(c, d)) : (this.state != "pending" && this.attach(), h.logAction(h.LOG_MICRO, "RealtimeChannel.publish()", "queueing message"), this.pendingEvents.push({message:g, listener:d}))) : d(g.defaultMessage)
    };
    a.prototype.onEvent = function(a) {
      h.logAction(h.LOG_MICRO, "RealtimeChannel.onEvent()", "received message");
      var b = this.subscriptions, c;
      for(c in a) {
        var d = a[c];
        b.emit(d.name, d)
      }
    };
    a.prototype.attach = function(a) {
      var d = this.connectionManager, g = d.state;
      x.activeState(g) ? this.state == "attached" ? a() : this.state == "failed" ? a(g.defaultMessage) : (this.once(function(b) {
        switch(this.event) {
          case "attached":
            a();
            break;
          case "detached":
          ;
          case "failed":
            a(b || d.state.defaultMessage)
        }
      }), h.logAction(h.LOG_MICRO, "RealtimeChannel.attach()", "sending ATTACH message"), this.state = "pending", this.sendMessage(new b.TChannelMessage({action:b.TAction.ATTACH, channel:this.name}), c)) : a(g.defaultMessage)
    };
    a.prototype.detach = function(a) {
      var c = this.connectionManager, d = c.state;
      x.activeState(d) ? this.state == "detached" ? a() : (this.once(function(b) {
        switch(this.event) {
          case "detached":
            a();
            break;
          case "attached":
            a(t.FAIL_REASON_UNKNOWN);
            break;
          case "failed":
            a(b || c.state.defaultMessage)
        }
      }), h.logAction(h.LOG_MICRO, "RealtimeChannel.attach()", "sending DETACH message"), this.sendMessage(new b.TChannelMessage({action:b.TAction.DETACH, channel:this.name}))) : a(d.defaultMessage)
    };
    a.prototype.subscribe = function() {
      var a = Array.prototype.slice.call(arguments);
      typeof a[0] == "function" && a.unshift("*");
      var b = a[0], d = a[1], g = a[2] = a[2] || c;
      if(this.state == "attached") {
        this.subscribeAttached(b, d, g)
      }else {
        this.state != "pending" && this.attach();
        var h = this;
        this.once(function(a) {
          switch(this.event) {
            case "attached":
              h.subscribeAttached(b, d, g);
              break;
            case "detached":
            ;
            case "failed":
              g(a || h.connectionManager.state.defaultMessage)
          }
        })
      }
    };
    a.prototype.subscribeAttached = function(a, b, c) {
      if(a) {
        if(a.__proto__ !== Array.prototype) {
          this.subscribeForEvent(a, b, c)
        }else {
          for(var d = 0;d < a.length;d++) {
            this.subscribeForEvent(a[d], b, c)
          }
        }
      }else {
        c()
      }
    };
    a.prototype.subscribeForEvent = function(a, d, g) {
      if(this.subscriptions.listeners(a === "*" ? null : a)) {
        g()
      }else {
        h.logAction(h.LOG_MICRO, "RealtimeChannel.attach()", "sending SUBSCRIBE message");
        var j = this.pendingSubscriptions[a];
        j || (j = [], this.pendingSubscriptions[a] = j);
        j.push({listener:d, callback:g});
        this.sendMessage(new b.TChannelMessage({action:b.TAction.SUBSCRIBE, channel:this.name, name:a}), c)
      }
    };
    a.prototype.unsubscribe = function() {
      var a = Array.prototype.slice.call(arguments);
      typeof a[0] == "function" && a.unshift("*");
      var b = a[0], d = a[1], g = a[2] = a[2] || c;
      if(this.state == "attached") {
        this.unsubscribeAttached(b, d, g)
      }else {
        this.state != "pending" && this.attach();
        var h = this;
        this.once(function(a) {
          switch(this.event) {
            case "attached":
              h.unsubscribeAttached(b, d, g);
              break;
            case "detached":
            ;
            case "failed":
              g(a || h.connectionManager.state.defaultMessage)
          }
        })
      }
    };
    a.prototype.unsubscribeAttached = function(a, b, c) {
      if(a) {
        if(a.__proto__ !== Array.prototype) {
          this.unsubscribeForEvent(a, b, c)
        }else {
          for(var d = 0;d < a.length;d++) {
            this.unsubscribeForEvent(a[d], b, c)
          }
        }
      }else {
        c()
      }
    };
    a.prototype.unsubscribeForEvent = function(a, d, g) {
      var j = this.subscriptions;
      j.off(a, d);
      j.listeners(a === "*" ? null : a) ? g() : (h.logAction(h.LOG_MICRO, "RealtimeChannel.unsubscribe()", "sending UNSUBSCRIBE message"), this.sendMessage(new b.TChannelMessage({action:b.TAction.UNSUBSCRIBE, channel:this.name, name:a}), c))
    };
    a.prototype.sendMessage = function(a, b) {
      this.connectionManager.send(a, this.options.queueEvents, b)
    };
    a.prototype.sendPresence = function(a, c) {
      this.sendMessage(new b.TChannelMessage({action:b.TAction.PRESENCE, name:name}), c)
    };
    a.prototype.onMessage = function(a) {
      switch(a.action) {
        case 3:
          h.logAction(h.LOG_ERROR, "RealtimeChannel.onMessage()", "Error received: statusCode = " + a.statusCode + "; reason = " + a.reason);
          this.abort(t.FAIL_REASON_REFUSED);
          break;
        case 5:
          this.setAttached(a);
          break;
        case 7:
          this.setDetached(a);
          break;
        case 9:
          this.setSubscribed(a);
          break;
        case 11:
          this.setUnsubscribed(a);
          break;
        case 12:
          this.setPresence(a.presence);
          break;
        case 13:
          if(a = a.messages) {
            var b = Array(a.length), c;
            for(c in a) {
              var d = a[c];
              b[c] = new Q(d.channelSerial, d.timestamp, d.name, Q.getPayload(d.payload))
            }
            this.onEvent(b)
          }
          break;
        default:
          h.logAction(h.LOG_ERROR, "Transport.onChannelMessage()", "Fatal protocol error: unrecognised action (" + a.action + ")"), this.abort(t.FAIL_REASON_FAILED)
      }
    };
    a.mergeTo = function(a, b) {
      var c = !1, d;
      if(a.channel == b.channel && (d = a.action) == b.action) {
        switch(d) {
          case 10:
            for(var g in b.messages) {
              a.messages.push(b.messages[g])
            }
            c = !0;
            break;
          case 9:
            for(g in b.presence) {
              a.presence.push(b.presence[g])
            }
            c = !0
        }
      }
      return c
    };
    a.prototype.setAttached = function(a) {
      h.logAction(h.LOG_MINOR, "RealtimeChannel.setAttached", "activating channel; name = " + this.name);
      this.state = "attached";
      a.presence && this.presence.setPresence(a.presence, !1);
      this.emit("attached");
      try {
        if(this.pendingEvents.length) {
          var c = new b.TChannelMessage({action:b.TAction.EVENT, name:this.name}), d = new U;
          h.logAction(h.LOG_MICRO, "RealtimeChannel.setAttached", "sending " + this.pendingEvents.length + " queued messages");
          for(var g in this.pendingEvents) {
            var j = this.pendingEvents[g];
            c.addToEvents(j.message);
            d.push(j.callback)
          }
          this.sendMessage(c, d)
        }
        this.presence.setSubscribed()
      }catch(l) {
        h.logAction(h.LOG_ERROR, "RealtimeChannel.setSubscribed()", "Unexpected exception sending pending messages: " + l.stack)
      }
    };
    a.prototype.setSubscribed = function(a) {
      var b = a.name;
      h.logAction(h.LOG_MINOR, "RealtimeChannel.setSubscribed", "activating event; name = " + b);
      var c = this.pendingSubscriptions[b];
      if(c) {
        var d = this.subscriptions;
        l.nextTick(function() {
          for(var a in c) {
            d.on(b, c[a].listener), c[a].callback()
          }
        });
        delete this.pendingSubscriptions[a.name]
      }
    };
    a.prototype.setDetached = function(a) {
      var b = this.state;
      this.state = "detached";
      b == "pending" ? this.emit("failed", a) : this.emit("detached")
    };
    a.prototype.setUnsubscribed = function(a) {
      var b = a.name, c = this.pendingSubscriptions[b];
      c && (l.nextTick(function() {
        for(var b in c) {
          c[b].callback(a.reason || t.FAIL_REASON_REFUSED)
        }
      }), delete this.pendingSubscriptions[b]);
      this.subscriptions.off(b)
    };
    a.prototype.setSuspended = function(a) {
      h.logAction(h.LOG_MINOR, "RealtimeChannel.setSuspended", "deactivating channel; name = " + this.name);
      this.state = "detached";
      for(var b in this.pendingEvents) {
        try {
          this.pendingEvents[b].callback(a.defaultMessage)
        }catch(c) {
        }
      }
      this.pendingEvents = [];
      this.presence.setSuspended(a);
      this.emit("detached")
    };
    return a
  }(), da = function() {
    function a(a, b) {
      u.call(this);
      this.channel = a;
      this.clientId = b.clientId;
      this.clients = {}
    }
    var b = typeof s == "object" ? s : require("../nodejs/lib/protocol/clientmessage_types");
    l.inherits(a, u);
    a.prototype.enter = function(a, b) {
      if(!this.clientId) {
        throw Error("clientId must be specified to enter a presence channel");
      }
      this.enterClient(this.clientId, a, b)
    };
    a.prototype.enterClient = function(a, d, e) {
      h.logAction("Presence.enterClient()", "entering; channel = " + this.channel.name + ", client = " + a);
      this.clients[a] = d;
      a = new b.TPresence({state:b.TPresenceState.ENTER, clientId:this.clientId});
      a.clientData = L.createPayload(d);
      this.channel.state == "pending" ? this.pendingPresence = {presence:"enter", callback:e} : this.channel.state == "subscribed" && channel.sendPresence(a, listener)
    };
    a.prototype.leave = function(a) {
      if(!this.clientId) {
        throw Error("clientId must have been specified to enter or leave a presence channel");
      }
      this.leaveClient(this.clientId, a)
    };
    a.prototype.leaveClient = function(a, d) {
      h.logAction(h.LOG_MICRO, "Presence.leaveClient()", "leaving; channel = " + this.channel.name + ", client = " + a);
      delete this.clients[a];
      var e = new b.TPresence({state:b.TPresenceState.LEAVE, clientId:this.channel.ably.options.clientId});
      this.channel.state == "subscribed" ? this.channel.sendPresence(e, d) : this.channel.state == "pending" ? this.pendingPresence = {presence:"leave", callback:d} : delete this.pendingPresence
    };
    a.prototype.get = function(a) {
      return clients[a || this.clientId]
    };
    a.prototype.setPresence = function(a, b) {
      h.logAction(h.LOG_MICRO, "Presence.setPresence()", "received presence for " + a.length + " participants; channel = " + this.channel.name + ", client = " + j);
      for(var d in a) {
        var f = a[d], i = void 0, j = f.clientId;
        f.state == "leave" ? delete this.clients[j] : i = this.clients[j] = Q.getPayload(f.clientData);
        b && this.emit(f.state, j, i)
      }
    };
    a.prototype.setSubscribed = function() {
      this.pendingPresence && (h.logAction(h.LOG_MICRO, "Presence.setSubscribed", "sending queued presence; state = " + this.state), this.channel.sendPresence(this.pendingPresence.presence, this.pendingPresence.callback), delete this.pendingPresence)
    };
    a.prototype.setSuspended = function(a) {
      this.pendingPresence && (this.pendingPresence.callback(a.defaultMessage), delete this.pendingPresence)
    };
    return a
  }(), Q = function() {
    function a(a, b, c, d) {
      this.channelSerial = a;
      this.timestamp = b;
      this.name = c;
      this.data = d
    }
    var b = typeof s == "object" ? s : require("../nodejs/lib/protocol/clientmessage_types"), c = {"[object Null]":function(a) {
      a.type = b.TType.NONE;
      return!0
    }, "[object Buffer]":function(a, c) {
      a.type = b.TType.BUFFER;
      a.binaryData = c;
      return!0
    }, "[object ArrayBuffer]":function(a, c) {
      a.type = b.TType.BUFFER;
      a.binaryData = c;
      return!0
    }, "[object Array]":function(a, c) {
      a.type = b.TType.LIST;
      a.listData = c;
      return!0
    }, "[object String]":function(a, c) {
      a.type = b.TType.STRING;
      a.stringData = c.valueOf();
      return!0
    }, "[object Number]":function(a, c) {
      a.type = b.TType.DOUBLE;
      a.doubleData = c.valueOf();
      return!0
    }, "[object Boolean]":function(a, c) {
      a.type = c.valueOf() ? b.TType.TRUE : b.TType.FALSE;
      return!0
    }, "[object Object]":function(a, c) {
      result.type = b.TType.MAP;
      result.mapData = c;
      return!0
    }, "[object Function]":function(a, c) {
      result.type = b.TType.MAP;
      result.mapData = c;
      return!0
    }}, d = {undefined:function(a) {
      a.type = b.TType.NONE;
      return!0
    }, "boolean":function(a, c) {
      a.type = c ? b.TType.TRUE : b.TType.FALSE;
      return!0
    }, string:function(a, c) {
      a.type = b.TType.STRING;
      a.stringData = c;
      return!0
    }, number:function(a, c) {
      a.type = b.TType.DOUBLE;
      a.doubleData = c;
      return!0
    }, object:function(a, b) {
      var d = c[Object.prototype.toString.call(b)];
      return d && d(result, b)
    }};
    a.createPayload = function(a) {
      var c = new b.TData, h = d[typeof a];
      if(h && h(c, a)) {
        return c
      }
      throw Error("Unsupported data type: " + Object.prototype.toString.call(a));
    };
    a.getPayload = function(a) {
      var b = void 0;
      switch(a.type) {
        case 1:
          b = !0;
          break;
        case 2:
          b = !1;
          break;
        case 3:
          b = a.i32Data;
          break;
        case 4:
          b = a.i64Data;
          break;
        case 5:
          b = a.doubleData;
          break;
        case 6:
          b = a.stringData;
          break;
        case 7:
          b = a.binaryData;
          break;
        case 8:
          b = a.listData;
          break;
        case 9:
          b = a.mapData
      }
      return b
    };
    return a
  }();
  window.Ably = {Realtime:this.Realtime}
})();
