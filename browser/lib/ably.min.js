(function() {
  for(var V = {disconnected:{statusCode:408, code:80003, reason:"Connection to server temporarily unavailable"}, suspended:{statusCode:408, code:80002, reason:"Connection to server unavailable"}, failed:{statusCode:408, code:8E4, reason:"Connection failed or disconnected by server"}}, Ma = function(a, b, c) {
    function f() {
    }
    f.prototype = b.prototype;
    a.prototype = new f;
    if(c) {
      for(var j in c) {
        a.prototype[j] = c[j]
      }
    }
  }, jb = [], na = 0;256 > na;na++) {
    jb[na] = (15 < na ? "" : "0") + na.toString(16)
  }
  var ea = function(a, b) {
    a instanceof Array ? (this.buffer = a, this.offset = b || 0) : (this.buffer = this.buffer || Array(8), this.offset = 0, this.setValue.apply(this, arguments))
  };
  ea.MAX_INT = Math.pow(2, 53);
  ea.MIN_INT = -Math.pow(2, 53);
  ea.prototype = {_2scomp:function() {
    for(var a = this.buffer, b = this.offset, c = 1, f = b + 7;f >= b;f--) {
      c = (a[f] ^ 255) + c, a[f] = c & 255, c >>= 8
    }
  }, setValue:function(a, b) {
    var c = !1;
    if(1 == arguments.length) {
      if("number" == typeof a) {
        c = 0 > a;
        a = Math.abs(a);
        b = a % 4294967296;
        a /= 4294967296;
        if(4294967296 < a) {
          throw new RangeError(a + " is outside Int64 range");
        }
        a |= 0
      }else {
        if("string" == typeof a) {
          a = (a + "").replace(/^0x/, ""), b = a.substr(-8), a = 8 < a.length ? a.substr(0, a.length - 8) : "", a = parseInt(a, 16), b = parseInt(b, 16)
        }else {
          throw Error(a + " must be a Number or String");
        }
      }
    }
    for(var f = this.buffer, j = this.offset, d = 7;0 <= d;d--) {
      f[j + d] = b & 255, b = 4 == d ? a : b >>> 8
    }
    c && this._2scomp()
  }, toNumber:function(a) {
    for(var b = this.buffer, c = this.offset, f = b[0] & 128, j = 0, d = 1, e = 7, r = 1;0 <= e;e--, r *= 256) {
      var p = b[c + e];
      f && (p = (p ^ 255) + d, d = p >> 8, p &= 255);
      j += p * r
    }
    return!a && j >= ea.MAX_INT ? f ? -Infinity : Infinity : f ? -j : j
  }, valueOf:function() {
    return this.toNumber(!1)
  }, toString:function(a) {
    return this.valueOf().toString(a || 10)
  }, toOctetString:function(a) {
    for(var b = Array(8), c = this.buffer, f = this.offset, d = 0;8 > d;d++) {
      b[d] = jb[c[f + d]]
    }
    return b.join(a || "")
  }, inspect:function() {
    return"[Int64 value:" + this + " octets:" + this.toOctetString(" ") + "]"
  }};
  var d = {Version:"0.8.0", Type:{STOP:0, VOID:1, BOOL:2, BYTE:3, I08:3, DOUBLE:4, I16:6, I32:8, I64:10, STRING:11, UTF7:11, STRUCT:12, MAP:13, SET:14, LIST:15, UTF8:16, UTF16:17}, MessageType:{CALL:1, REPLY:2, EXCEPTION:3}, objectLength:function(a) {
    var b = 0, c;
    for(c in a) {
      a.hasOwnProperty(c) && b++
    }
    return b
  }, inherits:function(a, b) {
    function c() {
    }
    c.prototype = b.prototype;
    a.prototype = new c
  }, TException:function(a) {
    this.message = a
  }};
  d.inherits(d.TException, Error);
  d.TException.prototype.name = "TException";
  d.TApplicationExceptionType = {UNKNOWN:0, UNKNOWN_METHOD:1, INVALID_MESSAGE_TYPE:2, WRONG_METHOD_NAME:3, BAD_SEQUENCE_ID:4, MISSING_RESULT:5, INTERNAL_ERROR:6, PROTOCOL_ERROR:7};
  d.TApplicationException = function(a, b) {
    this.message = a;
    this.code = null === b ? 0 : b
  };
  d.inherits(d.TApplicationException, d.TException);
  d.TApplicationException.prototype.name = "TApplicationException";
  d.TApplicationException.prototype.read = function(a) {
    for(;;) {
      var b = a.readFieldBegin();
      if(b.ftype == d.Type.STOP) {
        break
      }
      switch(b.fid) {
        case 1:
          b.ftype == d.Type.STRING ? (b = a.readString(), this.message = b.value) : a.skip(b.ftype);
          break;
        case 2:
          b.ftype == d.Type.I32 ? (b = a.readI32(), this.code = b.value) : a.skip(b.ftype);
          break;
        default:
          a.skip(b.ftype)
      }
      a.readFieldEnd()
    }
    a.readStructEnd()
  };
  d.TApplicationException.prototype.write = function(a) {
    a.writeStructBegin("TApplicationException");
    this.message && (a.writeFieldBegin("message", d.Type.STRING, 1), a.writeString(this.getMessage()), a.writeFieldEnd());
    this.code && (a.writeFieldBegin("type", d.Type.I32, 2), a.writeI32(this.code), a.writeFieldEnd());
    a.writeFieldStop();
    a.writeStructEnd()
  };
  d.TApplicationException.prototype.getCode = function() {
    return this.code
  };
  d.TApplicationException.prototype.getMessage = function() {
    return this.message
  };
  d.TXHRTransport = function(a) {
    this.url = a;
    this.rpos = this.wpos = 0;
    this.recv_buf = this.send_buf = ""
  };
  d.TXHRTransport.prototype = {getXmlHttpRequestObject:function() {
    try {
      return new XMLHttpRequest
    }catch(a) {
    }
    try {
      return new ActiveXObject("Msxml2.XMLHTTP")
    }catch(b) {
    }
    try {
      return new ActiveXObject("Microsoft.XMLHTTP")
    }catch(c) {
    }
    throw"Your browser doesn't support the XmlHttpRequest object.";
  }, flush:function(a) {
    if(a || void 0 === this.url || "" === this.url) {
      return this.send_buf
    }
    a = this.getXmlHttpRequestObject();
    a.overrideMimeType && a.overrideMimeType("application/json");
    a.open("POST", this.url, !1);
    a.send(this.send_buf);
    if(4 != a.readyState) {
      throw"encountered an unknown ajax ready state: " + a.readyState;
    }
    if(200 != a.status) {
      throw"encountered a unknown request status: " + a.status;
    }
    this.recv_buf = a.responseText;
    this.wpos = this.recv_buf_sz = this.recv_buf.length;
    this.rpos = 0
  }, jqRequest:function(a, b, c, f) {
    if("undefined" === typeof jQuery || "undefined" === typeof jQuery.Deferred) {
      throw"Thrift.js requires jQuery 1.5+ to use asynchronous requests";
    }
    var d = jQuery.Deferred(), e = jQuery._Deferred(), k = d.promise();
    k.success = k.done;
    k.error = k.fail;
    k.complete = e.done;
    b = jQuery.ajax({url:this.url, data:b, type:"POST", cache:!1, dataType:"text", context:this, success:this.jqResponse, error:function(b, c, f) {
      d.rejectWith(a, jQuery.merge([f], b.tArgs))
    }, complete:function(b, c) {
      e.resolveWith(a, [b, c])
    }});
    d.done(jQuery.makeArray(c).pop());
    b.tArgs = c;
    b.tClient = a;
    b.tRecvFn = f;
    b.tDfd = d;
    return k
  }, jqResponse:function(a, b, c) {
    this.setRecvBuffer(a);
    try {
      var f = c.tRecvFn.call(c.tClient);
      c.tDfd.resolveWith(c, jQuery.merge([f], c.tArgs))
    }catch(d) {
      c.tDfd.rejectWith(c, jQuery.merge([d], c.tArgs))
    }
  }, setRecvBuffer:function(a) {
    this.recv_buf = a;
    this.wpos = this.recv_buf_sz = this.recv_buf.length;
    this.rpos = 0
  }, isOpen:function() {
    return!0
  }, open:function() {
  }, close:function() {
  }, read:function(a) {
    var b = this.wpos - this.rpos;
    if(0 === b) {
      return""
    }
    var c = a;
    b < a && (c = b);
    a = this.read_buf.substr(this.rpos, c);
    this.rpos += c;
    return a
  }, readAll:function() {
    return this.recv_buf
  }, write:function(a) {
    this.send_buf = a
  }, getSendBuffer:function() {
    return this.send_buf
  }};
  d.TStringTransport = function(a, b) {
    this.send_buf = "";
    this.recv_buf = a || "";
    this.onFlush = b
  };
  d.TStringTransport.prototype = {flush:function() {
    if(this.onFlush) {
      this.onFlush(this.send_buf)
    }
  }, isOpen:function() {
    return!0
  }, open:function() {
  }, close:function() {
  }, read:function() {
    return this.recv_buf
  }, readAll:function() {
    return this.recv_buf
  }, write:function(a) {
    this.send_buf = a
  }};
  d.Protocol = function(a) {
    this.transport = a
  };
  d.Protocol.Type = {};
  d.Protocol.Type[d.Type.BOOL] = '"tf"';
  d.Protocol.Type[d.Type.BYTE] = '"i8"';
  d.Protocol.Type[d.Type.I16] = '"i16"';
  d.Protocol.Type[d.Type.I32] = '"i32"';
  d.Protocol.Type[d.Type.I64] = '"i64"';
  d.Protocol.Type[d.Type.DOUBLE] = '"dbl"';
  d.Protocol.Type[d.Type.STRUCT] = '"rec"';
  d.Protocol.Type[d.Type.STRING] = '"str"';
  d.Protocol.Type[d.Type.MAP] = '"map"';
  d.Protocol.Type[d.Type.LIST] = '"lst"';
  d.Protocol.Type[d.Type.SET] = '"set"';
  d.Protocol.RType = {};
  d.Protocol.RType.tf = d.Type.BOOL;
  d.Protocol.RType.i8 = d.Type.BYTE;
  d.Protocol.RType.i16 = d.Type.I16;
  d.Protocol.RType.i32 = d.Type.I32;
  d.Protocol.RType.i64 = d.Type.I64;
  d.Protocol.RType.dbl = d.Type.DOUBLE;
  d.Protocol.RType.rec = d.Type.STRUCT;
  d.Protocol.RType.str = d.Type.STRING;
  d.Protocol.RType.map = d.Type.MAP;
  d.Protocol.RType.lst = d.Type.LIST;
  d.Protocol.RType.set = d.Type.SET;
  d.Protocol.Version = 1;
  d.Protocol.prototype = {getTransport:function() {
    return this.transport
  }, writeMessageBegin:function(a, b, c) {
    this.tstack = [];
    this.tpos = [];
    this.tstack.push([d.Protocol.Version, '"' + a + '"', b, c])
  }, writeMessageEnd:function() {
    var a = this.tstack.pop();
    this.wobj = this.tstack.pop();
    this.wobj.push(a);
    this.wbuf = "[" + this.wobj.join(",") + "]";
    this.transport.write(this.wbuf)
  }, writeStructBegin:function() {
    this.tpos.push(this.tstack.length);
    this.tstack.push({})
  }, writeStructEnd:function() {
    var a = this.tpos.pop(), b = this.tstack[a], c = "{", f = !0, d;
    for(d in b) {
      f ? f = !1 : c += ",", c += d + ":" + b[d]
    }
    this.tstack[a] = c + "}"
  }, writeFieldBegin:function(a, b, c) {
    this.tpos.push(this.tstack.length);
    this.tstack.push({fieldId:'"' + c + '"', fieldType:d.Protocol.Type[b]})
  }, writeFieldEnd:function() {
    var a = this.tstack.pop(), b = this.tstack.pop();
    this.tstack[this.tstack.length - 1][b.fieldId] = "{" + b.fieldType + ":" + a + "}";
    this.tpos.pop()
  }, writeFieldStop:function() {
  }, writeMapBegin:function(a, b) {
    this.tpos.push(this.tstack.length);
    this.tstack.push([d.Protocol.Type[a], d.Protocol.Type[b], 0])
  }, writeMapEnd:function() {
    var a = this.tpos.pop();
    if(a != this.tstack.length) {
      0 !== (this.tstack.length - a - 1) % 2 && this.tstack.push("");
      this.tstack[a][this.tstack[a].length - 1] = (this.tstack.length - a - 1) / 2;
      for(var b = "}", c = !0;this.tstack.length > a + 1;) {
        var f = this.tstack.pop(), d = this.tstack.pop();
        c ? c = !1 : b = "," + b;
        isNaN(d) || (d = '"' + d + '"');
        b = d + ":" + f + b
      }
      this.tstack[a].push("{" + b);
      this.tstack[a] = "[" + this.tstack[a].join(",") + "]"
    }
  }, writeListBegin:function(a, b) {
    this.tpos.push(this.tstack.length);
    this.tstack.push([d.Protocol.Type[a], b])
  }, writeListEnd:function() {
    for(var a = this.tpos.pop();this.tstack.length > a + 1;) {
      var b = this.tstack[a + 1];
      this.tstack.splice(a + 1, 1);
      this.tstack[a].push(b)
    }
    this.tstack[a] = "[" + this.tstack[a].join(",") + "]"
  }, writeSetBegin:function(a, b) {
    this.tpos.push(this.tstack.length);
    this.tstack.push([d.Protocol.Type[a], b])
  }, writeSetEnd:function() {
    for(var a = this.tpos.pop();this.tstack.length > a + 1;) {
      var b = this.tstack[a + 1];
      this.tstack.splice(a + 1, 1);
      this.tstack[a].push(b)
    }
    this.tstack[a] = "[" + this.tstack[a].join(",") + "]"
  }, writeBool:function(a) {
    this.tstack.push(a ? 1 : 0)
  }, writeByte:function(a) {
    this.tstack.push(a)
  }, writeI16:function(a) {
    this.tstack.push(a)
  }, writeI32:function(a) {
    this.tstack.push(a)
  }, writeI64:function(a) {
    this.tstack.push(a)
  }, writeDouble:function(a) {
    this.tstack.push(a)
  }, writeString:function(a) {
    if(null === a) {
      this.tstack.push(null)
    }else {
      for(var b = "", c = 0;c < a.length;c++) {
        var f = a.charAt(c), b = '"' === f ? b + '\\"' : "\\" === f ? b + "\\\\" : "\b" === f ? b + "\\b" : "\f" === f ? b + "\\f" : "\n" === f ? b + "\\n" : "\r" === f ? b + "\\r" : "\t" === f ? b + "\\t" : b + f
      }
      this.tstack.push('"' + b + '"')
    }
  }, writeBinary:function(a) {
    this.writeString(a)
  }, readMessageBegin:function() {
    this.rstack = [];
    this.rpos = [];
    this.robj = "undefined" !== typeof jQuery ? jQuery.parseJSON(this.transport.readAll()) : eval(this.transport.readAll());
    var a = {}, b = this.robj.shift();
    if(b != d.Protocol.Version) {
      throw"Wrong thrift protocol version: " + b;
    }
    a.fname = this.robj.shift();
    a.mtype = this.robj.shift();
    a.rseqid = this.robj.shift();
    this.rstack.push(this.robj.shift());
    return a
  }, readMessageEnd:function() {
  }, readStructBegin:function() {
    this.rstack[this.rstack.length - 1] instanceof Array && this.rstack.push(this.rstack[this.rstack.length - 1].shift());
    return{fname:""}
  }, readStructEnd:function() {
    this.rstack[this.rstack.length - 2] instanceof Array && this.rstack.pop()
  }, readFieldBegin:function() {
    var a = {}, b = -1, c = d.Type.STOP, f;
    for(f in this.rstack[this.rstack.length - 1]) {
      if(null !== f) {
        b = parseInt(f, 10);
        this.rpos.push(this.rstack.length);
        f = this.rstack[this.rstack.length - 1][b];
        delete this.rstack[this.rstack.length - 1][b];
        this.rstack.push(f);
        break
      }
    }
    if(-1 != b) {
      for(var j in this.rstack[this.rstack.length - 1]) {
        null !== d.Protocol.RType[j] && (c = d.Protocol.RType[j], this.rstack[this.rstack.length - 1] = this.rstack[this.rstack.length - 1][j])
      }
    }
    a.fname = "";
    a.ftype = c;
    a.fid = b;
    return a
  }, readFieldEnd:function() {
    for(var a = this.rpos.pop();this.rstack.length > a;) {
      this.rstack.pop()
    }
  }, readMapBegin:function() {
    var a = this.rstack.pop(), b = {};
    b.ktype = d.Protocol.RType[a.shift()];
    b.vtype = d.Protocol.RType[a.shift()];
    b.size = a.shift();
    this.rpos.push(this.rstack.length);
    this.rstack.push(a.shift());
    return b
  }, readMapEnd:function() {
    this.readFieldEnd()
  }, readListBegin:function() {
    var a = this.rstack[this.rstack.length - 1], b = {};
    b.etype = d.Protocol.RType[a.shift()];
    b.size = a.shift();
    this.rpos.push(this.rstack.length);
    this.rstack.push(a);
    return b
  }, readListEnd:function() {
    this.readFieldEnd()
  }, readSetBegin:function(a, b) {
    return this.readListBegin(a, b)
  }, readSetEnd:function() {
    return this.readListEnd()
  }, readBool:function() {
    var a = this.readI32();
    a.value = null !== a && "1" == a.value ? !0 : !1;
    return a
  }, readByte:function() {
    return this.readI32()
  }, readI16:function() {
    return this.readI32()
  }, readI32:function(a) {
    void 0 === a && (a = this.rstack[this.rstack.length - 1]);
    var b = {};
    if(a instanceof Array) {
      b.value = 0 === a.length ? void 0 : a.shift()
    }else {
      if(a instanceof Object) {
        for(var c in a) {
          if(null !== c) {
            this.rstack.push(a[c]);
            delete a[c];
            b.value = c;
            break
          }
        }
      }else {
        b.value = a, this.rstack.pop()
      }
    }
    return b
  }, readI64:function() {
    return this.readI32()
  }, readDouble:function() {
    return this.readI32()
  }, readString:function() {
    return this.readI32()
  }, readBinary:function() {
    return this.readString()
  }, skip:function() {
    throw"skip not supported yet";
  }};
  d.TJSONProtocol = function(a) {
    this.transport = a;
    this.reset()
  };
  d.TJSONProtocol.Type = {};
  d.TJSONProtocol.Type[d.Type.BOOL] = "tf";
  d.TJSONProtocol.Type[d.Type.BYTE] = "i8";
  d.TJSONProtocol.Type[d.Type.I16] = "i16";
  d.TJSONProtocol.Type[d.Type.I32] = "i32";
  d.TJSONProtocol.Type[d.Type.I64] = "i64";
  d.TJSONProtocol.Type[d.Type.DOUBLE] = "dbl";
  d.TJSONProtocol.Type[d.Type.STRUCT] = "rec";
  d.TJSONProtocol.Type[d.Type.STRING] = "str";
  d.TJSONProtocol.Type[d.Type.MAP] = "map";
  d.TJSONProtocol.Type[d.Type.LIST] = "lst";
  d.TJSONProtocol.Type[d.Type.SET] = "set";
  d.TJSONProtocol.getValueFromScope = function(a) {
    var b = a.listvalue;
    return b ? b.shift() : a.value
  };
  d.TJSONProtocol.getScopeFromScope = function(a) {
    var b = a.listvalue;
    b && (a = {value:b.shift()});
    return a
  };
  d.TJSONProtocol.prototype = {reset:function() {
    this.elementStack = []
  }, writeMessageBegin:function() {
    throw Error("TJSONProtocol: Message not supported");
  }, writeMessageEnd:function() {
  }, writeStructBegin:function() {
    this.elementStack.unshift({})
  }, writeStructEnd:function() {
    var a = this.elementStack.shift();
    0 == this.elementStack.length ? this.transport.write(JSON.stringify(a)) : this.elementStack[0].value.push(a)
  }, writeFieldBegin:function(a, b, c) {
    this.elementStack.unshift({name:a, fieldType:d.TJSONProtocol.Type[b], fieldId:c, value:[]})
  }, writeFieldEnd:function() {
    var a = this.elementStack.shift(), b = {};
    b[a.fieldType] = a.value[0];
    this.elementStack[0][a.fieldId] = b
  }, writeFieldStop:function() {
  }, writeMapBegin:function(a, b, c) {
    this.elementStack.unshift({value:[d.TJSONProtocol.Type[a], d.TJSONProtocol.Type[b], c]})
  }, writeMapEnd:function() {
    var a = this.elementStack.shift();
    this.elementStack[0].value.push(a.value)
  }, writeListBegin:function(a, b) {
    this.elementStack.unshift({name:name, value:[d.TJSONProtocol.Type[a], b]})
  }, writeListEnd:function() {
    var a = this.elementStack.shift();
    this.elementStack[0].value.push(a.value)
  }, writeSetBegin:function(a, b) {
    this.elementStack.unshift({name:name, value:[d.TJSONProtocol.Type[a], b]})
  }, writeSetEnd:function() {
    var a = this.elementStack.shift();
    this.elementStack[0].value.push(a.value)
  }, writeBool:function(a) {
    this.elementStack[0].value.push(a ? 1 : 0)
  }, writeByte:function(a) {
    this.elementStack[0].value.push(a)
  }, writeI16:function(a) {
    this.elementStack[0].value.push(a)
  }, writeI32:function(a) {
    this.elementStack[0].value.push(a)
  }, writeI64:function(a) {
    this.elementStack[0].value.push(a)
  }, writeDouble:function(a) {
    this.elementStack[0].value.push(a)
  }, writeString:function(a) {
    this.elementStack[0].value.push(a)
  }, writeBinary:function(a) {
    this.elementStack[0].value.push(a)
  }, readMessageBegin:function() {
    throw Error("TJSONProtocol: Message not supported");
  }, readMessageEnd:function() {
  }, readStructBegin:function() {
    var a;
    a = 0 == this.elementStack.length ? JSON.parse(this.transport.readAll()) : d.TJSONProtocol.getValueFromScope(this.elementStack[0]);
    var b = [], c;
    for(c in a) {
      b.push(c)
    }
    this.elementStack.unshift({fields:b, value:a});
    return{fname:""}
  }, readStructEnd:function() {
    this.elementStack.shift()
  }, readFieldBegin:function() {
    var a = this.elementStack[0], b = d.TJSONProtocol.getValueFromScope(a), a = a.fields.shift();
    if(!a) {
      return{fname:"", ftype:d.Type.STOP}
    }
    var b = b[a], c;
    for(c in b) {
      return this.elementStack.unshift({value:b[c]}), {fname:"", fid:Number(a), ftype:d.Protocol.RType[c]}
    }
    throw Error("TJSONProtocol: parse error reading field value");
  }, readFieldEnd:function() {
    this.elementStack.shift()
  }, readMapBegin:function() {
    var a = d.TJSONProtocol.getValueFromScope(this.elementStack[0]), b = {ktype:d.Protocol.RType[a.shift()], vtype:d.Protocol.RType[a.shift()], size:a.shift()};
    this.elementStack.unshift({listvalue:a});
    return b
  }, readMapEnd:function() {
    this.elementStack.shift()
  }, readListBegin:function() {
    var a = d.TJSONProtocol.getValueFromScope(this.elementStack[0]), b = {etype:d.Protocol.RType[a.shift()], size:a.shift()};
    this.elementStack.unshift({listvalue:a});
    return b
  }, readListEnd:function() {
    this.elementStack.shift()
  }, readSetBegin:function() {
    var a = d.TJSONProtocol.getValueFromScope(this.elementStack[0]), b = {etype:d.Protocol.RType[a.shift()], size:a.shift()};
    this.elementStack.unshift({listvalue:a});
    return b
  }, readSetEnd:function() {
    this.elementStack.shift()
  }, readBool:function() {
    return!!d.TJSONProtocol.getValueFromScope(this.elementStack[0])
  }, readByte:function() {
    return d.TJSONProtocol.getValueFromScope(this.elementStack[0])
  }, readI16:function() {
    return d.TJSONProtocol.getValueFromScope(this.elementStack[0])
  }, readI32:function() {
    return d.TJSONProtocol.getValueFromScope(this.elementStack[0])
  }, readI64:function() {
    return d.TJSONProtocol.getValueFromScope(this.elementStack[0])
  }, readDouble:function() {
    return d.TJSONProtocol.getValueFromScope(this.elementStack[0])
  }, readString:function() {
    return d.TJSONProtocol.getValueFromScope(this.elementStack[0])
  }, readBinary:function() {
    return d.TJSONProtocol.getValueFromScope(this.elementStack[0])
  }, flush:function() {
    this.transport.flush()
  }};
  var Na = {encode:function(a, b, c) {
    for(var f = c, d = 0;d < a.length;d++) {
      var e = a.charCodeAt(d);
      128 > e ? b.setInt8(f++, e) : (127 < e && 2048 > e ? b.setInt8(f++, e >> 6 | 192) : (b.setInt8(f++, e >> 12 | 224), b.setInt8(f++, e >> 6 & 63 | 128)), b.setInt8(f++, e & 63 | 128))
    }
    return f - c
  }, decode:function(a, b, c) {
    for(var f = "", d = b, c = c + b, b = c1 = c2 = 0;d < c;) {
      b = a.getInt8(d++), 128 > b ? f += String.fromCharCode(b) : 191 < b && 224 > b ? (c2 = a.getInt8(d++), f += String.fromCharCode((b & 31) << 6 | c2 & 63)) : (c2 = a.getInt8(d++), c3 = a.getInt8(d++), f += String.fromCharCode((b & 15) << 12 | (c2 & 63) << 6 | c3 & 63))
    }
    return f
  }}, B = function(a) {
    this.offset = 0;
    if(this.length = a) {
      a = this.buf = new ArrayBuffer(a), this.view = new DataView(a)
    }
  };
  B.prototype = {getArray:function() {
    this.array || (this.array = new Uint8Array(this.buf, this.offset, this.length));
    return this.array
  }, slice:function(a, b) {
    var a = a || 0, b = b || this.length, c = new B, f = c.length = b - a, d = c.offset = this.offset + a, e = c.buf = this.buf;
    c.view = new DataView(e, d, f);
    return c
  }, getInt8:function(a) {
    return this.view.getInt8(a)
  }, getInt16:function(a) {
    return this.view.getInt16(a, !1)
  }, getInt32:function(a) {
    return this.view.getInt32(a, !1)
  }, getInt64:function(a) {
    var b = this.view.getInt32(a, !1), a = this.view.getUint32(a + 4, !1);
    return new ea(b, a)
  }, getFloat64:function(a) {
    return this.view.getFloat64(a, !1)
  }, getUtf8String:function(a, b) {
    return Na.decode(this.view, a, b)
  }, setInt8:function(a, b) {
    this.view.setInt8(a, b)
  }, setInt16:function(a, b) {
    this.view.setInt16(a, b, !1)
  }, setInt32:function(a, b) {
    this.view.setInt32(a, b, !1)
  }, setInt64:function(a, b) {
    this.getArray().set(b.buffer, a)
  }, setFloat64:function(a, b) {
    this.view.setFloat64(a, b, !1)
  }, setBuffer:function(a, b) {
    this.getArray().set(b.getArray(), a)
  }, setUtf8String:function(a, b) {
    return Na.encode(b, this.view, a)
  }, inspect:function() {
    for(var a = "length: " + this.length + "\n", b = 0;b < this.length;) {
      for(var c = 0;b < this.length && 32 > c;c++) {
        a += this.view.getInt8(b++).toString(16) + " "
      }
      a += "\n"
    }
    return a
  }};
  var Mb = d.CheckedBuffer = function(a) {
    B.call(this, a)
  };
  Ma(Mb, B, {grow:function(a) {
    var a = this.length + Math.max(a || 0, 0.41 * this.length), b = getArray();
    this.buf = new ArrayBuffer(a);
    this.view = new DataView(this.buf);
    this.getArray().set(b);
    this.offset = 0;
    this.length = a
  }, checkAvailable:function(a, b) {
    a + b >= this.length && this.grow(b)
  }, setInt8:function(a, b) {
    this.checkAvailable(1);
    this.view.setInt8(a, b)
  }, setInt16:function(a, b) {
    this.checkAvailable(2);
    this.view.setInt16(a, b, !1)
  }, setInt32:function(a, b) {
    this.checkAvailable(4);
    this.view.setInt32(a, b, !1)
  }, setInt64:function(a, b) {
    this.checkAvailable(8);
    this.getArray().set(b.buffer, a)
  }, setFloat64:function(a, b) {
    this.checkAvailable(8);
    this.view.setFloat64(a, b, !1)
  }, setBuffer:function(a, b) {
    this.checkAvailable(b.length);
    this.getArray().set(b.getArray(), a)
  }, setUtf8String:function(a, b) {
    for(;;) {
      try {
        return Na.encode(b, this.view, a)
      }catch(c) {
        this.grow()
      }
    }
  }});
  var D = d.Type, Oa = function(a, b) {
    Error.call(this, b);
    this.name = "TProtocolException";
    this.type = a
  };
  Ma(Oa, Error);
  var m = d.TBinaryProtocol = function(a, b, c) {
    this.trans = a;
    this.strictRead = void 0 !== b ? b : !1;
    this.strictWrite = void 0 !== c ? c : !0
  };
  m.prototype.flush = function() {
    return this.trans.flush()
  };
  m.prototype.writeMessageBegin = function(a, b, c) {
    this.strictWrite ? (this.writeI32(-2147418112 | b), this.writeString(a)) : (this.writeString(a), this.writeByte(b));
    this.writeI32(c)
  };
  m.prototype.writeMessageEnd = function() {
  };
  m.prototype.writeStructBegin = function() {
  };
  m.prototype.writeStructEnd = function() {
  };
  m.prototype.writeFieldBegin = function(a, b, c) {
    this.writeByte(b);
    this.writeI16(c)
  };
  m.prototype.writeFieldEnd = function() {
  };
  m.prototype.writeFieldStop = function() {
    this.writeByte(D.STOP)
  };
  m.prototype.writeMapBegin = function(a, b, c) {
    this.writeByte(a);
    this.writeByte(b);
    this.writeI32(c)
  };
  m.prototype.writeMapEnd = function() {
  };
  m.prototype.writeListBegin = function(a, b) {
    this.writeByte(a);
    this.writeI32(b)
  };
  m.prototype.writeListEnd = function() {
  };
  m.prototype.writeSetBegin = function(a, b) {
    this.writeByte(a);
    this.writeI32(b)
  };
  m.prototype.writeSetEnd = function() {
  };
  m.prototype.writeBool = function(a) {
    this.writeByte(a ? 1 : 0)
  };
  m.prototype.writeByte = function(a) {
    this.trans.writeByte(a)
  };
  m.prototype.writeI16 = function(a) {
    this.trans.writeI16(a)
  };
  m.prototype.writeI32 = function(a) {
    this.trans.writeI32(a)
  };
  m.prototype.writeI64 = function(a) {
    a.buffer ? this.trans.writeI64(a) : this.trans.writeI64(new ea(a))
  };
  m.prototype.writeDouble = function(a) {
    this.trans.writeDouble(a)
  };
  m.prototype.writeString = function(a) {
    this.trans.writeWithLength(a)
  };
  m.prototype.writeBinary = function(a) {
    this.trans.writeWithLength(a)
  };
  m.prototype.readMessageBegin = function() {
    var a = this.readI32(), b, c;
    if(0 > a) {
      b = a & -65536;
      if(-2147418112 != b) {
        throw console.log("BAD: " + b), Oa(4, "Bad version in readMessageBegin: " + a);
      }
      a &= 255;
      b = this.readString()
    }else {
      if(this.strictRead) {
        throw Oa(4, "No protocol version header");
      }
      b = this.trans.read(a);
      a = this.readByte()
    }
    c = this.readI32();
    return{fname:b, mtype:a, rseqid:c}
  };
  m.prototype.readMessageEnd = function() {
  };
  m.prototype.readStructBegin = function() {
    return{fname:""}
  };
  m.prototype.readStructEnd = function() {
  };
  m.prototype.readFieldBegin = function() {
    var a = this.readByte();
    if(a == D.STOP) {
      return{fname:null, ftype:a, fid:0}
    }
    var b = this.readI16();
    return{fname:null, ftype:a, fid:b}
  };
  m.prototype.readFieldEnd = function() {
  };
  m.prototype.readMapBegin = function() {
    var a = this.readByte(), b = this.readByte(), c = this.readI32();
    return{ktype:a, vtype:b, size:c}
  };
  m.prototype.readMapEnd = function() {
  };
  m.prototype.readListBegin = function() {
    var a = this.readByte(), b = this.readI32();
    return{etype:a, size:b}
  };
  m.prototype.readListEnd = function() {
  };
  m.prototype.readSetBegin = function() {
    var a = this.readByte(), b = this.readI32();
    return{etype:a, size:b}
  };
  m.prototype.readSetEnd = function() {
  };
  m.prototype.readBool = function() {
    return 0 == this.readByte() ? !1 : !0
  };
  m.prototype.readByte = function() {
    return this.trans.readByte()
  };
  m.prototype.readI16 = function() {
    return this.trans.readI16()
  };
  m.prototype.readI32 = function() {
    return this.trans.readI32()
  };
  m.prototype.readI64 = function() {
    return this.trans.readI64()
  };
  m.prototype.readDouble = function() {
    return this.trans.readDouble()
  };
  m.prototype.readBinary = function() {
    var a = this.readI32();
    return this.trans.read(a)
  };
  m.prototype.readString = function() {
    var a = this.readI32();
    return this.trans.readString(a)
  };
  m.prototype.getTransport = function() {
    return this.trans
  };
  m.prototype.skip = function(a) {
    switch(a) {
      case D.STOP:
        break;
      case D.BOOL:
        this.readBool();
        break;
      case D.BYTE:
        this.readByte();
        break;
      case D.I16:
        this.readI16();
        break;
      case D.I32:
        this.readI32();
        break;
      case D.I64:
        this.readI64();
        break;
      case D.DOUBLE:
        this.readDouble();
        break;
      case D.STRING:
        this.readString();
        break;
      case D.STRUCT:
        for(this.readStructBegin();;) {
          a = this.readFieldBegin();
          if(a.ftype === D.STOP) {
            break
          }
          this.skip(a.ftype);
          this.readFieldEnd()
        }
        this.readStructEnd();
        break;
      case D.MAP:
        for(var a = this.readMapBegin(), b = 0;b < a.size;++b) {
          this.skip(a.ktype), this.skip(a.vtype)
        }
        this.readMapEnd();
        break;
      case D.SET:
        a = this.readSetBegin();
        for(b = 0;b < a.size;++b) {
          this.skip(a.etype)
        }
        this.readSetEnd();
        break;
      case D.LIST:
        a = this.readListBegin();
        for(b = 0;b < a.size;++b) {
          this.skip(a.etype)
        }
        this.readListEnd();
        break;
      default:
        throw Error("Invalid type: " + a);
    }
  };
  var Nb = new B(0), fa = d.TTransport = function(a, b) {
    this.buf = a || Nb;
    this.onFlush = b;
    this.reset()
  };
  fa.receiver = function(a) {
    return function(b) {
      a(new fa(b))
    }
  };
  fa.prototype = {commitPosition:function() {
  }, rollbackPosition:function() {
  }, reset:function() {
    this.pos = 0
  }, isOpen:function() {
    return!0
  }, open:function() {
  }, close:function() {
  }, read:function(a) {
    var b = this.pos + a;
    if(this.buf.length < b) {
      throw Error("read(" + a + ") failed - not enough data");
    }
    a = this.buf.slice(this.pos, b);
    this.pos = b;
    return a
  }, readByte:function() {
    return this.buf.getInt8(this.pos++)
  }, readI16:function() {
    var a = this.buf.getInt16(this.pos);
    this.pos += 2;
    return a
  }, readI32:function() {
    var a = this.buf.getInt32(this.pos);
    this.pos += 4;
    return a
  }, readDouble:function() {
    var a = this.buf.getFloat64(this.pos);
    this.pos += 8;
    return a
  }, readString:function(a) {
    var b = this.buf.getUtf8String(this.pos, a);
    this.pos += a;
    return b
  }, readAll:function() {
    return this.buf
  }, writeByte:function(a) {
    this.buf.setInt8(this.pos++, a)
  }, writeI16:function(a) {
    this.buf.setInt16(this.pos, a);
    this.pos += 2
  }, writeI32:function(a) {
    this.buf.setInt32(this.pos, a);
    this.pos += 4
  }, writeI64:function(a) {
    this.buf.setInt64(this.pos, a);
    this.pos += 8
  }, writeDouble:function(a) {
    this.buf.setFloat64(this.pos, a);
    this.pos += 8
  }, write:function(a) {
    "string" === typeof a ? this.pos += this.setUtf8String(this.pos, a) : (this.setBuffer(this.pos, a), this.pos += a.length)
  }, writeWithLength:function(a) {
    "string" === typeof a ? a = this.buf.setUtf8String(this.pos + 4, a) : (this.setBuffer(this.pos + 4, a), a = a.length);
    this.buf.setInt32(this.pos, a);
    this.pos += a + 4
  }, flush:function(a) {
    if(a = a || this.onFlush) {
      var b = this.buf.slice(0, this.pos);
      a(b)
    }
  }};
  var Pa = d.TFramedTransport = function(a, b) {
    fa.call(this, a, b)
  };
  Pa.receiver = function(a) {
    var b = 0, c = 0, f = null, d = null;
    return function(e) {
      if(d) {
        var k = new B(e.length + d.length);
        d.copy(k, 0, 0);
        e.copy(k, d.length, 0);
        d = null
      }
      for(;e.length;) {
        if(0 === b) {
          if(4 > e.length) {
            console.log("Expecting > 4 bytes, found only " + e.length);
            d = e;
            break
          }
          b = binary.readI32(e, 0);
          f = new B(b);
          c = 0;
          e = e.slice(4, e.length)
        }
        e.length >= b ? (e.copy(f, c, 0, b), e = e.slice(b, e.length), b = 0, a(new Pa(f))) : e.length && (e.copy(f, c, 0, e.length), b -= e.length, c += e.length, e = e.slice(e.length, e.length))
      }
    }
  };
  Ma(Pa, fa, {flush:function() {
    var a = this;
    fa.prototype.flush.call(this, function(b) {
      if(a.onFlush) {
        var c = new B(b.length + 4);
        binary.writeI32(c, b.length);
        b.copy(c, 4, 0, b.length);
        a.onFlush(c)
      }
    })
  }});
  var W, X, Y, ga, oa;
  TAction = {HEARTBEAT:0, ACK:1, NACK:2, CONNECT:3, CONNECTED:4, DISCONNECT:5, DISCONNECTED:6, ERROR:7, ATTACH:8, ATTACHED:9, DETACH:10, DETACHED:11, PRESENCE:12, MESSAGE:13};
  TType = {NONE:0, TRUE:1, FALSE:2, INT32:3, INT64:4, DOUBLE:5, STRING:6, BUFFER:7, JSONARRAY:8, JSONOBJECT:9};
  TFlags = {SYNC_TIME:0};
  TPresenceState = {ENTER:0, LEAVE:1, UPDATE:2};
  TError = function(a) {
    this.reason = this.code = this.statusCode = void 0;
    a && (void 0 !== a.statusCode && (this.statusCode = a.statusCode), void 0 !== a.code && (this.code = a.code), void 0 !== a.reason && (this.reason = a.reason))
  };
  TError.prototype = {};
  TError.prototype.read = function(a) {
    for(a.readStructBegin();;) {
      var b = a.readFieldBegin(), c = b.ftype;
      if(c == d.Type.STOP) {
        break
      }
      switch(b.fid) {
        case 1:
          c == d.Type.I16 ? this.statusCode = a.readI16() : a.skip(c);
          break;
        case 2:
          c == d.Type.I16 ? this.code = a.readI16() : a.skip(c);
          break;
        case 3:
          c == d.Type.STRING ? this.reason = a.readString() : a.skip(c);
          break;
        default:
          a.skip(c)
      }
      a.readFieldEnd()
    }
    a.readStructEnd()
  };
  TError.prototype.write = function(a) {
    a.writeStructBegin("TError");
    void 0 !== this.statusCode && (a.writeFieldBegin("statusCode", d.Type.I16, 1), a.writeI16(this.statusCode), a.writeFieldEnd());
    void 0 !== this.code && (a.writeFieldBegin("code", d.Type.I16, 2), a.writeI16(this.code), a.writeFieldEnd());
    void 0 !== this.reason && (a.writeFieldBegin("reason", d.Type.STRING, 3), a.writeString(this.reason), a.writeFieldEnd());
    a.writeFieldStop();
    a.writeStructEnd()
  };
  W = function(a) {
    this.binaryData = this.stringData = this.doubleData = this.i64Data = this.i32Data = this.type = void 0;
    a && (void 0 !== a.type && (this.type = a.type), void 0 !== a.i32Data && (this.i32Data = a.i32Data), void 0 !== a.i64Data && (this.i64Data = a.i64Data), void 0 !== a.doubleData && (this.doubleData = a.doubleData), void 0 !== a.stringData && (this.stringData = a.stringData), void 0 !== a.binaryData && (this.binaryData = a.binaryData))
  };
  W.prototype = {};
  W.prototype.read = function(a) {
    for(a.readStructBegin();;) {
      var b = a.readFieldBegin(), c = b.ftype;
      if(c == d.Type.STOP) {
        break
      }
      switch(b.fid) {
        case 1:
          c == d.Type.I32 ? this.type = a.readI32() : a.skip(c);
          break;
        case 2:
          c == d.Type.I32 ? this.i32Data = a.readI32() : a.skip(c);
          break;
        case 3:
          c == d.Type.I64 ? this.i64Data = a.readI64() : a.skip(c);
          break;
        case 4:
          c == d.Type.DOUBLE ? this.doubleData = a.readDouble() : a.skip(c);
          break;
        case 5:
          c == d.Type.STRING ? this.stringData = a.readString() : a.skip(c);
          break;
        case 6:
          c == d.Type.STRING ? this.binaryData = a.readBinary() : a.skip(c);
          break;
        default:
          a.skip(c)
      }
      a.readFieldEnd()
    }
    a.readStructEnd()
  };
  W.prototype.write = function(a) {
    a.writeStructBegin("TData");
    void 0 !== this.type && (a.writeFieldBegin("type", d.Type.I32, 1), a.writeI32(this.type), a.writeFieldEnd());
    void 0 !== this.i32Data && (a.writeFieldBegin("i32Data", d.Type.I32, 2), a.writeI32(this.i32Data), a.writeFieldEnd());
    void 0 !== this.i64Data && (a.writeFieldBegin("i64Data", d.Type.I64, 3), a.writeI64(this.i64Data), a.writeFieldEnd());
    void 0 !== this.doubleData && (a.writeFieldBegin("doubleData", d.Type.DOUBLE, 4), a.writeDouble(this.doubleData), a.writeFieldEnd());
    void 0 !== this.stringData && (a.writeFieldBegin("stringData", d.Type.STRING, 5), a.writeString(this.stringData), a.writeFieldEnd());
    void 0 !== this.binaryData && (a.writeFieldBegin("binaryData", d.Type.STRING, 6), a.writeString(this.binaryData), a.writeFieldEnd());
    a.writeFieldStop();
    a.writeStructEnd()
  };
  X = function(a) {
    this.clientData = this.connectionId = this.clientId = this.state = void 0;
    a && (void 0 !== a.state && (this.state = a.state), void 0 !== a.clientId && (this.clientId = a.clientId), void 0 !== a.connectionId && (this.connectionId = a.connectionId), void 0 !== a.clientData && (this.clientData = a.clientData))
  };
  X.prototype = {};
  X.prototype.read = function(a) {
    for(a.readStructBegin();;) {
      var b = a.readFieldBegin(), c = b.ftype;
      if(c == d.Type.STOP) {
        break
      }
      switch(b.fid) {
        case 1:
          c == d.Type.I32 ? this.state = a.readI32() : a.skip(c);
          break;
        case 2:
          c == d.Type.STRING ? this.clientId = a.readString() : a.skip(c);
          break;
        case 3:
          c == d.Type.STRING ? this.connectionId = a.readString() : a.skip(c);
          break;
        case 4:
          c == d.Type.STRUCT ? (this.clientData = new W, this.clientData.read(a)) : a.skip(c);
          break;
        default:
          a.skip(c)
      }
      a.readFieldEnd()
    }
    a.readStructEnd()
  };
  X.prototype.write = function(a) {
    a.writeStructBegin("TPresence");
    void 0 !== this.state && (a.writeFieldBegin("state", d.Type.I32, 1), a.writeI32(this.state), a.writeFieldEnd());
    void 0 !== this.clientId && (a.writeFieldBegin("clientId", d.Type.STRING, 2), a.writeString(this.clientId), a.writeFieldEnd());
    void 0 !== this.connectionId && (a.writeFieldBegin("connectionId", d.Type.STRING, 3), a.writeString(this.connectionId), a.writeFieldEnd());
    void 0 !== this.clientData && (a.writeFieldBegin("clientData", d.Type.STRUCT, 4), this.clientData.write(a), a.writeFieldEnd());
    a.writeFieldStop();
    a.writeStructEnd()
  };
  TPresenceArray = function(a) {
    this.items = void 0;
    a && void 0 !== a.items && (this.items = a.items)
  };
  TPresenceArray.prototype = {};
  TPresenceArray.prototype.read = function(a) {
    for(a.readStructBegin();;) {
      var b = a.readFieldBegin(), c = b.ftype;
      if(c == d.Type.STOP) {
        break
      }
      switch(b.fid) {
        case 1:
          if(c == d.Type.LIST) {
            b = 0;
            this.items = [];
            b = a.readListBegin().size;
            for(c = 0;c < b;++c) {
              var f = void 0, f = new X;
              f.read(a);
              this.items.push(f)
            }
            a.readListEnd()
          }else {
            a.skip(c)
          }
          break;
        case 0:
          a.skip(c);
          break;
        default:
          a.skip(c)
      }
      a.readFieldEnd()
    }
    a.readStructEnd()
  };
  TPresenceArray.prototype.write = function(a) {
    a.writeStructBegin("TPresenceArray");
    if(void 0 !== this.items) {
      a.writeFieldBegin("items", d.Type.LIST, 1);
      a.writeListBegin(d.Type.STRUCT, this.items.length);
      for(var b in this.items) {
        this.items.hasOwnProperty(b) && (b = this.items[b], b.write(a))
      }
      a.writeListEnd();
      a.writeFieldEnd()
    }
    a.writeFieldStop();
    a.writeStructEnd()
  };
  Y = function(a) {
    this.tags = this.data = this.timestamp = this.clientId = this.name = void 0;
    a && (void 0 !== a.name && (this.name = a.name), void 0 !== a.clientId && (this.clientId = a.clientId), void 0 !== a.timestamp && (this.timestamp = a.timestamp), void 0 !== a.data && (this.data = a.data), void 0 !== a.tags && (this.tags = a.tags))
  };
  Y.prototype = {};
  Y.prototype.read = function(a) {
    for(a.readStructBegin();;) {
      var b = a.readFieldBegin(), c = b.ftype;
      if(c == d.Type.STOP) {
        break
      }
      switch(b.fid) {
        case 1:
          c == d.Type.STRING ? this.name = a.readString() : a.skip(c);
          break;
        case 2:
          c == d.Type.STRING ? this.clientId = a.readString() : a.skip(c);
          break;
        case 3:
          c == d.Type.I64 ? this.timestamp = a.readI64() : a.skip(c);
          break;
        case 4:
          c == d.Type.STRUCT ? (this.data = new W, this.data.read(a)) : a.skip(c);
          break;
        case 5:
          if(c == d.Type.LIST) {
            b = 0;
            this.tags = [];
            b = a.readListBegin().size;
            for(c = 0;c < b;++c) {
              var f = void 0, f = a.readString();
              this.tags.push(f)
            }
            a.readListEnd()
          }else {
            a.skip(c)
          }
          break;
        default:
          a.skip(c)
      }
      a.readFieldEnd()
    }
    a.readStructEnd()
  };
  Y.prototype.write = function(a) {
    a.writeStructBegin("TMessage");
    void 0 !== this.name && (a.writeFieldBegin("name", d.Type.STRING, 1), a.writeString(this.name), a.writeFieldEnd());
    void 0 !== this.clientId && (a.writeFieldBegin("clientId", d.Type.STRING, 2), a.writeString(this.clientId), a.writeFieldEnd());
    void 0 !== this.timestamp && (a.writeFieldBegin("timestamp", d.Type.I64, 3), a.writeI64(this.timestamp), a.writeFieldEnd());
    void 0 !== this.data && (a.writeFieldBegin("data", d.Type.STRUCT, 4), this.data.write(a), a.writeFieldEnd());
    if(void 0 !== this.tags) {
      a.writeFieldBegin("tags", d.Type.LIST, 5);
      a.writeListBegin(d.Type.STRING, this.tags.length);
      for(var b in this.tags) {
        this.tags.hasOwnProperty(b) && (b = this.tags[b], a.writeString(b))
      }
      a.writeListEnd();
      a.writeFieldEnd()
    }
    a.writeFieldStop();
    a.writeStructEnd()
  };
  TMessageArray = function(a) {
    this.items = void 0;
    a && void 0 !== a.items && (this.items = a.items)
  };
  TMessageArray.prototype = {};
  TMessageArray.prototype.read = function(a) {
    for(a.readStructBegin();;) {
      var b = a.readFieldBegin(), c = b.ftype;
      if(c == d.Type.STOP) {
        break
      }
      switch(b.fid) {
        case 1:
          if(c == d.Type.LIST) {
            b = 0;
            this.items = [];
            b = a.readListBegin().size;
            for(c = 0;c < b;++c) {
              var f = void 0, f = new Y;
              f.read(a);
              this.items.push(f)
            }
            a.readListEnd()
          }else {
            a.skip(c)
          }
          break;
        case 0:
          a.skip(c);
          break;
        default:
          a.skip(c)
      }
      a.readFieldEnd()
    }
    a.readStructEnd()
  };
  TMessageArray.prototype.write = function(a) {
    a.writeStructBegin("TMessageArray");
    if(void 0 !== this.items) {
      a.writeFieldBegin("items", d.Type.LIST, 1);
      a.writeListBegin(d.Type.STRUCT, this.items.length);
      for(var b in this.items) {
        this.items.hasOwnProperty(b) && (b = this.items[b], b.write(a))
      }
      a.writeListEnd();
      a.writeFieldEnd()
    }
    a.writeFieldStop();
    a.writeStructEnd()
  };
  ga = function(a) {
    this.presence = this.messages = this.timestamp = this.msgSerial = this.channelSerial = this.channel = this.connectionSerial = this.connectionId = this.applicationId = this.error = this.count = this.flags = this.action = void 0;
    a && (void 0 !== a.action && (this.action = a.action), void 0 !== a.flags && (this.flags = a.flags), void 0 !== a.count && (this.count = a.count), void 0 !== a.error && (this.error = a.error), void 0 !== a.applicationId && (this.applicationId = a.applicationId), void 0 !== a.connectionId && (this.connectionId = a.connectionId), void 0 !== a.connectionSerial && (this.connectionSerial = a.connectionSerial), void 0 !== a.channel && (this.channel = a.channel), void 0 !== a.channelSerial && (this.channelSerial = 
    a.channelSerial), void 0 !== a.msgSerial && (this.msgSerial = a.msgSerial), void 0 !== a.timestamp && (this.timestamp = a.timestamp), void 0 !== a.messages && (this.messages = a.messages), void 0 !== a.presence && (this.presence = a.presence))
  };
  ga.prototype = {};
  ga.prototype.read = function(a) {
    for(a.readStructBegin();;) {
      var b = a.readFieldBegin(), c = b.ftype;
      if(c == d.Type.STOP) {
        break
      }
      switch(b.fid) {
        case 1:
          c == d.Type.I32 ? this.action = a.readI32() : a.skip(c);
          break;
        case 2:
          c == d.Type.BYTE ? this.flags = a.readByte() : a.skip(c);
          break;
        case 3:
          c == d.Type.I32 ? this.count = a.readI32() : a.skip(c);
          break;
        case 4:
          c == d.Type.STRUCT ? (this.error = new TError, this.error.read(a)) : a.skip(c);
          break;
        case 5:
          c == d.Type.STRING ? this.applicationId = a.readString() : a.skip(c);
          break;
        case 6:
          c == d.Type.STRING ? this.connectionId = a.readString() : a.skip(c);
          break;
        case 7:
          c == d.Type.I64 ? this.connectionSerial = a.readI64() : a.skip(c);
          break;
        case 8:
          c == d.Type.STRING ? this.channel = a.readString() : a.skip(c);
          break;
        case 9:
          c == d.Type.STRING ? this.channelSerial = a.readString() : a.skip(c);
          break;
        case 10:
          c == d.Type.I64 ? this.msgSerial = a.readI64() : a.skip(c);
          break;
        case 11:
          c == d.Type.I64 ? this.timestamp = a.readI64() : a.skip(c);
          break;
        case 12:
          if(c == d.Type.LIST) {
            b = 0;
            this.messages = [];
            b = a.readListBegin().size;
            for(c = 0;c < b;++c) {
              var f = void 0, f = new Y;
              f.read(a);
              this.messages.push(f)
            }
            a.readListEnd()
          }else {
            a.skip(c)
          }
          break;
        case 13:
          if(c == d.Type.SET) {
            b = 0;
            this.presence = [];
            b = a.readSetBegin().size;
            for(c = 0;c < b;++c) {
              f = void 0, f = new X, f.read(a), this.presence.push(f)
            }
            a.readSetEnd()
          }else {
            a.skip(c)
          }
          break;
        default:
          a.skip(c)
      }
      a.readFieldEnd()
    }
    a.readStructEnd()
  };
  ga.prototype.write = function(a) {
    a.writeStructBegin("TChannelMessage");
    void 0 !== this.action && (a.writeFieldBegin("action", d.Type.I32, 1), a.writeI32(this.action), a.writeFieldEnd());
    void 0 !== this.flags && (a.writeFieldBegin("flags", d.Type.BYTE, 2), a.writeByte(this.flags), a.writeFieldEnd());
    void 0 !== this.count && (a.writeFieldBegin("count", d.Type.I32, 3), a.writeI32(this.count), a.writeFieldEnd());
    void 0 !== this.error && (a.writeFieldBegin("error", d.Type.STRUCT, 4), this.error.write(a), a.writeFieldEnd());
    void 0 !== this.applicationId && (a.writeFieldBegin("applicationId", d.Type.STRING, 5), a.writeString(this.applicationId), a.writeFieldEnd());
    void 0 !== this.connectionId && (a.writeFieldBegin("connectionId", d.Type.STRING, 6), a.writeString(this.connectionId), a.writeFieldEnd());
    void 0 !== this.connectionSerial && (a.writeFieldBegin("connectionSerial", d.Type.I64, 7), a.writeI64(this.connectionSerial), a.writeFieldEnd());
    void 0 !== this.channel && (a.writeFieldBegin("channel", d.Type.STRING, 8), a.writeString(this.channel), a.writeFieldEnd());
    void 0 !== this.channelSerial && (a.writeFieldBegin("channelSerial", d.Type.STRING, 9), a.writeString(this.channelSerial), a.writeFieldEnd());
    void 0 !== this.msgSerial && (a.writeFieldBegin("msgSerial", d.Type.I64, 10), a.writeI64(this.msgSerial), a.writeFieldEnd());
    void 0 !== this.timestamp && (a.writeFieldBegin("timestamp", d.Type.I64, 11), a.writeI64(this.timestamp), a.writeFieldEnd());
    if(void 0 !== this.messages) {
      a.writeFieldBegin("messages", d.Type.LIST, 12);
      a.writeListBegin(d.Type.STRUCT, this.messages.length);
      for(var b in this.messages) {
        this.messages.hasOwnProperty(b) && (b = this.messages[b], b.write(a))
      }
      a.writeListEnd();
      a.writeFieldEnd()
    }
    if(void 0 !== this.presence) {
      a.writeFieldBegin("presence", d.Type.SET, 13);
      a.writeSetBegin(d.Type.STRUCT, this.presence.length);
      for(var c in this.presence) {
        this.presence.hasOwnProperty(c) && (c = this.presence[c], c.write(a))
      }
      a.writeSetEnd();
      a.writeFieldEnd()
    }
    a.writeFieldStop();
    a.writeStructEnd()
  };
  oa = function(a) {
    this.items = void 0;
    a && void 0 !== a.items && (this.items = a.items)
  };
  oa.prototype = {};
  oa.prototype.read = function(a) {
    for(a.readStructBegin();;) {
      var b = a.readFieldBegin(), c = b.ftype;
      if(c == d.Type.STOP) {
        break
      }
      switch(b.fid) {
        case 1:
          if(c == d.Type.LIST) {
            b = 0;
            this.items = [];
            b = a.readListBegin().size;
            for(c = 0;c < b;++c) {
              var f = void 0, f = new ga;
              f.read(a);
              this.items.push(f)
            }
            a.readListEnd()
          }else {
            a.skip(c)
          }
          break;
        case 0:
          a.skip(c);
          break;
        default:
          a.skip(c)
      }
      a.readFieldEnd()
    }
    a.readStructEnd()
  };
  oa.prototype.write = function(a) {
    a.writeStructBegin("TMessageSet");
    if(void 0 !== this.items) {
      a.writeFieldBegin("items", d.Type.LIST, 1);
      a.writeListBegin(d.Type.STRUCT, this.items.length);
      for(var b in this.items) {
        this.items.hasOwnProperty(b) && (b = this.items[b], b.write(a))
      }
      a.writeListEnd();
      a.writeFieldEnd()
    }
    a.writeFieldStop();
    a.writeStructEnd()
  };
  SMessageCount = function(a) {
    this.data = this.count = void 0;
    a && (void 0 !== a.count && (this.count = a.count), void 0 !== a.data && (this.data = a.data))
  };
  SMessageCount.prototype = {};
  SMessageCount.prototype.read = function(a) {
    for(a.readStructBegin();;) {
      var b = a.readFieldBegin(), c = b.ftype;
      if(c == d.Type.STOP) {
        break
      }
      switch(b.fid) {
        case 1:
          c == d.Type.DOUBLE ? this.count = a.readDouble() : a.skip(c);
          break;
        case 2:
          c == d.Type.DOUBLE ? this.data = a.readDouble() : a.skip(c);
          break;
        default:
          a.skip(c)
      }
      a.readFieldEnd()
    }
    a.readStructEnd()
  };
  SMessageCount.prototype.write = function(a) {
    a.writeStructBegin("SMessageCount");
    void 0 !== this.count && (a.writeFieldBegin("count", d.Type.DOUBLE, 1), a.writeDouble(this.count), a.writeFieldEnd());
    void 0 !== this.data && (a.writeFieldBegin("data", d.Type.DOUBLE, 2), a.writeDouble(this.data), a.writeFieldEnd());
    a.writeFieldStop();
    a.writeStructEnd()
  };
  SMessageTypes = function(a) {
    this.presence = this.messages = this.all = void 0;
    a && (void 0 !== a.all && (this.all = a.all), void 0 !== a.messages && (this.messages = a.messages), void 0 !== a.presence && (this.presence = a.presence))
  };
  SMessageTypes.prototype = {};
  SMessageTypes.prototype.read = function(a) {
    for(a.readStructBegin();;) {
      var b = a.readFieldBegin(), c = b.ftype;
      if(c == d.Type.STOP) {
        break
      }
      switch(b.fid) {
        case 1:
          c == d.Type.STRUCT ? (this.all = new SMessageCount, this.all.read(a)) : a.skip(c);
          break;
        case 2:
          c == d.Type.STRUCT ? (this.messages = new SMessageCount, this.messages.read(a)) : a.skip(c);
          break;
        case 3:
          c == d.Type.STRUCT ? (this.presence = new SMessageCount, this.presence.read(a)) : a.skip(c);
          break;
        default:
          a.skip(c)
      }
      a.readFieldEnd()
    }
    a.readStructEnd()
  };
  SMessageTypes.prototype.write = function(a) {
    a.writeStructBegin("SMessageTypes");
    void 0 !== this.all && (a.writeFieldBegin("all", d.Type.STRUCT, 1), this.all.write(a), a.writeFieldEnd());
    void 0 !== this.messages && (a.writeFieldBegin("messages", d.Type.STRUCT, 2), this.messages.write(a), a.writeFieldEnd());
    void 0 !== this.presence && (a.writeFieldBegin("presence", d.Type.STRUCT, 3), this.presence.write(a), a.writeFieldEnd());
    a.writeFieldStop();
    a.writeStructEnd()
  };
  SResourceCount = function(a) {
    this.sample_sum = this.sample_count = this.refused = this.min = this.mean = this.peak = this.opened = void 0;
    a && (void 0 !== a.opened && (this.opened = a.opened), void 0 !== a.peak && (this.peak = a.peak), void 0 !== a.mean && (this.mean = a.mean), void 0 !== a.min && (this.min = a.min), void 0 !== a.refused && (this.refused = a.refused), void 0 !== a.sample_count && (this.sample_count = a.sample_count), void 0 !== a.sample_sum && (this.sample_sum = a.sample_sum))
  };
  SResourceCount.prototype = {};
  SResourceCount.prototype.read = function(a) {
    for(a.readStructBegin();;) {
      var b = a.readFieldBegin(), c = b.ftype;
      if(c == d.Type.STOP) {
        break
      }
      switch(b.fid) {
        case 1:
          c == d.Type.DOUBLE ? this.opened = a.readDouble() : a.skip(c);
          break;
        case 2:
          c == d.Type.DOUBLE ? this.peak = a.readDouble() : a.skip(c);
          break;
        case 3:
          c == d.Type.DOUBLE ? this.mean = a.readDouble() : a.skip(c);
          break;
        case 4:
          c == d.Type.DOUBLE ? this.min = a.readDouble() : a.skip(c);
          break;
        case 5:
          c == d.Type.DOUBLE ? this.refused = a.readDouble() : a.skip(c);
          break;
        case 10:
          c == d.Type.DOUBLE ? this.sample_count = a.readDouble() : a.skip(c);
          break;
        case 11:
          c == d.Type.DOUBLE ? this.sample_sum = a.readDouble() : a.skip(c);
          break;
        default:
          a.skip(c)
      }
      a.readFieldEnd()
    }
    a.readStructEnd()
  };
  SResourceCount.prototype.write = function(a) {
    a.writeStructBegin("SResourceCount");
    void 0 !== this.opened && (a.writeFieldBegin("opened", d.Type.DOUBLE, 1), a.writeDouble(this.opened), a.writeFieldEnd());
    void 0 !== this.peak && (a.writeFieldBegin("peak", d.Type.DOUBLE, 2), a.writeDouble(this.peak), a.writeFieldEnd());
    void 0 !== this.mean && (a.writeFieldBegin("mean", d.Type.DOUBLE, 3), a.writeDouble(this.mean), a.writeFieldEnd());
    void 0 !== this.min && (a.writeFieldBegin("min", d.Type.DOUBLE, 4), a.writeDouble(this.min), a.writeFieldEnd());
    void 0 !== this.refused && (a.writeFieldBegin("refused", d.Type.DOUBLE, 5), a.writeDouble(this.refused), a.writeFieldEnd());
    void 0 !== this.sample_count && (a.writeFieldBegin("sample_count", d.Type.DOUBLE, 10), a.writeDouble(this.sample_count), a.writeFieldEnd());
    void 0 !== this.sample_sum && (a.writeFieldBegin("sample_sum", d.Type.DOUBLE, 11), a.writeDouble(this.sample_sum), a.writeFieldEnd());
    a.writeFieldStop();
    a.writeStructEnd()
  };
  SConnectionTypes = function(a) {
    this.tls = this.plain = this.all = void 0;
    a && (void 0 !== a.all && (this.all = a.all), void 0 !== a.plain && (this.plain = a.plain), void 0 !== a.tls && (this.tls = a.tls))
  };
  SConnectionTypes.prototype = {};
  SConnectionTypes.prototype.read = function(a) {
    for(a.readStructBegin();;) {
      var b = a.readFieldBegin(), c = b.ftype;
      if(c == d.Type.STOP) {
        break
      }
      switch(b.fid) {
        case 1:
          c == d.Type.STRUCT ? (this.all = new SResourceCount, this.all.read(a)) : a.skip(c);
          break;
        case 2:
          c == d.Type.STRUCT ? (this.plain = new SResourceCount, this.plain.read(a)) : a.skip(c);
          break;
        case 3:
          c == d.Type.STRUCT ? (this.tls = new SResourceCount, this.tls.read(a)) : a.skip(c);
          break;
        default:
          a.skip(c)
      }
      a.readFieldEnd()
    }
    a.readStructEnd()
  };
  SConnectionTypes.prototype.write = function(a) {
    a.writeStructBegin("SConnectionTypes");
    void 0 !== this.all && (a.writeFieldBegin("all", d.Type.STRUCT, 1), this.all.write(a), a.writeFieldEnd());
    void 0 !== this.plain && (a.writeFieldBegin("plain", d.Type.STRUCT, 2), this.plain.write(a), a.writeFieldEnd());
    void 0 !== this.tls && (a.writeFieldBegin("tls", d.Type.STRUCT, 3), this.tls.write(a), a.writeFieldEnd());
    a.writeFieldStop();
    a.writeStructEnd()
  };
  SMessageTraffic = function(a) {
    this.httpStream = this.post = this.rest = this.realtime = this.all = void 0;
    a && (void 0 !== a.all && (this.all = a.all), void 0 !== a.realtime && (this.realtime = a.realtime), void 0 !== a.rest && (this.rest = a.rest), void 0 !== a.post && (this.post = a.post), void 0 !== a.httpStream && (this.httpStream = a.httpStream))
  };
  SMessageTraffic.prototype = {};
  SMessageTraffic.prototype.read = function(a) {
    for(a.readStructBegin();;) {
      var b = a.readFieldBegin(), c = b.ftype;
      if(c == d.Type.STOP) {
        break
      }
      switch(b.fid) {
        case 1:
          c == d.Type.STRUCT ? (this.all = new SMessageTypes, this.all.read(a)) : a.skip(c);
          break;
        case 2:
          c == d.Type.STRUCT ? (this.realtime = new SMessageTypes, this.realtime.read(a)) : a.skip(c);
          break;
        case 3:
          c == d.Type.STRUCT ? (this.rest = new SMessageTypes, this.rest.read(a)) : a.skip(c);
          break;
        case 4:
          c == d.Type.STRUCT ? (this.post = new SMessageTypes, this.post.read(a)) : a.skip(c);
          break;
        case 5:
          c == d.Type.STRUCT ? (this.httpStream = new SMessageTypes, this.httpStream.read(a)) : a.skip(c);
          break;
        default:
          a.skip(c)
      }
      a.readFieldEnd()
    }
    a.readStructEnd()
  };
  SMessageTraffic.prototype.write = function(a) {
    a.writeStructBegin("SMessageTraffic");
    void 0 !== this.all && (a.writeFieldBegin("all", d.Type.STRUCT, 1), this.all.write(a), a.writeFieldEnd());
    void 0 !== this.realtime && (a.writeFieldBegin("realtime", d.Type.STRUCT, 2), this.realtime.write(a), a.writeFieldEnd());
    void 0 !== this.rest && (a.writeFieldBegin("rest", d.Type.STRUCT, 3), this.rest.write(a), a.writeFieldEnd());
    void 0 !== this.post && (a.writeFieldBegin("post", d.Type.STRUCT, 4), this.post.write(a), a.writeFieldEnd());
    void 0 !== this.httpStream && (a.writeFieldBegin("httpStream", d.Type.STRUCT, 5), this.httpStream.write(a), a.writeFieldEnd());
    a.writeFieldStop();
    a.writeStructEnd()
  };
  SRequestCount = function(a) {
    this.refused = this.failed = this.succeeded = void 0;
    a && (void 0 !== a.succeeded && (this.succeeded = a.succeeded), void 0 !== a.failed && (this.failed = a.failed), void 0 !== a.refused && (this.refused = a.refused))
  };
  SRequestCount.prototype = {};
  SRequestCount.prototype.read = function(a) {
    for(a.readStructBegin();;) {
      var b = a.readFieldBegin(), c = b.ftype;
      if(c == d.Type.STOP) {
        break
      }
      switch(b.fid) {
        case 1:
          c == d.Type.DOUBLE ? this.succeeded = a.readDouble() : a.skip(c);
          break;
        case 2:
          c == d.Type.DOUBLE ? this.failed = a.readDouble() : a.skip(c);
          break;
        case 3:
          c == d.Type.DOUBLE ? this.refused = a.readDouble() : a.skip(c);
          break;
        default:
          a.skip(c)
      }
      a.readFieldEnd()
    }
    a.readStructEnd()
  };
  SRequestCount.prototype.write = function(a) {
    a.writeStructBegin("SRequestCount");
    void 0 !== this.succeeded && (a.writeFieldBegin("succeeded", d.Type.DOUBLE, 1), a.writeDouble(this.succeeded), a.writeFieldEnd());
    void 0 !== this.failed && (a.writeFieldBegin("failed", d.Type.DOUBLE, 2), a.writeDouble(this.failed), a.writeFieldEnd());
    void 0 !== this.refused && (a.writeFieldBegin("refused", d.Type.DOUBLE, 3), a.writeDouble(this.refused), a.writeFieldEnd());
    a.writeFieldStop();
    a.writeStructEnd()
  };
  SStats = function(a) {
    this.tokenRequests = this.apiRequests = this.channels = this.connections = this.persisted = this.outbound = this.inbound = this.all = void 0;
    a && (void 0 !== a.all && (this.all = a.all), void 0 !== a.inbound && (this.inbound = a.inbound), void 0 !== a.outbound && (this.outbound = a.outbound), void 0 !== a.persisted && (this.persisted = a.persisted), void 0 !== a.connections && (this.connections = a.connections), void 0 !== a.channels && (this.channels = a.channels), void 0 !== a.apiRequests && (this.apiRequests = a.apiRequests), void 0 !== a.tokenRequests && (this.tokenRequests = a.tokenRequests))
  };
  SStats.prototype = {};
  SStats.prototype.read = function(a) {
    for(a.readStructBegin();;) {
      var b = a.readFieldBegin(), c = b.ftype;
      if(c == d.Type.STOP) {
        break
      }
      switch(b.fid) {
        case 1:
          c == d.Type.STRUCT ? (this.all = new SMessageTypes, this.all.read(a)) : a.skip(c);
          break;
        case 2:
          c == d.Type.STRUCT ? (this.inbound = new SMessageTraffic, this.inbound.read(a)) : a.skip(c);
          break;
        case 3:
          c == d.Type.STRUCT ? (this.outbound = new SMessageTraffic, this.outbound.read(a)) : a.skip(c);
          break;
        case 4:
          c == d.Type.STRUCT ? (this.persisted = new SMessageTypes, this.persisted.read(a)) : a.skip(c);
          break;
        case 5:
          c == d.Type.STRUCT ? (this.connections = new SConnectionTypes, this.connections.read(a)) : a.skip(c);
          break;
        case 6:
          c == d.Type.STRUCT ? (this.channels = new SResourceCount, this.channels.read(a)) : a.skip(c);
          break;
        case 7:
          c == d.Type.STRUCT ? (this.apiRequests = new SRequestCount, this.apiRequests.read(a)) : a.skip(c);
          break;
        case 8:
          c == d.Type.STRUCT ? (this.tokenRequests = new SRequestCount, this.tokenRequests.read(a)) : a.skip(c);
          break;
        default:
          a.skip(c)
      }
      a.readFieldEnd()
    }
    a.readStructEnd()
  };
  SStats.prototype.write = function(a) {
    a.writeStructBegin("SStats");
    void 0 !== this.all && (a.writeFieldBegin("all", d.Type.STRUCT, 1), this.all.write(a), a.writeFieldEnd());
    void 0 !== this.inbound && (a.writeFieldBegin("inbound", d.Type.STRUCT, 2), this.inbound.write(a), a.writeFieldEnd());
    void 0 !== this.outbound && (a.writeFieldBegin("outbound", d.Type.STRUCT, 3), this.outbound.write(a), a.writeFieldEnd());
    void 0 !== this.persisted && (a.writeFieldBegin("persisted", d.Type.STRUCT, 4), this.persisted.write(a), a.writeFieldEnd());
    void 0 !== this.connections && (a.writeFieldBegin("connections", d.Type.STRUCT, 5), this.connections.write(a), a.writeFieldEnd());
    void 0 !== this.channels && (a.writeFieldBegin("channels", d.Type.STRUCT, 6), this.channels.write(a), a.writeFieldEnd());
    void 0 !== this.apiRequests && (a.writeFieldBegin("apiRequests", d.Type.STRUCT, 7), this.apiRequests.write(a), a.writeFieldEnd());
    void 0 !== this.tokenRequests && (a.writeFieldBegin("tokenRequests", d.Type.STRUCT, 8), this.tokenRequests.write(a), a.writeFieldEnd());
    a.writeFieldStop();
    a.writeStructEnd()
  };
  SStatsArray = function(a) {
    this.items = void 0;
    a && void 0 !== a.items && (this.items = a.items)
  };
  SStatsArray.prototype = {};
  SStatsArray.prototype.read = function(a) {
    for(a.readStructBegin();;) {
      var b = a.readFieldBegin(), c = b.ftype;
      if(c == d.Type.STOP) {
        break
      }
      switch(b.fid) {
        case 1:
          if(c == d.Type.LIST) {
            b = 0;
            this.items = [];
            b = a.readListBegin().size;
            for(c = 0;c < b;++c) {
              var f = void 0, f = new SStats;
              f.read(a);
              this.items.push(f)
            }
            a.readListEnd()
          }else {
            a.skip(c)
          }
          break;
        case 0:
          a.skip(c);
          break;
        default:
          a.skip(c)
      }
      a.readFieldEnd()
    }
    a.readStructEnd()
  };
  SStatsArray.prototype.write = function(a) {
    a.writeStructBegin("SStatsArray");
    if(void 0 !== this.items) {
      a.writeFieldBegin("items", d.Type.LIST, 1);
      a.writeListBegin(d.Type.STRUCT, this.items.length);
      for(var b in this.items) {
        this.items.hasOwnProperty(b) && (b = this.items[b], b.write(a))
      }
      a.writeListEnd();
      a.writeFieldEnd()
    }
    a.writeFieldStop();
    a.writeStructEnd()
  };
  var E = {TAction:TAction, TFlags:TFlags, TType:TType, TData:W, TPresence:X, TMessage:Y, TChannelMessage:ga, TMessageSet:oa}, wa = function() {
  };
  "object" == typeof window && (wa.create = function(a, b, c) {
    var f = "";
    c && (f = new Date, f.setTime(f.getTime() + c), f = "; expires=" + f.toGMTString());
    document.cookie = a + "=" + b + f + "; path=/"
  }, wa.read = function(a) {
    for(var a = a + "=", b = document.cookie.split(";"), c = 0;c < b.length;c++) {
      for(var f = b[c];" " == f.charAt(0);) {
        f = f.substring(1, f.length)
      }
      if(0 == f.indexOf(a)) {
        return f.substring(a.length, f.length)
      }
    }
    return null
  }, wa.erase = function(a) {
    createCookie(a, "", -36E5)
  });
  this.Cookie = wa;
  var v = {protocolVersion:1, REST_HOST:"rest.ably.io", WS_HOST:"realtime.ably.io", FALLBACK_HOSTS:["A.ably-realtime.com", "B.ably-realtime.com", "C.ably-realtime.com", "D.ably-realtime.com", "E.ably-realtime.com"], PORT:80, TLS_PORT:443, connectTimeout:15E3, disconnectTimeout:3E4, suspendedTimeout:12E4, cometRecvTimeout:9E4, cometSendTimeout:1E4, httpTransports:["xhr", "jsonp"], transports:["web_socket", "flash_socket", "xhr", "jsonp"], flashTransport:{swfLocation:window.location.protocol + "//cdn.ably.io/lib/swf/WebSocketMainInsecure-0.9.swf"}}, 
  pa = function() {
  }, kb = function() {
  };
  pa.get = function(a, b, c, f, d) {
    function e(a) {
      pa.Request(a, f, null, !1, r, d)
    }
    var d = d || kb, k = "function" == typeof b ? b : function(c) {
      return a.baseUri(c) + b
    }, r = c && "application/json" != c.accept;
    if("string" == typeof k) {
      e(k, d)
    }else {
      var p, c = a.connection, F = a.options, g = F.restHost;
      "connected" == c.state ? p = c.connectionManager.host : F.fallbackHosts || (p = g);
      if(p) {
        e(k(p), d)
      }else {
        var h = fallbackHosts.slice().unshift(g);
        e(h.shift(), function(a, b, c) {
          if(a) {
            var f = a.code;
            if("ENETUNREACH" == f || "EHOSTUNREACH" == f || "EHOSTDOWN" == f) {
              e(h, d);
              return
            }
          }
          d.apply(null, arguments)
        })
      }
    }
  };
  pa.post = function(a, b, c, f, d, e) {
    function k(a) {
      pa.Request(a, d, f, !1, p, e)
    }
    var e = e || kb, r = "function" == typeof b ? b : function(c) {
      return a.baseUri(c) + b
    }, p = c && "application/json" != c.accept;
    if("string" == typeof r) {
      tryGet(r, e)
    }else {
      var F, c = a.connection, g = a.options, h = g.restHost;
      "connected" == c.state ? F = c.connectionManager.host : g.fallbackHosts || (F = h);
      if(F) {
        k(r(F), e)
      }else {
        var i = fallbackHosts.slice().unshift(h);
        k(i.shift(), function(a, b, c) {
          if(a) {
            var f = a.code;
            if("ENETUNREACH" == f || "EHOSTUNREACH" == f || "EHOSTDOWN" == f) {
              k(i, e);
              return
            }
          }
          e.apply(null, arguments)
        })
      }
    }
  };
  this.Http = pa;
  var Ob = new d.TTransport;
  new d.TBinaryProtocol(Ob);
  this.ThriftUtil = void 0;
  var Z, ha = function() {
    if(!$) {
      try {
        var a = l.getElementsByTagName("body")[0].appendChild(l.createElement("span"));
        a.parentNode.removeChild(a)
      }catch(b) {
        return
      }
      $ = !0;
      for(var a = xa.length, c = 0;c < a;c++) {
        xa[c]()
      }
    }
  }, lb = function(a) {
    $ ? a() : xa[xa.length] = a
  }, mb = function(a) {
    if(typeof K.addEventListener != t) {
      K.addEventListener("load", a, !1)
    }else {
      if(typeof l.addEventListener != t) {
        l.addEventListener("load", a, !1)
      }else {
        if(typeof K.attachEvent != t) {
          var b = K;
          b.attachEvent("onload", a);
          ia[ia.length] = [b, "onload", a]
        }else {
          if("function" == typeof K.onload) {
            var c = K.onload;
            K.onload = function() {
              c();
              a()
            }
          }else {
            K.onload = a
          }
        }
      }
    }
  }, Ta = function() {
    var a = R.length;
    if(0 < a) {
      for(var b = 0;b < a;b++) {
        var c = R[b].id, f = R[b].callbackFn, d = {success:!1, id:c};
        if(0 < g.pv[0]) {
          var e = M(c);
          if(e) {
            if(ya(R[b].swfVersion) && !(g.wk && 312 > g.wk)) {
              aa(c, !0), f && (d.success = !0, d.ref = Qa(c), f(d))
            }else {
              if(R[b].expressInstall && Ra()) {
                d = {};
                d.data = R[b].expressInstall;
                d.width = e.getAttribute("width") || "0";
                d.height = e.getAttribute("height") || "0";
                e.getAttribute("class") && (d.styleclass = e.getAttribute("class"));
                e.getAttribute("align") && (d.align = e.getAttribute("align"));
                for(var k = {}, e = e.getElementsByTagName("param"), r = e.length, p = 0;p < r;p++) {
                  "movie" != e[p].getAttribute("name").toLowerCase() && (k[e[p].getAttribute("name")] = e[p].getAttribute("value"))
                }
                Sa(d, k, c, f)
              }else {
                Pb(e), f && f(d)
              }
            }
          }
        }else {
          if(aa(c, !0), f) {
            if((c = Qa(c)) && typeof c.SetVariable != t) {
              d.success = !0, d.ref = c
            }
            f(d)
          }
        }
      }
    }
  }, Qa = function(a) {
    var b = null;
    if((a = M(a)) && "OBJECT" == a.nodeName) {
      typeof a.SetVariable != t ? b = a : (a = a.getElementsByTagName(P)[0]) && (b = a)
    }
    return b
  }, Ra = function() {
    return!za && ya("6.0.65") && (g.win || g.mac) && !(g.wk && 312 > g.wk)
  }, Sa = function(a, b, c, f) {
    za = !0;
    Ua = f || null;
    nb = {success:!1, id:c};
    var d = M(c);
    if(d) {
      "OBJECT" == d.nodeName ? (qa = Va(d), Aa = null) : (qa = d, Aa = c);
      a.id = ob;
      if(typeof a.width == t || !/%$/.test(a.width) && 310 > parseInt(a.width, 10)) {
        a.width = "310"
      }
      if(typeof a.height == t || !/%$/.test(a.height) && 137 > parseInt(a.height, 10)) {
        a.height = "137"
      }
      l.title = l.title.slice(0, 47) + " - Flash Player Installation";
      f = g.ie && g.win ? "ActiveX" : "PlugIn";
      f = "MMredirectURL=" + K.location.toString().replace(/&/g, "%26") + "&MMplayerType=" + f + "&MMdoctitle=" + l.title;
      b.flashvars = typeof b.flashvars != t ? b.flashvars + ("&" + f) : f;
      g.ie && (g.win && 4 != d.readyState) && (f = l.createElement("div"), c += "SWFObjectNew", f.setAttribute("id", c), d.parentNode.insertBefore(f, d), d.style.display = "none", function() {
        4 == d.readyState ? d.parentNode.removeChild(d) : setTimeout(arguments.callee, 10)
      }());
      Wa(a, b, c)
    }
  }, Pb = function(a) {
    if(g.ie && g.win && 4 != a.readyState) {
      var b = l.createElement("div");
      a.parentNode.insertBefore(b, a);
      b.parentNode.replaceChild(Va(a), b);
      a.style.display = "none";
      (function() {
        4 == a.readyState ? a.parentNode.removeChild(a) : setTimeout(arguments.callee, 10)
      })()
    }else {
      a.parentNode.replaceChild(Va(a), a)
    }
  }, Va = function(a) {
    var b = l.createElement("div");
    if(g.win && g.ie) {
      b.innerHTML = a.innerHTML
    }else {
      if(a = a.getElementsByTagName(P)[0]) {
        if(a = a.childNodes) {
          for(var c = a.length, f = 0;f < c;f++) {
            !(1 == a[f].nodeType && "PARAM" == a[f].nodeName) && 8 != a[f].nodeType && b.appendChild(a[f].cloneNode(!0))
          }
        }
      }
    }
    return b
  }, Wa = function(a, b, c) {
    var f, d = M(c);
    if(g.wk && 312 > g.wk) {
      return f
    }
    if(d) {
      if(typeof a.id == t && (a.id = c), g.ie && g.win) {
        var e = "", k;
        for(k in a) {
          a[k] != Object.prototype[k] && ("data" == k.toLowerCase() ? b.movie = a[k] : "styleclass" == k.toLowerCase() ? e += ' class="' + a[k] + '"' : "classid" != k.toLowerCase() && (e += " " + k + '="' + a[k] + '"'))
        }
        k = "";
        for(var r in b) {
          b[r] != Object.prototype[r] && (k += '<param name="' + r + '" value="' + b[r] + '" />')
        }
        d.outerHTML = '<object classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"' + e + ">" + k + "</object>";
        Ba[Ba.length] = a.id;
        f = M(a.id)
      }else {
        r = l.createElement(P);
        r.setAttribute("type", Ca);
        for(var p in a) {
          a[p] != Object.prototype[p] && ("styleclass" == p.toLowerCase() ? r.setAttribute("class", a[p]) : "classid" != p.toLowerCase() && r.setAttribute(p, a[p]))
        }
        for(e in b) {
          b[e] != Object.prototype[e] && "movie" != e.toLowerCase() && (a = r, k = e, p = b[e], c = l.createElement("param"), c.setAttribute("name", k), c.setAttribute("value", p), a.appendChild(c))
        }
        d.parentNode.replaceChild(r, d);
        f = r
      }
    }
    return f
  }, pb = function(a) {
    var b = M(a);
    b && "OBJECT" == b.nodeName && (g.ie && g.win ? (b.style.display = "none", function() {
      if(4 == b.readyState) {
        var c = M(a);
        if(c) {
          for(var f in c) {
            "function" == typeof c[f] && (c[f] = null)
          }
          c.parentNode.removeChild(c)
        }
      }else {
        setTimeout(arguments.callee, 10)
      }
    }()) : b.parentNode.removeChild(b))
  }, M = function(a) {
    var b = null;
    try {
      b = l.getElementById(a)
    }catch(c) {
    }
    return b
  }, ya = function(a) {
    var b = g.pv, a = a.split(".");
    a[0] = parseInt(a[0], 10);
    a[1] = parseInt(a[1], 10) || 0;
    a[2] = parseInt(a[2], 10) || 0;
    return b[0] > a[0] || b[0] == a[0] && b[1] > a[1] || b[0] == a[0] && b[1] == a[1] && b[2] >= a[2] ? !0 : !1
  }, qb = function(a, b, c, f) {
    if(!g.ie || !g.mac) {
      var d = l.getElementsByTagName("head")[0];
      if(d) {
        c = c && "string" == typeof c ? c : "screen";
        f && (Xa = Q = null);
        if(!Q || Xa != c) {
          f = l.createElement("style"), f.setAttribute("type", "text/css"), f.setAttribute("media", c), Q = d.appendChild(f), g.ie && (g.win && typeof l.styleSheets != t && 0 < l.styleSheets.length) && (Q = l.styleSheets[l.styleSheets.length - 1]), Xa = c
        }
        g.ie && g.win ? Q && typeof Q.addRule == P && Q.addRule(a, b) : Q && typeof l.createTextNode != t && Q.appendChild(l.createTextNode(a + " {" + b + "}"))
      }
    }
  }, aa = function(a, b) {
    if(rb) {
      var c = b ? "visible" : "hidden";
      $ && M(a) ? M(a).style.visibility = c : qb("#" + a, "visibility:" + c)
    }
  }, sb = function(a) {
    return null != /[\\\"<>\.;]/.exec(a) && typeof encodeURIComponent != t ? encodeURIComponent(a) : a
  }, t = "undefined", P = "object", Ca = "application/x-shockwave-flash", ob = "SWFObjectExprInst", K = window, l = document, S = navigator, tb = !1, xa = [function() {
    if(tb) {
      var a = l.getElementsByTagName("body")[0], b = l.createElement(P);
      b.setAttribute("type", Ca);
      var c = a.appendChild(b);
      if(c) {
        var f = 0;
        (function() {
          if(typeof c.GetVariable != t) {
            var d = c.GetVariable("$version");
            d && (d = d.split(" ")[1].split(","), g.pv = [parseInt(d[0], 10), parseInt(d[1], 10), parseInt(d[2], 10)])
          }else {
            if(10 > f) {
              f++;
              setTimeout(arguments.callee, 10);
              return
            }
          }
          a.removeChild(b);
          c = null;
          Ta()
        })()
      }else {
        Ta()
      }
    }else {
      Ta()
    }
  }], R = [], Ba = [], ia = [], qa, Aa, Ua, nb, $ = !1, za = !1, Q, Xa, rb = !0, g, Qb = typeof l.getElementById != t && typeof l.getElementsByTagName != t && typeof l.createElement != t, Da = S.userAgent.toLowerCase(), Ea = S.platform.toLowerCase(), Rb = Ea ? /win/.test(Ea) : /win/.test(Da), Sb = Ea ? /mac/.test(Ea) : /mac/.test(Da), Tb = /webkit/.test(Da) ? parseFloat(Da.replace(/^.*webkit\/(\d+(\.\d+)?).*$/, "$1")) : !1, Ya = !+"\v1", ra = [0, 0, 0], G = null;
  if(typeof S.plugins != t && typeof S.plugins["Shockwave Flash"] == P) {
    if((G = S.plugins["Shockwave Flash"].description) && !(typeof S.mimeTypes != t && S.mimeTypes[Ca] && !S.mimeTypes[Ca].enabledPlugin)) {
      tb = !0, Ya = !1, G = G.replace(/^.*\s+(\S+\s+\S+$)/, "$1"), ra[0] = parseInt(G.replace(/^(.*)\..*$/, "$1"), 10), ra[1] = parseInt(G.replace(/^.*\.(.*)\s.*$/, "$1"), 10), ra[2] = /[a-zA-Z]/.test(G) ? parseInt(G.replace(/^.*[a-zA-Z]+(.*)$/, "$1"), 10) : 0
    }
  }else {
    if(typeof K.ActiveXObject != t) {
      try {
        var ub = new ActiveXObject("ShockwaveFlash.ShockwaveFlash");
        if(ub && (G = ub.GetVariable("$version"))) {
          Ya = !0, G = G.split(" ")[1].split(","), ra = [parseInt(G[0], 10), parseInt(G[1], 10), parseInt(G[2], 10)]
        }
      }catch(hc) {
      }
    }
  }
  g = {w3:Qb, pv:ra, wk:Tb, ie:Ya, win:Rb, mac:Sb};
  g.w3 && ((typeof l.readyState != t && "complete" == l.readyState || typeof l.readyState == t && (l.getElementsByTagName("body")[0] || l.body)) && ha(), $ || (typeof l.addEventListener != t && l.addEventListener("DOMContentLoaded", ha, !1), g.ie && g.win && (l.attachEvent("onreadystatechange", function() {
    "complete" == l.readyState && (l.detachEvent("onreadystatechange", arguments.callee), ha())
  }), K == top && function() {
    if(!$) {
      try {
        l.documentElement.doScroll("left")
      }catch(a) {
        setTimeout(arguments.callee, 0);
        return
      }
      ha()
    }
  }()), g.wk && function() {
    $ || (/loaded|complete/.test(l.readyState) ? ha() : setTimeout(arguments.callee, 0))
  }(), mb(ha)));
  g.ie && g.win && window.attachEvent("onunload", function() {
    for(var a = ia.length, b = 0;b < a;b++) {
      ia[b][0].detachEvent(ia[b][1], ia[b][2])
    }
    a = Ba.length;
    for(b = 0;b < a;b++) {
      pb(Ba[b])
    }
    for(var c in g) {
      g[c] = null
    }
    g = null;
    for(var f in Z) {
      Z[f] = null
    }
    Z = null
  });
  Z = {registerObject:function(a, b, c, f) {
    if(g.w3 && a && b) {
      var d = {};
      d.id = a;
      d.swfVersion = b;
      d.expressInstall = c;
      d.callbackFn = f;
      R[R.length] = d;
      aa(a, !1)
    }else {
      f && f({success:!1, id:a})
    }
  }, getObjectById:function(a) {
    if(g.w3) {
      return Qa(a)
    }
  }, embedSWF:function(a, b, c, f, d, e, k, r, p, F) {
    var h = {success:!1, id:b};
    g.w3 && !(g.wk && 312 > g.wk) && a && b && c && f && d ? (aa(b, !1), lb(function() {
      c += "";
      f += "";
      var g = {};
      if(p && typeof p === P) {
        for(var i in p) {
          g[i] = p[i]
        }
      }
      g.data = a;
      g.width = c;
      g.height = f;
      i = {};
      if(r && typeof r === P) {
        for(var m in r) {
          i[m] = r[m]
        }
      }
      if(k && typeof k === P) {
        for(var l in k) {
          i.flashvars = typeof i.flashvars != t ? i.flashvars + ("&" + l + "=" + k[l]) : l + "=" + k[l]
        }
      }
      if(ya(d)) {
        m = Wa(g, i, b), g.id == b && aa(b, !0), h.success = !0, h.ref = m
      }else {
        if(e && Ra()) {
          g.data = e;
          Sa(g, i, b, F);
          return
        }
        aa(b, !0)
      }
      F && F(h)
    })) : F && F(h)
  }, switchOffAutoHideShow:function() {
    rb = !1
  }, ua:g, getFlashPlayerVersion:function() {
    return{major:g.pv[0], minor:g.pv[1], release:g.pv[2]}
  }, hasFlashPlayerVersion:ya, createSWF:function(a, b, c) {
    if(g.w3) {
      return Wa(a, b, c)
    }
  }, showExpressInstall:function(a, b, c, f) {
    g.w3 && Ra() && Sa(a, b, c, f)
  }, removeSWF:function(a) {
    g.w3 && pb(a)
  }, createCSS:function(a, b, c, f) {
    g.w3 && qb(a, b, c, f)
  }, addDomLoadEvent:lb, addLoadEvent:mb, getQueryParamValue:function(a) {
    var b = l.location.search || l.location.hash;
    if(b) {
      /\?/.test(b) && (b = b.split("?")[1]);
      if(null == a) {
        return sb(b)
      }
      for(var b = b.split("&"), c = 0;c < b.length;c++) {
        if(b[c].substring(0, b[c].indexOf("=")) == a) {
          return sb(b[c].substring(b[c].indexOf("=") + 1))
        }
      }
    }
    return""
  }, expressInstallCallback:function() {
    if(za) {
      var a = M(ob);
      a && qa && (a.parentNode.replaceChild(qa, a), Aa && (aa(Aa, !0), g.ie && g.win && (qa.style.display = "block")), Ua && Ua(nb));
      za = !1
    }
  }};
  var Fa;
  window.WebSocket = window.WebSocket || {};
  logger = window.console && window.console.log && window.console.error ? window.console : {log:function() {
  }, error:function() {
  }};
  var h = function(a, b, c, f, d) {
    var e = this;
    e.__id = h.__nextId++;
    h.__instances[e.__id] = e;
    e.readyState = h.CONNECTING;
    e.bufferedAmount = 0;
    e.__events = {};
    b ? "string" == typeof b && (b = [b]) : b = [];
    e.__createTask = setTimeout(function() {
      h.__addTask(function() {
        e.__createTask = null;
        h.__flash.create(e.__id, a, b, c || null, f || 0, d || null)
      })
    }, 0)
  };
  h.prototype.send = function(a) {
    if(this.readyState == h.CONNECTING) {
      throw"INVALID_STATE_ERR: Web Socket connection has not been established";
    }
    a = h.__flash.send(this.__id, encodeURIComponent(a));
    if(0 > a) {
      return!0
    }
    this.bufferedAmount += a;
    return!1
  };
  h.prototype.close = function() {
    this.__createTask ? (clearTimeout(this.__createTask), this.__createTask = null, this.readyState = h.CLOSED) : this.readyState == h.CLOSED || this.readyState == h.CLOSING || (this.readyState = h.CLOSING, h.__flash.close(this.__id))
  };
  h.prototype.addEventListener = function(a, b) {
    a in this.__events || (this.__events[a] = []);
    this.__events[a].push(b)
  };
  h.prototype.removeEventListener = function(a, b) {
    if(a in this.__events) {
      for(var c = this.__events[a], f = c.length - 1;0 <= f;--f) {
        if(c[f] === b) {
          c.splice(f, 1);
          break
        }
      }
    }
  };
  h.prototype.dispatchEvent = function(a) {
    for(var b = this.__events[a.type] || [], c = 0;c < b.length;++c) {
      b[c](a)
    }
    (b = this["on" + a.type]) && b.apply(this, [a])
  };
  h.prototype.__handleEvent = function(a) {
    "readyState" in a && (this.readyState = a.readyState);
    "protocol" in a && (this.protocol = a.protocol);
    var b;
    if("open" == a.type || "error" == a.type) {
      b = this.__createSimpleEvent(a.type)
    }else {
      if("close" == a.type) {
        b = this.__createSimpleEvent("close"), b.wasClean = a.wasClean ? !0 : !1, b.code = a.code, b.reason = a.reason
      }else {
        if("message" == a.type) {
          a = decodeURIComponent(a.message), b = this.__createMessageEvent("message", a)
        }else {
          throw"unknown event type: " + a.type;
        }
      }
    }
    this.dispatchEvent(b)
  };
  h.prototype.__createSimpleEvent = function(a) {
    if(document.createEvent && window.Event) {
      var b = document.createEvent("Event");
      b.initEvent(a, !1, !1);
      return b
    }
    return{type:a, bubbles:!1, cancelable:!1}
  };
  h.prototype.__createMessageEvent = function(a, b) {
    if(document.createEvent && window.MessageEvent && !window.opera) {
      var c = document.createEvent("MessageEvent");
      c.initMessageEvent("message", !1, !1, b, null, null, window, null);
      return c
    }
    return{type:a, data:b, bubbles:!1, cancelable:!1}
  };
  h.CONNECTING = 0;
  h.OPEN = 1;
  h.CLOSING = 2;
  h.CLOSED = 3;
  h.__isFlashImplementation = !0;
  h.__initialized = !1;
  h.__flash = null;
  h.__instances = {};
  h.__tasks = [];
  h.__nextId = 0;
  h.loadFlashPolicyFile = function(a) {
    h.__addTask(function() {
      h.__flash.loadManualPolicyFile(a)
    })
  };
  h.__initialize = function(a) {
    if(!h.__initialized) {
      h.__initialized = !0;
      var b = document.createElement("div");
      b.id = "webSocketContainer";
      b.style.position = "absolute";
      h.__isFlashLite() ? (b.style.left = "0px", b.style.top = "0px") : (b.style.left = "-100px", b.style.top = "-100px");
      var c = document.createElement("div");
      c.id = "webSocketFlash";
      b.appendChild(c);
      document.body.appendChild(b);
      Z.embedSWF(a, "webSocketFlash", "1", "1", "10.0.0", null, null, {hasPriority:!0, swliveconnect:!0, allowScriptAccess:"always"}, null, function(a) {
        a.success || logger.error("[WebSocket] swfobject.embedSWF failed")
      })
    }
  };
  window.WebSocket.__onFlashInitialized = h.__onFlashInitialized = function() {
    setTimeout(function() {
      h.__flash = document.getElementById("webSocketFlash");
      h.__flash.setCallerUrl(location.href);
      h.__flash.setDebug(!!window.WEB_SOCKET_DEBUG);
      for(var a = 0;a < h.__tasks.length;++a) {
        h.__tasks[a]()
      }
      h.__tasks = []
    }, 0)
  };
  window.WebSocket.__onFlashEvent = h.__onFlashEvent = function() {
    setTimeout(function() {
      try {
        for(var a = h.__flash.receiveEvents(), b = 0;b < a.length;++b) {
          h.__instances[a[b].webSocketId].__handleEvent(a[b])
        }
      }catch(c) {
        logger.error(c)
      }
    }, 0);
    return!0
  };
  window.WebSocket.__log = h.__log = function(a) {
    logger.log(decodeURIComponent(a))
  };
  window.WebSocket.__error = h.__error = function(a) {
    logger.error(decodeURIComponent(a))
  };
  h.__addTask = function(a) {
    h.__flash ? a() : h.__tasks.push(a)
  };
  h.__isFlashLite = function() {
    if(!window.navigator || !window.navigator.mimeTypes) {
      return!1
    }
    var a = window.navigator.mimeTypes["application/x-shockwave-flash"];
    return!a || !a.enabledPlugin || !a.enabledPlugin.filename ? !1 : a.enabledPlugin.filename.match(/flashlite/i) ? !0 : !1
  };
  Fa = h;
  var x = function() {
    this.any = [];
    this.events = {};
    this.anyOnce = [];
    this.eventsOnce = {}
  };
  x.prototype.on = function(a, b) {
    1 == arguments.length && "function" == typeof a ? this.any.push(a) : null === a ? this.any.push(b) : (this.events[a] = this.events[a] || []).push(b)
  };
  x.prototype.off = function(a, b) {
    if(0 == arguments.length) {
      this.any = [], this.events = {}, this.anyOnce = [], this.eventsOnce = {}
    }else {
      1 == arguments.length && "function" == typeof a && (b = a, a = null);
      var c, f = -1;
      if(null === a) {
        if(b) {
          if(!(c = this.any) || -1 == (f = c.indexOf(b))) {
            if(c = this.anyOnce) {
              f = c.indexOf(b)
            }
          }
          -1 < f && c.splice(f, 1)
        }else {
          this.any = [], this.anyOnce = []
        }
      }else {
        if(b) {
          f = -1;
          if(!(c = this.events[a]) || -1 == (f = c.indexOf(b))) {
            if(c = this.eventsOnce[a]) {
              f = c.indexOf(b)
            }
          }
          -1 < f && c.splice(f, 1)
        }else {
          delete this.events[a], delete this.eventsOnce[a]
        }
      }
    }
  };
  x.prototype.listeners = function(a) {
    if(a) {
      var b = this.events[a] || [];
      this.eventsOnce[a] && Array.prototype.push.apply(b, this.eventsOnce[a]);
      return b.length ? b : null
    }
    return this.any.length ? this.any : null
  };
  x.prototype.emit = function(a) {
    var b = Array.prototype.slice.call(arguments, 1), c = {event:a};
    if(this.anyOnce.length) {
      var f = this.anyOnce;
      this.anyOnce = [];
      for(var d = 0;d < f.length;d++) {
        f[d].apply(c, b)
      }
    }
    for(d = 0;d < this.any.length;d++) {
      this.any[d].apply(c, b)
    }
    if(f = this.eventsOnce[a]) {
      delete this.eventsOnce[a];
      for(d = 0;d < f.length;d++) {
        f[d].apply(c, b)
      }
    }
    if(f = this.events[a]) {
      for(d = 0;d < f.length;d++) {
        f[d].apply(c, b)
      }
    }
  };
  x.prototype.once = function(a, b) {
    1 == arguments.length && "function" == typeof a ? this.anyOnce.push(a) : null === a ? this.anyOnce.push(b) : (this.eventsOnce[a] = this.eventsOnce[a] || []).push(b)
  };
  var e = function() {
  }, vb = 4, wb = function() {
  };
  e.LOG_NONE = 0;
  e.LOG_ERROR = 1;
  e.LOG_MAJOR = 2;
  e.LOG_MINOR = 3;
  e.LOG_MICRO = 4;
  e.LOG_DEFAULT = 3;
  e.LOG_DEBUG = 4;
  e.logAction = function(a, b, c) {
    a <= vb && wb("Ably: " + b + ": " + c)
  };
  e.setLog = function(a, b) {
    vb = a || 3;
    wb = b || console.log.bind(console)
  };
  var i, s = function() {
  }, Ub = "object" == typeof window;
  s.addProperties = s.mixin = function(a, b) {
    for(var c in b) {
      a[c] = b[c]
    }
    return a
  };
  s.copy = function(a) {
    return s.mixin({}, a)
  };
  s.isArray = function(a) {
    return"[object Array]" == Object.prototype.toString.call(a)
  };
  s.isEmpty = function(a) {
    for(var b in a) {
      return!1
    }
    return!0
  };
  s.shallowClone = function(a) {
    var b = {}, c;
    for(c in a) {
      b[c] = a[c]
    }
    return b
  };
  s.prototypicalClone = function(a, b) {
    function c() {
    }
    c.prototype = a;
    var d = new c;
    b && s.mixin(d, b);
    return d
  };
  s.inherits = function(a, b) {
    a.super_ = b;
    a.prototype = Object.create(b.prototype, {constructor:{value:a, enumerable:!1, writable:!0, configurable:!0}})
  };
  s.containsValue = function(a, b) {
    for(var c in a) {
      if(a[c] == b) {
        return!0
      }
    }
    return!1
  };
  s.intersect = function(a, b) {
    return Array.isArray(b) ? s.arrIntersect(a, b) : s.arrIntersectOb(a, b)
  };
  s.arrIntersect = function(a, b) {
    for(var c = [], d = 0;d < a.length;d++) {
      var e = a[d];
      -1 != b.indexOf(e) && c.push(e)
    }
    return c
  };
  s.arrIntersectOb = function(a, b) {
    for(var c = [], d = 0;d < a.length;d++) {
      var e = a[d];
      e in b && c.push(e)
    }
    return c
  };
  s.arrSubtract = function(a, b) {
    for(var c = [], d = 0;d < a.length;d++) {
      var e = a[d];
      -1 == b.indexOf(e) && c.push(e)
    }
    return c
  };
  s.keysArray = function(a, b) {
    var c = [], d;
    for(d in a) {
      (!b || a.hasOwnProperty(d)) && c.push(d)
    }
    return c.length ? c : void 0
  };
  s.valuesArray = function(a, b) {
    var c = [], d;
    for(d in a) {
      (!b || a.hasOwnProperty(d)) && c.push(a[d])
    }
    return c.length ? c : void 0
  };
  s.nextTick = Ub ? function(a) {
    setTimeout(a, 0)
  } : process.nextTick;
  s.defaultGetHeaders = function(a) {
    return{accept:a ? "application/x-thrift,application/json" : "application/json"}
  };
  s.defaultPostHeaders = function(a) {
    return{accept:a ? "application/x-thrift,application/json" : "application/json", "content-type":a ? "application/x-thrift" : "application/json"}
  };
  s.arrRandomElement = function(a) {
    return a.splice(Math.floor(Math.random() * a.length))
  };
  i = s;
  var sa = function(a) {
    var a = a || [], b = function(b, d) {
      for(var e = 0;e < a.length;e++) {
        try {
          a[e](b, d)
        }catch(n) {
        }
      }
    };
    b.__proto__ = this.__proto__;
    b.members = a;
    return b
  };
  i.inherits(sa, Function);
  sa.prototype.push = function() {
    Array.prototype.push.apply(this.members, arguments)
  };
  var L, Za = function(a, b, c, d, e) {
    this.options = a;
    this.binary = !a.useTextProtocol;
    this.host = b;
    this.mode = c;
    this.connectionId = d;
    this.connectionSerial = e
  }, yb = function(a, b) {
    this.msg = a;
    var c = a.action;
    this.ackRequired = c == xb.MESSAGE || c == xb.PRESENCE;
    this.callback = b;
    this.merged = !1
  }, q = function(a, b) {
    x.call(this);
    this.realtime = a;
    this.options = b;
    this.state = H.initialized;
    this.error = null;
    this.queuedMessages = [];
    this.pendingMessages = [];
    this.msgSerial = 0;
    this.connectionSerial = this.connectionId = void 0;
    this.httpTransports = i.intersect(b.transports || v.httpTransports, q.httpTransports);
    this.transports = i.intersect(b.transports || v.transports, q.transports);
    this.upgradeTransports = i.arrSubtract(this.transports, this.httpTransports);
    var c = b.fallbackHosts;
    if(c) {
      var d;
      this.httpHosts = d = c.slice();
      d.unshift(b.restHost);
      this.wsHosts = d = c.slice();
      d.unshift(b.wsHost)
    }else {
      this.httpHosts = [b.restHost], this.wsHosts = [b.wsHost]
    }
    this.host = this.pendingTransport = this.transport = null;
    e.logAction(e.LOG_MINOR, "Realtime.ConnectionManager()", "started");
    e.logAction(e.LOG_MICRO, "Realtime.ConnectionManager()", "requested transports = [" + (b.transports || v.transports) + "]");
    e.logAction(e.LOG_MICRO, "Realtime.ConnectionManager()", "available http transports = [" + this.httpTransports + "]");
    e.logAction(e.LOG_MICRO, "Realtime.ConnectionManager()", "available transports = [" + this.transports + "]");
    e.logAction(e.LOG_MICRO, "Realtime.ConnectionManager()", "http hosts = [" + this.httpHosts + "]");
    e.logAction(e.LOG_MICRO, "Realtime.ConnectionManager()", "ws hosts = [" + this.wsHosts + "]");
    if(!this.transports.length) {
      throw e.logAction(e.LOG_ERROR, "realtime.ConnectionManager()", "no requested transports available"), Error("no requested transports available");
    }
    Ga && b.recover && window.addEventListener("beforeunload", function() {
      self.persistConnection()
    })
  }, zb = "undefined" !== typeof Cookie && Cookie.read, Ga = "undefined" !== typeof Cookie && Cookie.create, xb = ("object" == typeof E ? E : require("../nodejs/lib/protocol/clientmessage_types")).TAction, Ab = function() {
  }, H = {initialized:{state:"initialized", terminal:!1, queueEvents:!0, sendEvents:!1}, connecting:{state:"connecting", terminal:!1, queueEvents:!0, sendEvents:!1, retryDelay:v.connectTimeout, failState:"disconnected"}, connected:{state:"connected", terminal:!1, queueEvents:!1, sendEvents:!0, failState:"disconnected"}, disconnected:{state:"disconnected", terminal:!1, queueEvents:!0, sendEvents:!1, retryDelay:v.disconnectTimeout}, suspended:{state:"suspended", terminal:!1, queueEvents:!1, sendEvents:!1, 
  retryDelay:v.suspendedTimeout}, closed:{state:"closed", terminal:!1, queueEvents:!1, sendEvents:!1}, failed:{state:"failed", terminal:!0, queueEvents:!1, sendEvents:!1}};
  Za.prototype.getConnectParams = function(a) {
    var a = a ? i.prototypicalClone(a) : {}, b = this.options;
    switch(this.mode) {
      case "resume":
        a.resume = this.connectionId;
        this.connectionSerial && (a.connection_serial = this.connectionSerial);
        break;
      case "recover":
        if(!0 === b.recover) {
          a.recover = zb("ably-connection-id"), a.connection_serial = zb("ably-connection-serial")
        }else {
          if(b = b.recover.match(/^([\w|\d]+):([\w|\d]+)$/)) {
            a.recover = b[1], a.connection_serial = b[2]
          }
        }
    }
    a.binary = this.binary;
    a.timestamp = Date.now();
    return a
  };
  i.inherits(q, x);
  q.httpTransports = {};
  q.transports = {};
  q.prototype.chooseTransport = function(a) {
    e.logAction(e.LOG_MAJOR, "ConnectionManager.chooseTransport()", "");
    if(this.transport) {
      e.logAction(e.LOG_MINOR, "ConnectionManager.chooseTransport()", "Transport already established"), a(null, this.transport)
    }else {
      var b = this.connectionId ? "resume" : this.options.recover ? "recover" : "clean", c = new Za(this.options, null, b, this.connectionId, this.connectionSerial);
      e.logAction(e.LOG_MINOR, "ConnectionManager.chooseTransport()", "Transport recovery mode = " + b + ("clean" == b ? "" : "; connectionId = " + this.connectionId));
      var d = this;
      this.httpTransports.length ? this.chooseHttpTransport(c, function(b, n) {
        if(b) {
          e.logAction(e.LOG_ERROR, "ConnectionManager.chooseTransport()", "Unexpected error establishing transport; err = " + b), a(b)
        }else {
          if(e.logAction(e.LOG_MINOR, "ConnectionManager.chooseTransport()", "Establishing http transport: " + n), a(null, n), d.upgradeTransports.length) {
            n.on("connected", function(a, b) {
              e.logAction(e.LOG_MAJOR, "ConnectionManager.chooseTransport()", "upgrading ... connectionId = " + b);
              c = new Za(d.options, c.host, "resume", b, d.connectionSerial);
              d.chooseTransportForHost(c, d.upgradeTransports.slice(), Ab)
            })
          }
        }
      }) : (c.host = this.httpHosts[0], e.logAction(e.LOG_MINOR, "ConnectionManager.chooseTransport()", "No http transports available; ignoring fallback hosts"), this.chooseTransportForHost(c, d.transports.slice(), a))
    }
  };
  q.prototype.chooseTransportForHost = function(a, b, c) {
    var d = b.shift();
    if(d) {
      var j = this;
      e.logAction(e.LOG_MICRO, "ConnectionManager.chooseTransportForHost()", "trying " + d);
      q.transports[d].tryConnect(this, this.realtime.auth, a, function(k, n) {
        k ? j.chooseTransportForHost(a, b, c) : (e.logAction(e.LOG_MICRO, "ConnectionManager.chooseTransport()", "transport " + d + " connecting"), j.setTransportPending(n), c(null, n))
      })
    }else {
      var n = Error("Unable to connect (no available transport)");
      n.statusCode = 404;
      n.code = 8E4;
      c(n)
    }
  };
  q.prototype.chooseHttpTransport = function(a, b) {
    function c() {
      if(d.length) {
        q.httpTransports[n.httpTransports[0]].checkConnectivity(function(e, j) {
          e ? b(e) : j ? (a.host = i.arrRandomElement(d), n.chooseTransportForHost(a, n.httpTransports.slice(), function(a, d) {
            a ? c() : b(null, d)
          })) : (e = Error("Unable to connect (network unreachable)"), e.statusCode = 404, e.code = 8E4, b(e))
        })
      }else {
        var e = Error("Unable to connect (no available host)");
        e.statusCode = 404;
        e.code = 8E4;
        b(e)
      }
    }
    var d = this.httpHosts.slice(), e = d.shift();
    if(e) {
      a.host = e;
      var n = this;
      this.chooseTransportForHost(a, this.httpTransports.slice(), function(a, d) {
        a ? c() : b(null, d)
      })
    }else {
      e = Error("Unable to connect (no available host)"), e.statusCode = 404, e.code = 8E4, b(e)
    }
  };
  q.prototype.setTransportPending = function(a) {
    e.logAction(e.LOG_MINOR, "ConnectionManager.setTransportPending()", "transport = " + a);
    if(this.state == H.closed) {
      a.close(!0)
    }else {
      this.pendingTransport && this.pendingTransport.close(!1);
      this.pendingTransport = a;
      for(var b = this, c = function(c) {
        return function(d, f) {
          e.logAction(e.LOG_MINOR, "ConnectionManager.setTransportPending", "on state = " + c);
          d && d.reason && e.logAction(e.LOG_MICRO, "ConnectionManager.setTransportPending", "reason =  " + d.reason);
          f && e.logAction(e.LOG_MICRO, "ConnectionManager.setTransportPending", "connectionId =  " + f);
          "connected" == c ? b.activateTransport(a, f) : b.deactivateTransport(a);
          b.transport === a && b.notifyState({state:c, error:d})
        }
      }, d = ["connected", "disconnected", "closed", "failed"], j = 0;j < d.length;j++) {
        var n = d[j];
        a.on(n, c(n))
      }
      this.emit("transport.pending", a)
    }
  };
  q.prototype.activateTransport = function(a, b) {
    e.logAction(e.LOG_MINOR, "ConnectionManager.activateTransport()", "transport = " + a + "; connectionId = " + b);
    if(this.state != H.closed) {
      var c = this.transport;
      c && (this.transport = null, c.close(!1));
      if(c = this.pendingTransport) {
        this.pendingTransport = null
      }
      this.transport = a;
      this.host = a.params.host;
      b && this.connectionId != b && (this.realtime.connection.id = this.connectionId = b, this.msgSerial = 0);
      var d = this;
      a.on("ack", function(a, b) {
        e.logAction(e.LOG_MICRO, "ConnectionManager on(ack)", "serial = " + a + "; count = " + b);
        d.ackMessage(a, b)
      });
      a.on("nack", function(a, b, c) {
        e.logAction(e.LOG_ERROR, "ConnectionManager on(nack)", "serial = " + a + "; count = " + b + "; err = " + c);
        c || (c = Error("Unknown error"), c.statusCode = 500, c.code = 50001, c.reason = "Unable to send message; channel not responding");
        d.ackMessage(a, b, c)
      });
      this.emit("transport.active", a, b, a.params)
    }
  };
  q.prototype.deactivateTransport = function(a) {
    e.logAction(e.LOG_MINOR, "ConnectionManager.deactivateTransport()", "transport = " + a);
    a.off("ack");
    a.off("nack");
    this.transport === a ? this.transport = this.host = null : this.pendingTransport === a && (this.pendingTransport = null);
    this.emit("transport.inactive", a)
  };
  q.prototype.persistConnection = function() {
    Ga && (this.connectionId && Ga("ably-connection-id", this.connectionId), this.connectionSerial && Ga("ably-connection-serial", this.connectionSerial))
  };
  q.prototype.getStateError = function() {
    return V[this.state.state]
  };
  q.activeState = function(a) {
    return a.queueEvents || a.sendEvents
  };
  q.prototype.enactStateChange = function(a) {
    e.logAction(e.LOG_MINOR, "ConnectionManager.enactStateChange", "setting new state: " + a.current);
    this.state = H[a.current];
    this.state.terminal && (this.error = a.error);
    this.emit("connectionstate", a, this.transport)
  };
  q.prototype.startConnectTimer = function() {
    var a = this;
    this.connectTimer = setTimeout(function() {
      a.connectTimer && (e.logAction(e.LOG_MINOR, "ConnectionManager connect timer expired", "requesting new state: " + H.connecting.failState), a.notifyState({state:H.connecting.failState}))
    }, v.connectTimeout)
  };
  q.prototype.cancelConnectTimer = function() {
    this.connectTimer && (clearTimeout(this.connectTimer), this.connectTimer = void 0)
  };
  q.prototype.startSuspendTimer = function() {
    var a = this;
    this.suspendTimer || (this.suspendTimer = setTimeout(function() {
      a.suspendTimer && (e.logAction(e.LOG_MINOR, "ConnectionManager suspend timer expired", "requesting new state: suspended"), H.connecting.failState = "suspended", H.connecting.queueEvents = !1, a.notifyState({state:"suspended"}))
    }, v.suspendedTimeout))
  };
  q.prototype.cancelSuspendTimer = function() {
    H.connecting.failState = "disconnected";
    H.connecting.queueEvents = !0;
    this.suspendTimer && (clearTimeout(this.suspendTimer), delete this.suspendTimer)
  };
  q.prototype.startRetryTimer = function(a) {
    var b = this;
    this.retryTimer = setTimeout(function() {
      e.logAction(e.LOG_MINOR, "ConnectionManager retry timer expired", "retrying");
      b.requestState({state:"connecting"})
    }, a)
  };
  q.prototype.cancelRetryTimer = function() {
    this.retryTimer && (clearTimeout(this.retryTimer), delete this.retryTimer)
  };
  q.prototype.notifyState = function(a) {
    if(!(this.state.terminal || a.state == this.state.state)) {
      e.logAction(e.LOG_MINOR, "ConnectionManager.notifyState()", "new state: " + a.state);
      var b = H[a.state];
      !b.sendEvents && this.transport && (e.logAction(e.LOG_MINOR, "ConnectionManager.notifyState()", "deleting transport " + this.transport), this.transport.dispose(), delete this.transport);
      this.cancelConnectTimer();
      this.cancelRetryTimer();
      "connected" == a.state && this.cancelSuspendTimer();
      a = new Ha(this.state.state, b.state, b.retryDelay, a.error || V[b.state]);
      b.retryDelay && this.startRetryTimer(b.retryDelay);
      this.enactStateChange(a);
      this.state.sendEvents ? this.sendQueuedMessages() : this.state.queueEvents && this.queuePendingMessages()
    }
  };
  q.prototype.requestState = function(a) {
    this.cancelConnectTimer();
    this.cancelRetryTimer();
    if(a.state != this.state.state) {
      if(this.state.terminal) {
        throw Error(this.error.reason);
      }
      if("connecting" == a.state) {
        if("connected" == this.state.state) {
          return
        }
        this.connectImpl()
      }else {
        this.pendingTransport && (this.pendingTransport.close(!0), this.pendingTransport = null), "failed" == a.state ? this.transport && (this.transport.abort(a.reason), this.transport = null) : (a.state = "closed", this.cancelConnectTimer(), this.cancelRetryTimer(), this.cancelSuspendTimer(), this.transport && (this.transport.close(!0), this.transport = null))
      }
      if(a.state != this.state.state) {
        var b = H[a.state], a = new Ha(this.state.state, b.state, b.retryIn, a.error || V[b.state]);
        this.enactStateChange(a)
      }
    }
  };
  q.prototype.connectImpl = function() {
    e.logAction(e.LOG_MINOR, "ConnectionManager.connectImpl()", "starting connection");
    this.startSuspendTimer();
    this.startConnectTimer();
    var a = this, b = this.realtime.auth, c = function(d) {
      e.logAction(e.LOG_ERROR, "ConnectionManager.connectImpl()", d);
      401 == d.statusCode && (-1 != d.message.indexOf("expire") && "token" == b.method) && b.getToken(!0, function(b) {
        b ? c(b) : a.connectImpl()
      });
      a.notifyState({state:H.connecting.failState, error:d})
    }, d = function() {
      a.chooseTransport(function(a) {
        a && c(a)
      })
    };
    "basic" == b.method ? d() : b.authorise(!1, function(a) {
      a ? c(a) : d()
    })
  };
  q.prototype.send = function(a, b, c) {
    c = c || Ab;
    this.state.queueEvents && (b ? this.queue(a, c) : (e.logAction(e.LOG_MICRO, "ConnectionManager.send()", "rejecting event"), c(this.error)));
    this.state.sendEvents && (e.logAction(e.LOG_MICRO, "ConnectionManager.send()", "sending event"), this.sendImpl(new yb(a, c)))
  };
  q.prototype.sendImpl = function(a) {
    var b = a.msg;
    a.ackRequired && (b.msgSerial = this.msgSerial++, this.pendingMessages.push(a));
    try {
      this.transport.send(b, function() {
      })
    }catch(c) {
      e.logAction(e.LOG_ERROR, "ConnectionManager.sendQueuedMessages()", "Unexpected exception in transport.send(): " + c)
    }
  };
  q.prototype.ackMessage = function(a, b, c) {
    e.logAction(e.LOG_MICRO, "ConnectionManager.ackMessage()", "serial = " + a + "; count = " + b);
    var c = c || null, d = this.pendingMessages, j = d[0];
    if(j && (j = j.msg.msgSerial, a += b, a > j)) {
      d = d.splice(0, a - j);
      for(a = 0;a < d.length;a++) {
        d[a].callback(c)
      }
    }
  };
  q.prototype.queue = function(a, b) {
    e.logAction(e.LOG_MICRO, "ConnectionManager.queue()", "queueing event");
    var c = this.queuedMessages[this.queuedMessages.length - 1];
    c && $a.mergeTo(c.msg, a) ? (c.merged || (c.callback = new sa([c.callback]), c.merged = !0), c.listener.push(b)) : this.queuedMessages.push(new yb(a, b))
  };
  q.prototype.sendQueuedMessages = function() {
    e.logAction(e.LOG_MICRO, "ConnectionManager.sendQueuedMessages()", "sending " + this.queuedMessages.length + " queued messages");
    for(var a;a = this.queuedMessages.shift();) {
      this.sendImpl(a)
    }
  };
  q.prototype.queuePendingMessages = function() {
    e.logAction(e.LOG_MICRO, "ConnectionManager.queuePendingMessages()", "queueing " + this.pendingMessages.length + " pending messages");
    this.queuedMessages = this.pendingMessages.concat(this.queuedMessages);
    this.pendingMessages = []
  };
  q.prototype.onChannelMessage = function(a, b) {
    if(b === this.transport || b.connectionId == this.connectionId) {
      this.realtime.channels.onChannelMessage(a)
    }else {
      this.realtime.channels.retryChannelMessage(a)
    }
  };
  L = q;
  var y = function(a, b, c) {
    x.call(this);
    this.connectionManager = a;
    this.auth = b;
    this.params = c;
    this.isConnected = !1
  }, ab = "object" == typeof window ? E : require("../nodejs/lib/protocol/clientmessage_types"), ba = ab.TAction, Vb = ab.TFlags, Wb = function() {
  };
  i.inherits(y, x);
  y.prototype.connect = function() {
  };
  y.prototype.close = function(a) {
    this.isConnected = !1;
    this.emit("closed", V.closed);
    a && this.sendDisconnect();
    this.dispose()
  };
  y.prototype.abort = function(a) {
    this.isConnected = !1;
    this.emit("failed", a);
    this.sendDisconnect();
    this.dispose()
  };
  y.prototype.sendDisconnect = function() {
    this.send(new ab.TChannelMessage({action:ba.DISCONNECT}), Wb)
  };
  y.prototype.onChannelMessage = function(a) {
    switch(a.action) {
      case ba.HEARTBEAT:
        this.emit("heartbeat");
        break;
      case ba.CONNECTED:
        this.connectionId = a.connectionId;
        this.isConnected = !0;
        this.onConnect(a);
        this.emit("connected", null, this.connectionId, a.flags);
        break;
      case ba.DISCONNECTED:
        this.isConnected = !1;
        this.onDisconnect();
        break;
      case ba.ACK:
        this.emit("ack", a.msgSerial, a.count);
        break;
      case ba.NACK:
        this.emit("nack", a.msgSerial, a.count, a.error);
        break;
      case ba.ERROR:
        this.abort({statusCode:a.statusCode, code:a.code, reason:a.reason});
        break;
      default:
        this.connectionManager.onChannelMessage(a, this)
    }
  };
  y.prototype.onConnect = function(a) {
    a.flags && a.flags & 1 << Vb.SYNC_TIME && this.connectionManager.realtime.time({connection_id:a.connectionId})
  };
  y.prototype.onDisconnect = function() {
  };
  y.prototype.onClose = function(a, b) {
    if("closed" != this.connectionManager.state.state) {
      var c = a ? "disconnected" : "failed";
      this.isConnected = !1;
      var d = i.copy(V[c]);
      b && (d.reason = b);
      this.emit(c, d)
    }
  };
  y.prototype.dispose = function() {
    this.off()
  };
  var z = function(a, b, c) {
    c.binary = c.binary && Xb;
    y.call(this, a, b, c)
  }, Bb = "object" == typeof window, Cb = Bb ? window.WebSocket || window.MozWebSocket : require("ws"), Xb = Bb ? !1 : !!B;
  i.inherits(z, y);
  z.isAvailable = function() {
    return!!Cb
  };
  z.isAvailable() && (L.transports.web_socket = z);
  z.tryConnect = function(a, b, c, d) {
    var j = new z(a, b, c), n = function(a) {
      d(a)
    };
    j.on("wserror", n);
    j.on("wsopen", function() {
      e.logAction(e.LOG_MINOR, "WebSocketTransport.tryConnect()", "viable transport " + j);
      j.off("wserror", n);
      d(null, j)
    });
    j.connect()
  };
  z.prototype.createWebSocket = function(a, b) {
    var c = 0;
    if(b) {
      for(var d in b) {
        a += (c++ ? "&" : "?") + d + "=" + b[d]
      }
    }
    this.uri = a;
    return new Cb(a)
  };
  z.prototype.toString = function() {
    return"WebSocketTransport; uri=" + this.uri
  };
  z.prototype.connect = function() {
    e.logAction(e.LOG_MINOR, "WebSocketTransport.connect()", "starting");
    y.prototype.connect.call(this);
    var a = this, b = this.params, c = b.options, d = (c.encrypted ? "wss://" : "ws://") + b.host + ":" + c.wsPort + "/";
    e.logAction(e.LOG_MINOR, "WebSocketTransport.connect()", "uri: " + d);
    this.auth.getAuthParams(function(c, n) {
      var k = "", g;
      for(g in n) {
        k += " " + g + ": " + n[g] + ";"
      }
      e.logAction(e.LOG_MINOR, "WebSocketTransport.connect()", "authParams:" + k);
      if(c) {
        a.abort(UIMessages.FAIL_REASON_REFUSED)
      }else {
        k = b.getConnectParams(n);
        try {
          var p = a.wsConnection = a.createWebSocket(d, k);
          p.binaryType = "arraybuffer";
          p.onopen = function() {
            a.onWsOpen()
          };
          p.onclose = function(b, c) {
            a.onWsClose(b, c)
          };
          p.onmessage = function(b) {
            a.onWsData(b.data, "string" != typeof b.data)
          };
          p.onerror = function(b) {
            a.onWsError(b)
          }
        }catch(h) {
          a.onWsError(h)
        }
      }
    })
  };
  z.prototype.send = function(a, b) {
    try {
      this.wsConnection.send(Serialize.TChannelMessage.encode(a, this.params.binary))
    }catch(c) {
      var d = "Unexpected send exception: " + c;
      e.logAction(e.LOG_ERROR, "WebSocketTransport.send()", d);
      b(Error(d))
    }
  };
  z.prototype.onWsData = function(a, b) {
    e.logAction(e.LOG_MICRO, "WebSocketTransport.onWsData()", "data received; length = " + a.length + "; type = " + typeof a + "; binary = " + b);
    try {
      this.onChannelMessage(Serialize.TChannelMessage.decode(a, b))
    }catch(c) {
      e.logAction(e.LOG_ERROR, "WebSocketTransport.onWsData()", "Unexpected exception handing channel message: " + c.stack)
    }
  };
  z.prototype.onWsOpen = function() {
    e.logAction(e.LOG_MINOR, "WebSocketTransport.onWsOpen()", "opened WebSocket");
    this.emit("wsopen")
  };
  z.prototype.onWsClose = function(a, b) {
    var c, d, j;
    "object" == typeof a ? (c = a.wasClean, d = a.code, j = a.reason) : (d = a, j = b || "", c = 1E3 == d);
    e.logAction(e.LOG_MINOR, "WebSocketTransport.onWsClose()", "closed WebSocket; wasClean = " + c + "; code = " + d);
    delete this.wsConnection;
    y.prototype.onClose.call(this, c, j)
  };
  z.prototype.onWsError = function(a) {
    e.logAction(e.LOG_ERROR, "WebSocketTransport.onError()", "Unexpected error from WebSocket: " + a);
    this.emit("wserror", a);
    this.abort()
  };
  z.prototype.dispose = function() {
    this.wsConnection && (this.wsConnection.close(), delete this.wsConnection)
  };
  var u = function(a, b, c) {
    y.call(this, a, b, c);
    this.binary = this.params.binary;
    this.pendingItems = this.pendingCallback = this.recvRequest = this.sendRequest = null
  };
  "object" == typeof E || require("../nodejs/lib/protocol/clientmessage_types");
  (i || require("util")).inherits(u, y);
  u.paramStr = function(a, b) {
    var c = 0, d = b || "";
    if(a) {
      for(var e in a) {
        d += (c++ ? "&" : "?") + e + "=" + a[e]
      }
    }
    return d
  };
  u.prototype.connect = function() {
    e.logAction(e.LOG_MINOR, "CometTransport.connect()", "starting");
    y.prototype.connect.call(this);
    var a = this, b = this.params, c = b.options;
    this.baseUri = (c.encrypted ? "https://" : "http://") + b.host + ":" + c.wsPort + "/comet/";
    var d = this.baseUri + "connect";
    e.logAction(e.LOG_MINOR, "CometTransport.connect()", "uri: " + d);
    this.auth.getAuthParams(function(b, c) {
      if(b) {
        a.abort(UIMessages.FAIL_REASON_REFUSED)
      }else {
        a.authParams = c;
        var k = a.params.getConnectParams(c);
        e.logAction(e.LOG_MINOR, "CometTransport.connect()", "connectParams:" + u.paramStr(k));
        try {
          a.request(d, k, null, !1, function(b, c) {
            b ? a.emit("error", b) : (a.emit("preconnect"), a.onResponseData(c))
          })
        }catch(g) {
          a.emit("error", g)
        }
      }
    })
  };
  u.prototype.sendDisconnect = function() {
    var a = this;
    this.request(this.closeUri, this.authParams, null, !1, function(b) {
      b && a.emit("error", b)
    })
  };
  u.prototype.dispose = function() {
    this.recvRequest && (this.recvRequest.abort(), this.recvRequest = null)
  };
  u.prototype.onConnect = function() {
    var a = this.baseUri + this.connectionId;
    this.sendUri = a + "/send";
    this.recvUri = a + "/recv";
    this.closeUri = a + "/close";
    this.recv()
  };
  u.prototype.send = function(a, b) {
    if(this.sendRequest) {
      this.pendingItems = this.pendingItems || [], this.pendingItems.push(a), this.pendingCallback = this.pendingCallback || new sa, this.pendingCallback.push(b)
    }else {
      var c = this.pendingItems || [];
      c.push(a);
      this.pendingItems = null;
      var d = this.pendingCallback;
      d && (d.push(b), b = d, this.pendingCallback = null);
      this.sendItems(c, b)
    }
  };
  u.prototype.sendItems = function(a, b) {
    var c = this;
    try {
      this.sendRequest = c.request(c.sendUri, c.authParams, this.encodeRequest(a), !1, function(a, d) {
        c.sendRequest = null;
        c.pendingItems && (c.sendItems(c.pendingItems, c.pendingCallback), c.pendingItems = null, c.pendingCallback = null);
        a ? b(a) : (c.onResponseData(d), b(null))
      })
    }catch(d) {
      var j = "Unexpected send exception: " + d;
      e.logAction(e.LOG_ERROR, "CometTransport.sendItems()", j);
      b(Error(j))
    }
  };
  u.prototype.recv = function() {
    this.recvRequest && (this.recvRequest.abort(), this.recvRequest = null);
    if(this.isConnected) {
      var a = this;
      this.recvRequest = this.request(this.recvUri, this.authParams, null, !0, function(b, c) {
        b ? a.emit("error", b) : (a.onRecvResponse(c), a.recvRequest = null, a.recv())
      })
    }
  };
  u.prototype.onResponseData = function(a) {
    try {
      var b = this.decodeResponse(a);
      if(b && b.length) {
        for(a = 0;a < b.length;a++) {
          this.onChannelMessage(b[a])
        }
      }
    }catch(c) {
      e.logAction(e.LOG_ERROR, "CometTransport.onResponseData()", "Unexpected exception handing channel event: " + c.stack)
    }
  };
  u.prototype.onRecvResponse = function(a) {
    this.onResponseData(a)
  };
  u.prototype.encodeRequest = function(a) {
    return Serialize.TMessageSet.encode(a, this.binary)
  };
  u.prototype.decodeResponse = function(a) {
    return Serialize.TMessageSet.decode(a, this.binary)
  };
  var bb = function() {
  }, A = "object" == typeof E ? E : require("../nodejs/lib/protocol/clientmessage_types"), Yb = {"[object Null]":function(a) {
    a.type = A.TType.NONE;
    return!0
  }, "[object Buffer]":function(a, b) {
    a.type = A.TType.BUFFER;
    a.binaryData = b;
    return!0
  }, "[object ArrayBuffer]":function(a, b) {
    a.type = A.TType.BUFFER;
    a.binaryData = b;
    return!0
  }, "[object Array]":function(a, b) {
    a.type = A.TType.JSONARRAY;
    a.stringData = JSON.stringify(b);
    return!0
  }, "[object String]":function(a, b) {
    a.type = A.TType.STRING;
    a.stringData = b.valueOf();
    return!0
  }, "[object Number]":function(a, b) {
    a.type = A.TType.DOUBLE;
    a.doubleData = b.valueOf();
    return!0
  }, "[object Boolean]":function(a, b) {
    a.type = b.valueOf() ? A.TType.TRUE : A.TType.FALSE;
    return!0
  }, "[object Object]":function(a, b) {
    "undefined" !== typeof B && B.isBuffer(b) ? (a.type = A.TType.BUFFER, a.binaryData = b) : (a.type = A.TType.JSONOBJECT, a.stringData = JSON.stringify(b));
    return!0
  }, "[object Function]":function(a, b) {
    a.type = A.TType.JSONOBJECT;
    a.stringData = JSON.stringify(b);
    return!0
  }}, Zb = {undefined:function(a) {
    a.type = A.TType.NONE;
    return!0
  }, "boolean":function(a, b) {
    a.type = b ? A.TType.TRUE : A.TType.FALSE;
    return!0
  }, string:function(a, b) {
    a.type = A.TType.STRING;
    a.stringData = b;
    return!0
  }, number:function(a, b) {
    a.type = A.TType.DOUBLE;
    a.doubleData = b;
    return!0
  }, object:function(a, b) {
    var c = Yb[Object.prototype.toString.call(b)];
    return c && c(a, b)
  }};
  bb.fromTData = function(a) {
    var b = void 0;
    switch(a.type) {
      case 1:
        b = !0;
        break;
      case 2:
        b = !1;
        break;
      case 3:
        b = a.i32Data;
        break;
      case 4:
        b = a.i64Data;
        break;
      case 5:
        b = a.doubleData;
        break;
      case 6:
        b = a.stringData;
        break;
      case 7:
        b = a.binaryData;
        break;
      case 8:
      ;
      case 9:
        b = JSON.parse(a.stringData)
    }
    return b
  };
  bb.toTData = function(a) {
    var b = new A.TData, c = Zb[typeof a];
    if(c && c(b, a)) {
      return b
    }
    throw Error("Unsupported data type: " + Object.prototype.toString.call(a));
  };
  this.Data = bb;
  var Db;
  "object" == typeof E || require("../nodejs/lib/protocol/clientmessage_types");
  Db = function(a, b, c, d) {
    this.channelSerial = a;
    this.timestamp = b;
    this.name = c;
    this.data = d
  };
  "object" == typeof E || require("../nodejs/lib/protocol/clientmessage_types");
  this.PresenceMessage = void 0;
  var ca = function() {
  }, N = "object" == typeof E ? E : require("../nodejs/lib/protocol/clientmessage_types"), ja = ca.TData = {}, cb = ca.TMessage = {}, Eb = ca.TPresence = {}, ta = ca.TChannelMessage = {}, $b = ca.TMessageArray = {}, Fb = ca.TMessageSet = {}, Ia = N.TType.BUFFER;
  ja.fromREST = function(a) {
    var b, c = a.data, d = a.encoding;
    d ? (b = new ja, b.type = Ia, b.binaryData = new B(c, d)) : Data.toTData(c);
    a.data = c
  };
  N.TMessage.prototype.toJSON = function() {
    var a = this.data, b = {name:this.name, clientId:this.clientId, timestamp:this.timestamp, tags:this.tags}, c = Data.fromTData(a);
    a.type == Ia && (b.encoding = "base64", c = c.toString("base64"));
    b.data = c;
    return b
  };
  N.TPresence.prototype.toJSON = function() {
    var a = this.clientData, b = {name:this.name, clientId:this.clientId, timestamp:this.timestamp, tags:this.tags}, c = Data.fromTData(a);
    a.type == Ia && (b.encoding = "base64", c = c.toString("base64"));
    b.clientData = c;
    return b
  };
  ja.fromREST = function(a, b) {
    var c, d = a.encoding;
    d ? (c = new ja, c.type = Ia, c.binaryData = new B(b, d)) : c = Data.toTData(b);
    return c
  };
  cb.fromJSON = function(a) {
    a.data = ja.fromREST(a, a.data);
    return new N.TMessage(a)
  };
  Eb.fromJSON = function(a) {
    a.clientData = ja.fromREST(a, a.clientData);
    return new N.TPresence(a)
  };
  ta.fromJSON = function(a) {
    var b;
    if(b = a.messages) {
      for(var c = b.length, d = a.messages = Array(c), e = 0;e < c;e++) {
        d[e] = cb.fromJSON(b[e])
      }
    }
    if(b = a.presence) {
      c = b.length;
      d = a.presence = Array(c);
      for(e = 0;e < c;e++) {
        d[e] = Eb.fromJSON(b[e])
      }
    }
    return new N.TChannelMessage(a)
  };
  ta.decode = function(a, b) {
    var c, d;
    if(b) {
      if(d = ThriftUtil.decodeSync(c = new N.TChannelMessage, a)) {
        throw d;
      }
    }else {
      c = ta.fromJSON(JSON.parse(a))
    }
    return c
  };
  Fb.decode = function(a, b) {
    var c = null;
    if(a) {
      if(b) {
        var d;
        if(c = ThriftUtil.decodeSync(d = new N.TMessageSet, a)) {
          throw c;
        }
        c = d.items
      }else {
        d = JSON.parse(a);
        for(var e = d.length, c = Array(e), n = 0;n < e;n++) {
          c[n] = ta.fromJSON(d[n])
        }
      }
    }
    return c
  };
  ta.encode = function(a, b) {
    return b ? ThriftUtil.encodeSync(a) : JSON.stringify(a)
  };
  Fb.encode = function(a, b) {
    return b ? ThriftUtil.encodeSync(new N.TMessageSet({items:a})) : JSON.stringify(a)
  };
  $b.decode = function(a, b) {
    var c = null;
    if(a) {
      if(b) {
        var d;
        if(c = ThriftUtil.decodeSync(d = new N.TMessageArray, a)) {
          throw c;
        }
        c = d.items
      }else {
        d = JSON.parse(a);
        for(var e = d.length, c = Array(e), n = 0;n < e;n++) {
          c[n] = cb.fromJSON(d[n])
        }
      }
    }
    return c
  };
  this.Serialize = ca;
  var ka = function() {
  };
  ka.get = function(a, b, c, d, e) {
    function n() {
      a.auth.getAuthHeaders(function(k, g) {
        k ? e(k) : Http.get(a, b, i.mixin(g, c), d, function(b, c) {
          b && 40140 == b.code ? a.auth.authorise({force:!0}, function(a) {
            a ? e(a) : n()
          }) : e(b, c)
        })
      })
    }
    n()
  };
  ka.post = function(a, b, c, d, e, n) {
    function k() {
      a.auth.getAuthHeaders(function(g, h) {
        g ? n(g) : Http.post(a, b, i.mixin(h, d), c, e, function(b, c) {
          b && 40140 == b.code ? a.auth.authorise({force:!0}, function(a) {
            a ? n(a) : k()
          }) : n(b, c)
        })
      })
    }
    k()
  };
  var ac = function() {
  }, bc = function(a) {
    if(!a) {
      return""
    }
    "string" == typeof a && (a = JSON.parse(a));
    var b = {}, c = i.keysArray(a, !0);
    if(!c) {
      return""
    }
    c.sort();
    for(var d = 0;d < c.length;d++) {
      b[c[d]] = a[c[d]].sort()
    }
    return JSON.stringify(b)
  }, da = function(a, b) {
    this.rest = a;
    var c = this.tokenOptions = {};
    b.keyId && (c.keyId = b.keyId);
    b.keyValue && (c.keyValue = b.keyValue);
    if(b.keyValue) {
      if(!b.clientId) {
        e.logAction(e.LOG_MINOR, "Auth()", "anonymous, using basic auth");
        this.method = "basic";
        this.basicKey = (new B(b.key || b.keyId + ":" + b.keyValue, "ascii")).toString("base64");
        this.keyId = b.keyId;
        this.keyValue = b.keyValue;
        return
      }
      if(!Ja) {
        throw c = "client-side token request signing not supported", e.logAction(e.LOG_ERROR, "Auth()", c), Error(c);
      }
    }
    this.method = "token";
    b.authToken && (this.token = {id:b.authToken});
    if(b.authCallback) {
      e.logAction(e.LOG_MINOR, "Auth()", "using token auth with authCallback"), c.authCallback = b.authCallback
    }else {
      if(b.authUrl) {
        e.logAction(e.LOG_MINOR, "Auth()", "using token auth with authUrl"), c.authUrl = b.authUrl
      }else {
        if(b.keyValue) {
          e.logAction(e.LOG_MINOR, "Auth()", "using token auth with client-side signing")
        }else {
          if(this.token) {
            e.logAction(e.LOG_MINOR, "Auth()", "using token auth with supplied token only")
          }else {
            throw c = "options must include valid authentication parameters", e.logAction(e.LOG_ERROR, "Auth()", c), Error(c);
          }
        }
      }
    }
  }, db = "object" == typeof window, cc = db ? null : require("crypto"), Ja = void 0;
  db && (window.CryptoJS && CryptoJS.HmacSHA256 && CryptoJS.enc.Base64) && (Ja = function(a, b) {
    return CryptoJS.HmacSHA256(a, b).toString(CryptoJS.enc.Base64)
  });
  db || (Ja = function(a, b) {
    var c = cc.createHmac("SHA256", b);
    c.update(a);
    return c.digest("base64")
  });
  da.prototype.authorise = function(a, b) {
    var c = this.token;
    if(c) {
      if(void 0 === c.expires || c.expires > this.getTimestamp()) {
        if(!a.force) {
          e.logAction(e.LOG_MINOR, "Auth.getToken()", "using cached token; expires = " + c.expires);
          b(null, c);
          return
        }
      }else {
        e.logAction(e.LOG_MINOR, "Auth.getToken()", "deleting expired token"), this.token = null
      }
    }
    var d = this;
    this.requestToken(a, function(a, c) {
      a ? b(a) : b(null, d.token = c.access_token)
    })
  };
  da.prototype.requestToken = function(a, b) {
    "function" == typeof a && !b && (b = a, a = {});
    var a = a || {}, b = b || ac, a = i.mixin(i.copy(this.tokenOptions), a), c, d = this.rest;
    if(a.authCallback) {
      e.logAction(e.LOG_MINOR, "Auth.requestToken()", "using token auth with auth_callback"), c = a.authCallback
    }else {
      if(a.authUrl) {
        e.logAction(e.LOG_MINOR, "Auth.requestToken()", "using token auth with auth_url"), c = function(b, c) {
          Http.get(d, a.authUrl, a.authHeaders || {}, i.mixin(b, a.authParams), c)
        }
      }else {
        if(a.keyValue) {
          var j = this;
          e.logAction(e.LOG_MINOR, "Auth.requestToken()", "using token auth with client-side signing");
          c = function(b, c) {
            j.createTokenRequest(i.mixin(i.copy(a), b), c)
          }
        }else {
          throw Error("Auth.requestToken(): options must include valid authentication parameters");
        }
      }
    }
    var g = {}, k = a.clientId || this.rest.clientId;
    k && (g.client_id = k);
    k = a.ttl || "";
    "ttl" in a && (g.ttl = k);
    "capability" in a && (g.capability = bc(a.capability));
    var d = this.rest, h = function(b) {
      return d.baseUri(b) + "/keys/" + a.keyId + "/authorise"
    };
    c(g, function(a, c) {
      if(a) {
        e.logAction(e.LOG_ERROR, "Auth.requestToken()", "token request signing call returned error; err = " + a), b(a)
      }else {
        var j = function(a, c) {
          a ? (e.logAction(e.LOG_ERROR, "Auth.requestToken()", "token request API call returned error; err = " + a), b(a)) : (e.logAction(e.LOG_MINOR, "Auth.getToken()", "token received"), b(null, c.access_token))
        };
        Http.post ? Http.post(d, h, i.defaultPostHeaders(), c, null, j) : Http.get(d, h, i.defaultGetHeaders(), c, j)
      }
    })
  };
  da.prototype.createTokenRequest = function(a, b) {
    var c = a.keyId, d = a.keyValue;
    if(!c || !d) {
      b(Error("No key specified"))
    }else {
      var j = {id:c}, g = a.clientId || "";
      g && (j.client_id = a.clientId);
      var k = a.ttl || "";
      k && (j.ttl = k);
      var h = a.capability || "";
      h && (j.capability = h);
      var c = this.rest, i = function() {
        var c = j.nonce = a.nonce || ("000000" + Math.floor(1E16 * Math.random())).slice(-16), i = j.timestamp = a.timestamp, c = j.id + "\n" + k + "\n" + h + "\n" + g + "\n" + i + "\n" + c + "\n";
        j.mac = a.mac || Ja(c, d);
        e.logAction(e.LOG_MINOR, "Auth.getTokenRequest()", "generated signed request");
        b(null, j)
      };
      a.timestamp ? i() : a.queryTime ? c.time(function(c, d) {
        c ? b(c) : (a.timestamp = Math.floor(d / 1E3), i())
      }) : (a.timestamp = this.getTimestamp(), i())
    }
  };
  da.prototype.getAuthParams = function(a) {
    "basic" == this.method ? a(null, {key_id:this.keyId, key_value:this.keyValue}) : this.authorise({}, function(b, c) {
      b ? a(b) : a(null, {access_token:c.id})
    })
  };
  da.prototype.getAuthHeaders = function(a) {
    "basic" == this.method ? a(null, {authorization:"Basic " + this.basicKey}) : this.authorise({}, function(b, c) {
      b ? a(b) : a(null, {authorization:"Bearer " + (new B(c.id, "ascii")).toString("base64")})
    })
  };
  da.prototype.getTimestamp = function() {
    var a = Date.now() + (this.rest.serverTimeOffset || 0);
    return Math.floor(a / 1E3)
  };
  var eb = function(a) {
    if(!a) {
      var b = "no options provided";
      e.logAction(e.LOG_ERROR, "Rest()", b);
      throw Error(b);
    }
    "string" == typeof a && (a = {key:a});
    this.options = a;
    if(a.key) {
      b = a.key.match(/^([^:\s]+):([^:.\s]+)$/);
      if(!b) {
        throw b = "invalid key parameter", e.logAction(e.LOG_ERROR, "Rest()", b), Error(b);
      }
      a.keyId = b[1];
      a.keyValue = b[2]
    }
    a.log && e.setLog(a.log.level, a.log.handler);
    e.logAction(e.LOG_MINOR, "Rest()", "started");
    this.clientId = a.clientId;
    "object" == typeof window && ("https:" == window.location.protocol && !("encrypted" in a)) && (a.encrypted = !0);
    a.fallbackHosts = a.restHost ? null : v.fallbackHosts;
    a.restHost = a.restHost || v.REST_HOST;
    this.serverTimeOffset = null;
    this.baseUri = this.authority = function(b) {
      return"https://" + b + ":" + (a.tlsPort || v.TLS_PORT)
    };
    this.auth = new da(this, a);
    this.channels = new Gb(this)
  }, Gb = function(a) {
    this.rest = a;
    this.attached = {}
  }, Hb = function() {
  };
  eb.prototype.stats = function(a, b) {
    void 0 === b && ("function" == typeof a ? (b = a, a = null) : b = Hb);
    var c = i.copy(i.defaultGetHeaders());
    this.options.headers && i.mixin(c, this.options.headers);
    ka.get(this, "/stats", c, a, b)
  };
  eb.prototype.time = function(a, b) {
    void 0 === b && ("function" == typeof a ? (b = a, a = null) : b = Hb);
    var c = i.copy(i.defaultGetHeaders());
    this.options.headers && i.mixin(c, this.options.headers);
    var d = this;
    Http.get(this, function(a) {
      return d.authority(a) + "/time"
    }, c, a, function(a, c) {
      if(a) {
        b(a)
      }else {
        var e = c[0];
        e ? (d.serverTimeOffset = e - Date.now(), b(null, e)) : (a = Error("Internal error (unexpected result type from GET /time"), a.statusCode = 500, b(a))
      }
    })
  };
  Gb.prototype.get = function(a) {
    var a = String(a), b = this.attached[a];
    b || (this.attached[a] = b = new Ka(this.rest, a));
    return b
  };
  var Ib = this.Rest = eb, fb = function(a) {
    Ib.call(this, a);
    a.wsHost = a.wsHost || v.WS_HOST;
    a.wsPort = a.encrypted ? a.tlsPort || v.TLS_PORT : a.port || v.PORT;
    this.connection = new Jb(this, a);
    this.channels = new La(this);
    this.connection.connect()
  }, La = function(a) {
    this.realtime = a;
    this.attached = {}
  };
  i.inherits(fb, Ib);
  fb.prototype.close = function() {
    e.logAction(e.LOG_MINOR, "Realtime.close()", "");
    this.connection.close()
  };
  La.prototype.onChannelMessage = function(a) {
    var b = a.channel;
    if(b) {
      var c = this.attached[b];
      if(c) {
        c.onMessage(a)
      }else {
        e.logAction(e.LOG_ERROR, "ConnectionManager on(channelmessage)", "received event for non-existent channel: " + b)
      }
    }else {
      e.logAction(e.LOG_ERROR, "ConnectionManager on(channelmessage)", "received event unspecified channel: " + b)
    }
  };
  La.prototype.retryChannelMessage = function(a) {
    var b = a.channel;
    if(b) {
      var c = this.attached[b];
      c ? c.retryMessage(a) : e.logAction(e.LOG_ERROR, "ConnectionManager on(channelmessage)", "received event for non-existent channel: " + b)
    }else {
      e.logAction(e.LOG_ERROR, "ConnectionManager on(channelmessage)", "received event unspecified channel: " + b)
    }
  };
  La.prototype.get = function(a) {
    var a = String(a), b = this.attached[a];
    b || (this.attached[a] = b = new $a(this.realtime, a, this.realtime.options));
    return b
  };
  this.Realtime = fb;
  var Ha;
  Ha = function(a, b, c, d) {
    this.previous = a;
    this.current = b;
    c && (this.retryIn = c);
    d && (this.reason = d)
  };
  var Jb, ua = function(a, b) {
    x.call(this);
    this.ably = a;
    this.connectionManager = new L(a, b);
    this.state = this.connectionManager.state.state;
    this.id = void 0;
    var c = this;
    this.connectionManager.on("connectionstate", function(a) {
      var b = c.state = a.current;
      i.nextTick(function() {
        c.emit(b, a)
      })
    })
  };
  i.inherits(ua, x);
  ua.prototype.on = function(a, b) {
    x.prototype.on.call(this, a, b);
    if(this.state == a && b) {
      try {
        b(new Ha(void 0, a))
      }catch(c) {
      }
    }
  };
  ua.prototype.connect = function() {
    this.connectionManager.requestState({state:"connecting"})
  };
  ua.prototype.close = function() {
    this.connectionManager.requestState({state:"closed"})
  };
  Jb = ua;
  var Ka, gb = function() {
  }, va = function(a, b) {
    e.logAction(e.LOG_MINOR, "Channel()", "started; name = " + b);
    x.call(this);
    this.rest = a;
    this.name = b
  };
  i.inherits(va, x);
  va.prototype.presence = function(a, b) {
    e.logAction(e.LOG_MICRO, "Channel.presence()", "channel = " + this.name);
    void 0 === b && ("function" == typeof a ? (b = a, a = null) : b = gb);
    var c = this.rest, d = !c.options.useTextProtocol, j = i.copy(i.defaultGetHeaders(d));
    c.options.headers && i.mixin(j, c.options.headers);
    ka.get(c, "/channels/" + this.name + "/presence", j, a, function(a, c) {
      a ? b(a) : d ? PresenceMessage.decodeTPresenceArray(c, b) : b(null, c)
    })
  };
  va.prototype.history = function(a, b) {
    e.logAction(e.LOG_MICRO, "Channel.history()", "channel = " + this.name);
    void 0 === b && ("function" == typeof a ? (b = a, a = null) : b = gb);
    var c = this.rest, d = !c.options.useTextProtocol, j = i.copy(i.defaultGetHeaders(d));
    c.options.headers && i.mixin(j, c.options.headers);
    ka.get(c, "/channels/" + this.name + "/history", j, a, function(a, c) {
      if(a) {
        b(a)
      }else {
        try {
          b(null, Serialize.TMessageArray.decode(c, d))
        }catch(e) {
          b(e)
        }
      }
    })
  };
  va.prototype.publish = function(a, b, c) {
    e.logAction(e.LOG_MICRO, "Channel.publish()", "channel = " + this.name + "; name = " + a);
    var c = c || gb, d = this.rest, a = {name:a, data:b}, b = i.copy(i.defaultPostHeaders(!1));
    d.options.headers && i.mixin(b, d.options.headers);
    ka.post(d, "/channels/" + this.name + "/publish", a, b, null, c)
  };
  Ka = va;
  var $a, w = function(a, b, c) {
    e.logAction(e.LOG_MINOR, "RealtimeChannel()", "started; name = " + b);
    Ka.call(this, a, b, c);
    this.presence = new Kb(this, c);
    this.connectionManager = a.connection.connectionManager;
    this.options = i.prototypicalClone(dc, c);
    this.state = "initialized";
    this.subscriptions = new x;
    this.pendingEvents = []
  }, J = "object" == typeof E ? E : require("../nodejs/lib/protocol/clientmessage_types"), T = J.TAction, la = function() {
  }, dc = {queueEvents:!0};
  i.inherits(w, Ka);
  w.invalidStateError = {statusCode:400, code:90001, reason:"Channel operation failed (invalid channel state)"};
  w.prototype.publish = function(a, b, c) {
    e.logAction(e.LOG_MICRO, "RealtimeChannel.publish()", "name = " + a);
    var c = c || la, d = this.connectionManager;
    L.activeState(d.state) ? (d = new J.TMessage, d.name = a, d.data = Data.toTData(b), "attached" == this.state ? (e.logAction(e.LOG_MICRO, "RealtimeChannel.publish()", "sending message"), a = new J.TChannelMessage, a.action = J.TAction.MESSAGE, a.channel = this.name, a.messages = [d], this.sendMessage(a, c)) : ("pending" != this.state && this.attach(), e.logAction(e.LOG_MICRO, "RealtimeChannel.publish()", "queueing message"), this.pendingEvents.push({message:d, listener:c}))) : c(d.getStateError())
  };
  w.prototype.onEvent = function(a) {
    e.logAction(e.LOG_MICRO, "RealtimeChannel.onEvent()", "received message");
    for(var b = this.subscriptions, c = 0;c < a.length;c++) {
      var d = a[c];
      b.emit(d.name, d)
    }
  };
  w.prototype.attach = function(a) {
    var a = a || la, b = this.connectionManager;
    L.activeState(b.state) ? "attached" == this.state ? a() : "failed" == this.state ? a(b.getStateError()) : (this.once(function(c) {
      switch(this.event) {
        case "attached":
          a();
          break;
        case "detached":
        ;
        case "failed":
          a(c || b.getStateError())
      }
    }), this.attachImpl()) : a(b.getStateError())
  };
  w.prototype.attachImpl = function(a) {
    e.logAction(e.LOG_MICRO, "RealtimeChannel.attachImpl()", "sending ATTACH message");
    this.state = "pending";
    var b = new J.TChannelMessage({action:J.TAction.ATTACH, channel:this.name});
    this.sendMessage(b, a || la)
  };
  w.prototype.detach = function(a) {
    var a = a || la, b = this.connectionManager;
    L.activeState(b.state) ? "detached" == this.state ? a() : (this.once(function(c) {
      switch(this.event) {
        case "detached":
          a();
          break;
        case "attached":
          a(UIMessages.FAIL_REASON_UNKNOWN);
          break;
        case "failed":
          a(c || b.getStateError())
      }
    }), this.detachImpl()) : a(b.getStateError())
  };
  w.prototype.detachImpl = function(a) {
    e.logAction(e.LOG_MICRO, "RealtimeChannel.attach()", "sending DETACH message");
    var b = new J.TChannelMessage({action:J.TAction.DETACH, channel:this.name});
    this.sendMessage(b, a || la)
  };
  w.prototype.subscribe = function() {
    var a = Array.prototype.slice.call(arguments);
    1 == a.length && "function" == typeof a[0] && a.unshift(null);
    var b = a[0], c = a[1], a = a[2] = a[2] || la, d = this.subscriptions;
    if(null === b || !i.isArray(b)) {
      d.on(b, c)
    }else {
      for(var e = 0;e < b.length;e++) {
        d.on(b[e], c)
      }
    }
    this.attach(a)
  };
  w.prototype.unsubscribe = function() {
    var a = Array.prototype.slice.call(arguments);
    1 == a.length && "function" == typeof a[0] && a.unshift(null);
    var b = a[0], a = a[1], c = this.subscriptions;
    if(null === b || !i.isArray(b)) {
      c.off(b, a)
    }else {
      for(var d = 0;d < b.length;d++) {
        c.off(b[d], a)
      }
    }
  };
  w.prototype.sendMessage = function(a, b) {
    this.connectionManager.send(a, this.options.queueEvents, b)
  };
  w.prototype.sendPresence = function(a, b) {
    var c = new J.TChannelMessage({action:J.TAction.PRESENCE, channel:this.name, presence:[a]});
    this.sendMessage(c, b)
  };
  w.prototype.onMessage = function(a) {
    switch(a.action) {
      case T.ATTACHED:
        this.setAttached(a);
        break;
      case T.DETACHED:
        this.setDetached(a);
        break;
      case T.PRESENCE:
        this.presence.setPresence(a.presence, !0);
        break;
      case T.MESSAGE:
        if(a = a.messages) {
          for(var b = Array(a.length), c = 0;c < b.length;c++) {
            var d = a[c];
            b[c] = new Db(d.channelSerial, d.timestamp, d.name, Data.fromTData(d.data))
          }
          this.onEvent(b)
        }
        break;
      default:
        e.logAction(e.LOG_ERROR, "RealtimeChannel.onMessage()", "Fatal protocol error: unrecognised action (" + a.action + ")"), this.connectionManager.abort(UIMessages.FAIL_REASON_FAILED)
    }
  };
  w.mergeTo = function(a, b) {
    var c = !1, d;
    if(a.channel == b.channel && (d = a.action) == b.action) {
      switch(d) {
        case T.MESSAGE:
          for(c = 0;c < b.messages.length;c++) {
            a.messages.push(b.messages[c])
          }
          c = !0;
          break;
        case T.PRESENCE:
          for(c = 0;c < b.presence.length;c++) {
            a.presence.push(b.presence[c])
          }
          c = !0
      }
    }
    return c
  };
  w.prototype.setAttached = function(a) {
    e.logAction(e.LOG_MINOR, "RealtimeChannel.setAttached", "activating channel; name = " + this.name);
    this.state = "attached";
    a.presence && this.presence.setPresence(a.presence, !1);
    this.emit("attached");
    try {
      if(this.pendingEvents.length) {
        var b = new J.TChannelMessage({action:J.TAction.MESSAGE, channel:this.name, messages:[]}), c = new sa;
        e.logAction(e.LOG_MICRO, "RealtimeChannel.setAttached", "sending " + this.pendingEvents.length + " queued messages");
        for(a = 0;a < this.pendingEvents.length;a++) {
          var d = this.pendingEvents[a];
          b.messages.push(d.message);
          c.push(d.callback)
        }
        this.sendMessage(b, c)
      }
      this.presence.setAttached()
    }catch(j) {
      e.logAction(e.LOG_ERROR, "RealtimeChannel.setSubscribed()", "Unexpected exception sending pending messages: " + j.stack)
    }
  };
  w.prototype.setDetached = function(a) {
    a.code ? (this.state = "failed", this.emit("failed", {statusCode:a.statusCode, code:a.code, reason:a.reason})) : (this.state = "detached", this.emit("detached"))
  };
  w.prototype.setSuspended = function(a) {
    e.logAction(e.LOG_MINOR, "RealtimeChannel.setSuspended", "deactivating channel; name = " + this.name);
    this.state = "detached";
    for(var b = 0;b < this.pendingEvents.length;b++) {
      try {
        this.pendingEvents[b].callback(a.defaultMessage)
      }catch(c) {
      }
    }
    this.pendingEvents = [];
    this.presence.setSuspended(a);
    this.emit("detached")
  };
  w.prototype.retryMessage = function(a) {
    switch(a.action) {
      case T.ATTACHED:
        this.attachImpl();
        break;
      case T.DETACHED:
        this.detachImpl();
        break;
      default:
        e.logAction(e.LOG_ERROR, "RealtimeChannel.retryMessage()", "Unable to retry action (" + a.action + "); ignoring")
    }
  };
  $a = w;
  var Kb, O = function(a, b) {
    x.call(this);
    this.channel = a;
    this.clientId = b.clientId;
    this.clients = {}
  }, hb = "object" == typeof E ? E : require("../nodejs/lib/protocol/clientmessage_types"), ib = hb.TPresenceState, ec = ["enter", "leave", "update"];
  i.inherits(O, x);
  O.prototype.enter = function(a, b) {
    if(!this.clientId) {
      throw Error("clientId must be specified to enter a presence channel");
    }
    this.enterClient(this.clientId, a, b)
  };
  O.prototype.enterClient = function(a, b, c) {
    e.logAction(e.LOG_MICRO, "Presence.enterClient()", "entering; channel = " + this.channel.name + ", client = " + a);
    this.clients[a] = b;
    a = new hb.TPresence({state:ib.ENTER, clientId:a, clientData:Data.toTData(b)});
    b = this.channel;
    switch(b.state) {
      case "attached":
        b.sendPresence(a, c);
        break;
      case "initialized":
        b.attach();
      case "pending":
        this.pendingPresence = {presence:a, callback:c};
        break;
      default:
        a = Error("Unable to enter presence channel (incompatible state)"), a.code = 90001, c(a)
    }
  };
  O.prototype.leave = function(a) {
    if(!this.clientId) {
      throw Error("clientId must have been specified to enter or leave a presence channel");
    }
    this.leaveClient(this.clientId, a)
  };
  O.prototype.leaveClient = function(a, b) {
    e.logAction(e.LOG_MICRO, "Presence.leaveClient()", "leaving; channel = " + this.channel.name + ", client = " + a);
    delete this.clients[a];
    var c = new hb.TPresence({state:ib.LEAVE, clientId:a}), d = this.channel;
    switch(d.state) {
      case "attached":
        d.sendPresence(c, b);
        break;
      case "pending":
        this.pendingPresence = {presence:c, callback:b};
        break;
      case "initialized":
        this.pendingPresence = null;
        c = Error("Unable to enter presence channel (incompatible state)");
        c.code = 90001;
        b(c);
        break;
      default:
        this.pendingPresence = null, b(V.failed)
    }
  };
  O.prototype.get = function(a) {
    return this.clients[a || this.clientId]
  };
  O.prototype.setPresence = function(a, b) {
    e.logAction(e.LOG_MICRO, "Presence.setPresence()", "received presence for " + a.length + " participants");
    for(var c = 0;c < a.length;c++) {
      var d = a[c], j = void 0, g = d.clientId;
      d.state == ib.LEAVE ? delete this.clients[g] : j = this.clients[g] = Data.toTData(d.clientData);
      b && this.emit(ec[d.state], g, j)
    }
  };
  O.prototype.setAttached = function() {
    this.pendingPresence && (e.logAction(e.LOG_MICRO, "Presence.setAttached", "sending queued presence; state = " + this.state), this.channel.sendPresence(this.pendingPresence.presence, this.pendingPresence.callback), this.pendingPresence = null)
  };
  O.prototype.setSuspended = function(a) {
    this.pendingPresence && (this.pendingPresence.callback(V[a.state]), this.pendingPresence = null)
  };
  Kb = O;
  var I = function(a, b, c) {
    c.binary = !1;
    u.call(this, a, b, c);
    Ably._ = {}
  };
  i.inherits(I, u);
  I.isAvailable = function() {
    return!0
  };
  L.httpTransports.jsonp = L.transports.jsonp = I;
  var ma = null;
  I.checkConnectivity = function(a) {
    ma ? ma.push(a) : (ma = [a], new I.Request("http://live.cdn.ably-realtime.com/is-the-internet-up.js", null, null, !1, "isTheInternetUp", function(a, c) {
      for(var d = !a && c, e = 0;e < ma.length;e++) {
        ma[e](null, d)
      }
      ma = null
    }))
  };
  I.tryConnect = function(a, b, c, d) {
    var j = new I(a, b, c), g = function(a) {
      d(a)
    };
    j.on("error", g);
    j.on("preconnect", function() {
      e.logAction(e.LOG_MINOR, "JSONPTransport.tryConnect()", "viable transport " + j);
      j.off("error", g);
      d(null, j)
    });
    j.connect()
  };
  I.prototype.toString = function() {
    return"JSONPTransport; uri=" + this.baseUri + "; isConnected=" + this.isConnected
  };
  I.prototype.request = function(a, b, c, d, e) {
    return new I.Request(a, b, c, d, !1, e)
  };
  var fc = 0;
  I.Request = function(a, b, c, d, e, g) {
    var k = Ably._;
    this.callback = g;
    var h = this.requestId = fc++, i = this.timer = setTimeout(d ? v.cometRecvTimeout : v.cometSendTimeout, function() {
      l.abort()
    }), b = b || {};
    b.callback = "Ably._._" + h;
    c ? b.body = encodeURIComponent(c) : delete b.body;
    var m = document.createElement("script");
    m.async = !0;
    m.onerror = function() {
      l.abort()
    };
    m.src = u.paramStr(b, a);
    var l = this;
    Ably._["_" + h] = function(a) {
      clearTimeout(i);
      delete k["_" + h];
      l.aborted || (m.parentNode.removeChild(m), g(null, a))
    };
    a = document.getElementsByTagName("script")[0];
    a.parentNode.insertBefore(m, a);
    this.script = m
  };
  I.Request.prototype.abort = function() {
    clearTimeout(this.timer);
    this.aborted = !0;
    delete Ably._["_" + this.requestId];
    this.callback(Error("JSONPTransport: requestId " + this.requestId + " aborted"))
  };
  Http.Request = I.Request;
  var C = function(a, b, c) {
    c.binary = c.binary && C.binary;
    u.call(this, a, b, c)
  }, Lb = function() {
    var a = new XMLHttpRequest;
    return"withCredentials" in a ? a : "undefined" !== typeof XDomainRequest ? new XDomainRequest : null
  };
  i.inherits(C, u);
  C.isAvailable = function() {
    if(!Lb()) {
      return!1
    }
    C.binary = !1;
    return!0
  };
  C.checkConnectivity = function(a) {
    new C.Request("http://live.cdn.ably-realtime.com/is-the-internet-up.txt", null, null, !1, function(b, c) {
      a(null, !b && "yes" == c)
    })
  };
  C.tryConnect = function(a, b, c, d) {
    var g = new C(a, b, c), h = function(a) {
      d(a)
    };
    g.on("error", h);
    g.on("preconnect", function() {
      e.logAction(e.LOG_MINOR, "XHRTransport.tryConnect()", "viable transport " + g);
      g.off("error", h);
      d(null, g)
    });
    g.connect()
  };
  C.prototype.request = function(a, b, c, d, e) {
    return new C.Request(a, b, c, d, this.binary, e)
  };
  C.prototype.toString = function() {
    return"XHRTransport; uri=" + this.baseUri + "; isConnected=" + this.isConnected
  };
  C.Request = function(a, b, c, d, e, g) {
    var a = u.paramStr(b, a), h, i, m;
    c ? (b = "POST", h = 201) : (b = "GET", h = 200);
    var l = this.xhr = Lb();
    e && (l.responseType = "arraybuffer");
    var q = setTimeout(d ? v.cometRecvTimeout : v.cometSendTimeout, function() {
      m = !0;
      l.abort()
    });
    l.open(b, a, !0);
    l.setRequestHeader("Accept", e ? "application/x-thrift" : "application/json");
    l.onerror = function(a) {
      a.code = 8E4;
      g(a)
    };
    l.onabort = function() {
      i = Error(m ? "Request timed out" : "Request cancelled");
      i.statusCode = 404;
      i.code = 8E4;
      g(i)
    };
    l.onreadystatechange = function() {
      if(4 == l.readyState) {
        if(clearTimeout(q), i) {
          g(i)
        }else {
          if(l.status == h) {
            var a = null;
            e ? l.response && (a = new B, a.buf = l.response, a.view = new DataView(a.buf)) : a = l.responseText;
            g(null, a)
          }else {
            0 != l.status && (i = Error("Unexpected response: statusCode = " + l.status), i.statusCode = l.status, i.code = 8E4, i.statusText = l.statusText, g(i))
          }
        }
      }
    };
    l.send(c)
  };
  C.Request.prototype.abort = function() {
    this.xhr && this.xhr.abort()
  };
  C.isAvailable() && (L.httpTransports.xhr = L.transports.xhr = C, Http.Request = C.Request);
  var U = function(a, b, c) {
    c.binary = !1;
    z.call(this, a, b, c)
  }, gc = "object" == typeof window;
  i.inherits(U, z);
  U.isAvailable = function() {
    return gc && Z && 10 <= Z.getFlashPlayerVersion().major && Fa
  };
  U.isAvailable() && (L.transports.flash_socket = U);
  U.tryConnect = function(a, b, c, d) {
    Fa.__initialize(v.flashTransport.swfLocation);
    var g = new U(a, b, c);
    errorCb = function(a) {
      d(a)
    };
    g.on("wserror", errorCb);
    g.on("wsopen", function() {
      e.logAction(e.LOG_MINOR, "FlashTransport.tryConnect()", "viable transport " + g);
      g.off("wserror", errorCb);
      d(null, g)
    });
    g.connect()
  };
  U.prototype.createWebSocket = function(a, b) {
    var c = 0;
    if(b) {
      for(var d in b) {
        a += (c++ ? "&" : "?") + d + "=" + b[d]
      }
    }
    this.uri = a;
    c = this.params.options;
    return new Fa(a, [], c.proxyHost, c.proxyPort)
  };
  U.prototype.toString = function() {
    return"FlashTransport; uri=" + this.uri
  };
  window.Ably = {Realtime:this.Realtime}
})();
